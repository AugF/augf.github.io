<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"augf.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. 概览  算法学习分为这几类：  level 1 语法课, 直接题库搜索&quot;语法课&quot;即可进行练习 &gt; https:&#x2F;&#x2F;www.acwing.com&#x2F;problem&#x2F;search&#x2F;1&#x2F;?csrfmiddlewaretoken&#x3D;msUJJ5LtxRvIldBlsslvchYSw8Grn8UdIM32F2WtpNs1WitNTjsvLznTVFof8cW2&amp;search_con">
<meta property="og:type" content="article">
<meta property="og:title" content="algorithm acwing improve class">
<meta property="og:url" content="https://augf.github.io/2019/09/16/algorithm-acwing-improve/index.html">
<meta property="og:site_name" content="Life&#39;s Notes">
<meta property="og:description" content="1. 概览  算法学习分为这几类：  level 1 语法课, 直接题库搜索&quot;语法课&quot;即可进行练习 &gt; https:&#x2F;&#x2F;www.acwing.com&#x2F;problem&#x2F;search&#x2F;1&#x2F;?csrfmiddlewaretoken&#x3D;msUJJ5LtxRvIldBlsslvchYSw8Grn8UdIM32F2WtpNs1WitNTjsvLznTVFof8cW2&amp;search_con">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-09-16T06:57:57.000Z">
<meta property="article:modified_time" content="2021-05-27T01:05:35.000Z">
<meta property="article:author" content="Yun-Pan Wang">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="acwing">
<meta property="article:tag" content="improve">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://augf.github.io/2019/09/16/algorithm-acwing-improve/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>algorithm acwing improve class | Life's Notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Life's Notes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">岁月数载，愿不负韶华</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/16/algorithm-acwing-improve/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          algorithm acwing improve class
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-16 14:57:57" itemprop="dateCreated datePublished" datetime="2019-09-16T14:57:57+08:00">2019-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/" itemprop="url" rel="index"><span itemprop="name">acwing</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/improve/" itemprop="url" rel="index"><span itemprop="name">improve</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="概览">1. 概览</h2>
<ol type="1">
<li>算法学习分为这几类：
<ul>
<li>level 1 语法课, 直接题库搜索"语法课"即可进行练习 &gt;
https://www.acwing.com/problem/search/1/?csrfmiddlewaretoken=msUJJ5LtxRvIldBlsslvchYSw8Grn8UdIM32F2WtpNs1WitNTjsvLznTVFof8cW2&amp;search_content=%E8%AF%AD%E6%B3%95%E9%A2%98</li>
<li>level 2 算法基础课</li>
<li>level 3 算法提高课 算法的应用
<ul>
<li>题目--&gt; 模型 ---&gt;
相似的题目(因为整理的人太少，所以这里暂时以题目为主) 题谱</li>
</ul></li>
</ul></li>
<li>算法题考查两部分的内容：
<ol type="1">
<li>思维</li>
<li>写代码的熟练度</li>
</ol></li>
<li>非常好的网站: 衡阳七中 &gt; 看延迟，直接看时间就可以了</li>
</ol>
<h2 id="dp">2. DP</h2>
<h3 id="数字三角形">2.1 数字三角形</h3>
<ol type="1">
<li>basic
<ul>
<li>采花生问题 &gt; 从集合角度来考虑问题,
一个集合就代替了暴搜中的一个元素
<ul>
<li>状态表示 f[i, j]
<ul>
<li>集合： 所有从(1, 1)走到(i, j)的路线</li>
<li>属性： Max/Min/数量： 集合中所有集合的每个元素的最大值； &gt;
于是f(n, m)就是目标值; 计算该值实际上就是寻找一个拓扑排序</li>
</ul></li>
<li>状态计算： 集合划分 分而治之 &gt; 依据最后一步来划分
<ul>
<li>划分依据
<ul>
<li>不重复（最值无所谓，数量必须要）</li>
<li>不漏（所有的都必须考虑） &gt; 本题图的连通性</li>
</ul></li>
</ul></li>
</ul></li>
<li>最低通行费： 最大值往往不需要初始化，最小值需要进行考虑</li>
</ul></li>
<li>improve
<ul>
<li>方格取数：难点在于如何考虑走两次
<ul>
<li>走两次： 同时走 &gt; f[i1, j1, i2, j2]表示所有从(1,1),
(1,1)分别走向(i1,j1),(i2,j2)的路径的最大值。
<ul>
<li>如何处理“同一个格子不能被重复选择” &gt;
只有在i1+j1=i2+j2时，两条路径的格子才可能重合；一开始考虑使用f[i1, j1,
i2, j2], 但是发现可以少一维的变量!!! &gt; f[k, i1, i2]表示所有从(1,1),
(1,1)分别走到(i1, k-i1), (i2, k-i2)的路径的最大值，
k表示两条路线当前走到的格子的横纵坐标之和</li>
<li>状态计算： 集合划分=下+下， 下+右， &gt; (1,1)-&gt; (i1-1, j1),
(i2-1,j2) -&gt; (i1, j1), (i2, j2)
<ul>
<li>集合划分 &gt; 将(1,1)到(k, i1, i2)的路分为两种 &gt; (1,1)--&gt;
(i1-1, j1) -&gt; (i1, j1) &gt; (1,1)--&gt; (i2-1, j2) -&gt; (i2, j2)
&gt; f(k-1, i1-1, i2-1), 根据(i1,j1),(i2,j2)是否是同一个格子，重合 w(i1,
j1); 不重合， w(i1, j1)+w(i2, j2)
<ul>
<li>1： 下， 2： 下</li>
<li>1： 下， 2： 右</li>
<li>1： 右， 2： 下</li>
<li>1： 右， 2: 右</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<h3 id="最长上升子序列问题">2.2 最长上升子序列问题</h3>
<p>LIS(longest increase subsequence) 1017 怪盗基德 1014 登山，482
合唱队形 1012 友好城市 1016 最大上升子序列 1010(+贪心) 拦截导弹
187(+dfs) 导弹防御系统 272(LCS) 最长公共上升子序列</p>
<h4 id="basic">2.2.1 basic</h4>
<p>895: 最长上升子序列问题 - 状态表示f[i] - 集合：
所有以a[i]结尾的严格单调上升子序列 - 属性： Max - 状态计算 -
划分依据：最后一个不同的点。 &gt;
如果不能在前面很快判断，那么最基本的想法就是枚举来做，空</p>
<blockquote>
<p>LLS实际上可以从n^2转化为nlogn, 实际与后面的一步的转化。 优化？</p>
</blockquote>
<p>272： 最长上升公共子序列 f[i,j] - 集合：
所有由第一个序列的前i个字母，第二个序列的前j个字母,
且以b[j]结尾的构成的公共子序列，Max &gt; 注意这里要加条件 - 状态计算：
1. 所有包含a[i]的公共上升子序列 a[i]==b[j] &gt; 按照倒数第2类划分，
序列倒数第1个数时null, b[1], b[2], .., b[j-1] &gt; 进行枚举 f[i,k] + 1
因为b[j]大于，所以实际上就是 2. 所有不包含a[i]的公共上升子序列 f[i-1,
j]</p>
<h2 id="背包问题-背包九讲">3. 背包问题： 背包九讲</h2>
<p>01背包： 体积vi, 价值wi, 求各种放法，使得背包的总价值最大 ### 3.1
basic - 01背包 - 完全背包 - 多重背包I - 多重背包问题II + 二进制 -
多重背包问题III + 单调队列（滑动窗口求最值） - 混合背包 - 分组背包 -
有依赖背包 + 树形DP - 二维费用的背包问题 - 求具体方案 - 求方案数</p>
<p>简单回顾</p>
<p>线性DP 序列DP: 包含选出来的一些数，相邻的数之间有一些关系 背包问题:
序列问题， 组合问题DP， 不考虑相邻元素之间的关系，考虑全局</p>
<p>01背包问题：每个物品选择或者不选
f[i,j]所有只从前i个物品中选，且总体积不超过j的选法的集合 划分： 1.
选择第i个物品的所有方案 f[i-1,j-v_i] + w_i 2. 不选择第i个物品的方案
f[i-1,j]</p>
<p>完全背包问题： 每个物品选0，1，2，.. 个 f[i,j]所有
只从前i个物品中选择，且总体积不超过j的选法 f[i,j] = max(f[i-1,j],
f[i,j-v]+w)
一般当空间优化成1维后，只有完全背包问题的体积是从小到大循环的 for 物品
for 体积 for 决策</p>
<p>多重背包问题： 每个物品选0，..., si个</p>
<p>规律：当空间优化到1维之后，只有完全背包问题的体积是从小到大循环的。
完全背包问题：某个物品的个数可以选任意个 &gt; f[i, j] = max(f[i - 1, j],
f[i, j-v[i]]) ! 只有这种情况是从小到大循环的。</p>
<p>多重背包问题：某个物品的个数给定 &gt;
实际上，可以看作滑动窗口，这里对应的代码 todo &gt; 实际上，解法1：
f[i,j]使用二维，直接枚举；
f[j]使用一维，使用二进制优化转化为01背包问题。</p>
<p>分组背包问题： 每组中选择一个物品 &gt; f[i,j]
这里的i的含义为从前i组进行选择</p>
<p>面试算法题，设计题</p>
<blockquote>
<p>万能头文件 #include&lt;bits/stdc++.h&gt;
需要注意的就是这样做会导入很多文件，等于说会耗时</p>
</blockquote>
<h3 id="further">3.2 further</h3>
<ul>
<li>01背包
<ul>
<li>采药</li>
<li>装箱问题</li>
<li>小精灵（阅读理解）</li>
<li>数字组合（方案数）</li>
<li>开心的金明</li>
<li>能量石（+贪心）</li>
</ul></li>
<li>完全背包
<ul>
<li>买书（方案数）</li>
<li>货币系统（方案数）
<ul>
<li>货币系统（贪心）</li>
</ul></li>
<li>二维费用
<ul>
<li>潜水员</li>
</ul></li>
</ul></li>
<li>多重背包
<ul>
<li>庆功会</li>
</ul></li>
<li>分组背包
<ul>
<li>机器分配</li>
</ul></li>
</ul>
<p>思维过程，编程能力</p>
<p>背包问题 1. 货币系统 1021 2. 货币系统 532 3. 混合背包问题 4.
有依赖的背包问题 5. 背包问题求方案数 6. 能量石 kickstart</p>
<p>三种背包问题的状态表示都是一样的</p>
<p>动态规划 集合全部都是只从前i件物品中选，且总体积不超过j的选法的，
价值的最大值</p>
<ol type="1">
<li>状态计算</li>
</ol>
<ul>
<li>01背包： f[i,j] = max(f[i-1,j], f[i-1, j-v]+w)</li>
<li>完全背包： f[i,j] = max(f[i-1,j], f[i,j-v] + w)</li>
<li>多重背包： f[i,j] = max(f[i-1,j], f[i-1, j-v[i]] + w[i],
f[i-1,j-2v[i]]+2w[i],... ,f[i-1,j-sv[i]]+s*w[i])</li>
</ul>
<p>不需要考虑前i件物品，只需要从第i件物品类型来分析。</p>
<p>k个数进行划分，如果没有依赖关系的话，有2^k种选择。如果有的话，会大大减少依赖关系。所以直接按m来划分。</p>
<p>把每个子树看作是一个物品组</p>
<h2 id="备注">备注</h2>
<p>链表可以直接用结构体和指针来做，实际上都可以用数组来进行模拟。 &gt;
为什么要用数组，效率高！ &gt; 用struct Node{int val; Node *next;}
每次都要new一个新节点，效率非常低</p>
<p>分类 1. 单链表 - 邻接表： 用来存储图和树 2. 双链表：
用来优化某些题</p>
<ol start="3" type="1">
<li>怎么预留，把动态规划的操作留到最后一步去，看来还是dfs最牛！</li>
</ol>
<h2 id="最多-vs-恰好-vs-至少">最多 vs 恰好 vs 至少</h2>
<ol type="1">
<li>体积最多是j,Max： 全部为0， V&gt;=0</li>
<li>体积恰好是j, Min: f[0]=0, f[i]=+inf V&gt;=0</li>
<li>体积至少是j, Min: f[0]=0, f[i]=+inf
f[j][k]=min(f[j][k],f[max(0,j-v1)][max(0,k-v2)]+w); &gt;
初始化为+inf或者-inf, 自己上是为了不使用它的值 &gt;
https://www.acwing.com/activity/content/code/update/133054/ &gt;
潜水员问题，记得多看几遍</li>
</ol>
<p>怎么写快速判断-1，~i，取反后即全为0</p>
<p>有依赖的背包问题 树形DP</p>
<h2 id="状态机模型">状态机模型</h2>
<p>多种状态，状态其实是一系列有序的事件。</p>
<p>状态机描述的是一个过程？ &gt; 买入到买出</p>
<p>背包是一个结果</p>
<p>另类状态表示 - 状态机 - 状态DP</p>
<p>以前状态计算的时候只有一个状态，现在相当于</p>
<p>状态机的想法是完全转换为当前步依赖于前一步，然后讲前一步划分为各个状态，进而清晰的表示</p>
<p>状态DP是当前很难用维度表示，所以将状态压缩为数字进行表示</p>
<p>注意状态机入口也是一个很重要的部分。表明允许从哪里接入和从哪里结束</p>
<p>一维一般不用考虑至少，恰好，至多之类的东西</p>
<h3 id="题目概览">题目概览</h3>
<ol type="1">
<li>大盗阿福 &gt; 一个序列，序列中的两个数不能连续选择</li>
<li>股票买卖IV &gt; 股票某天买入，某天卖出；
交易不能重合；问怎么交易最好</li>
<li>股票买卖V &gt; 卖出后有一个冷冻期</li>
<li>设计密码： kmp + 状态DP &gt; 在一维上跳动
<ul>
<li>kmp: 匹配的模板串，前缀与后缀相等所以可以移动位置
<ol type="1">
<li>约定从1开始</li>
<li>ne[i]=j: p[1,..j]=p[i-j+1,i];</li>
<li>基准： i-1与j匹配， i与j+1不匹配， 所以每轮比较的是i与j+1
<ul>
<li>失配： 失配时最少移动距离，新的已匹配下标就是ne[j];
然后再看下一个点i与j+1是否匹配，如果不匹配，继续失配递归处理</li>
<li>匹配
<ul>
<li>i==n: 输出结果</li>
</ul></li>
</ul></li>
<li>如何找ne[]: &gt; 其实就是自己串跟自己串比较；然后ne[1]=0,
递归生成；其实就是模板匹配的过程，不断地比较，处理适配，当将p[i]与p[j+1]匹配时，实际是就是p[1,..,j]
== p[i-j+1,...,i], 即直接赋值ne[i]=j;</li>
</ol></li>
</ul></li>
<li>修复DNA： AC自动机=trie+kmp和状态DP的结合 &gt; 在二维上跳动</li>
</ol>
<h2 id="状态压缩dp">状态压缩DP</h2>
<h3 id="棋盘式基于连通性">1. 棋盘式（基于连通性）</h3>
<p>对于棋盘，当前这行怎么枚举，只需要考虑上行的状态即可</p>
<ol type="1">
<li>骑士 &gt; 井字形方格约束, 记i行状态为a，i-1行状态为b
<ul>
<li>a&amp;b==0: a,b不能有相邻</li>
<li>(a|b) 不能有相邻</li>
</ul></li>
<li>玉米田 &gt; 某些地不能种</li>
<li>炮兵布阵 &gt; 相邻的多个行或者列不能种</li>
<li>愤怒的小鸟 &gt;
关键分析两个点确定抛物线，然后查看每个抛物线能覆盖哪些顶点。DP的想法实际上是从0到最终覆盖，对非0的点进行选择，来覆盖对应的选择，即状态划分过程。</li>
</ol>
<h2 id="区间dp">区间DP</h2>
<p>感觉就是一堆数，可以按某种要求进行合并。合并在一起是具有代价的。目标就是问怎样合并能够使得总代价最小</p>
<ol type="1">
<li>环形DP</li>
<li>记录方案数</li>
<li>高精度</li>
<li>二维区间DP</li>
</ol>
<ul>
<li>石子合并 &gt;
一个线段上的多个数最终合并为一个数。然后可以按区间合并，看合并的代价。
<ul>
<li>集合： f[i,j]: 所有从i到j和并的最小值。</li>
<li>状态计算： 按照最后一步进行划分，就是两个点的分界点 &gt; !!! 分界点,
min(f[l,k]+f[k+1,r]+s[l,r])</li>
</ul></li>
</ul>
<p>环形石子合并 加分二叉树：区间DP的方案数 棋盘分割：二维DP 凸多边形：
高精度 能量项链</p>
<h2 id="树形dp">树形DP</h2>
<p>DP问题的实质是用一个点表示一类情况
树形DP的本质是用当前节点表示所包含子树的所有情况</p>
<ol type="1">
<li><p>树的直径 &gt; 对于无权边而言</p>
<ul>
<li>任取一点作为起点，找到距离该点最远的一个点u, DFS</li>
<li>再找到距离u最远的一个点 DFS, BFS(DFS费空间)</li>
<li>那么u和v之间的路径就是一条直径 &gt; 证明:
这个过程还是很有意思的。利用的树一定是连通的，所以直接设置a-&gt;u的论据，和一条最短直径的相互比较即可退出矛盾</li>
<li>DP 一般做法</li>
</ul></li>
<li><p>树的中心：求最远距离的最小值。有上下两个地方的衡量，使用数组保存结果来解决问题</p></li>
<li><p>数字转换：使用筛法预处理出因素和，建模为求树上的某条最远路径</p></li>
<li><p>二叉苹果树： 有依赖的背包问题：
有依赖？选背包时选择某一件物品就必须选择另一件物品</p></li>
<li><p>战略游戏： &gt; vs 没有上司的舞会：
每条边最多选一个点，求最大权值 &gt; 战略游戏：
每条边至少选一个点，求最小权值</p></li>
<li><p>皇宫守卫</p></li>
</ol>
<h2 id="数位dp">数位DP</h2>
<p>DP问题的技巧: 基本上问的都是区间问题 1. 技巧1：f[N]: 1~N &gt; [X, Y]:
f[Y] - f[X - 1] 前缀和 2. 技巧2：尽量用树的方式考虑</p>
<p>本质上其实都还是排列组合数，但是不大好用排列组合来求
方案，分情况讨论</p>
<ol type="1">
<li><p>度的数量：
就像摘苹果一样，每一个苹果都要小心翼翼地摘，不要漏了，也不要重了</p></li>
<li><p>不降数 ## 单调队列/单调栈/其它数据结构优化的DP</p></li>
</ol>
<p>解决问题有限，求滑动窗口中的值。
首尾端点不需要固定，只需要都保持严格递增就可以</p>
<p>把队列中所有冗余的元素去掉，会发现队列有单调的性质
其实，如果是最小值，往往对应的是单调上升序列</p>
<ol type="1">
<li>朴素DP原理：正确性</li>
<li>DP优化，代码等价变形，观察代码</li>
</ol>
<h2 id="斜率优化dp">斜率优化DP</h2>
<h3 id="集合">2. 集合</h3>
<h3 id="对比">对比</h3>
<p>状态压缩DP是将所有的状态用一个二进制来表示了</p>
<h2 id="搜素">3. 搜素</h2>
<h3 id="bfs">3.1 BFS</h3>
<p>应用型算法，题目变化很多，题型很多</p>
<p>最核心的问题： 1. “求最小” 2. 基于迭代，不会爆栈</p>
<ol type="1">
<li><p>迷宫：最短距离 &gt; 可以从地图的一个点到达另一个点</p></li>
<li><p>八数码：最小步数 &gt;
把整个地图看作是一个状态，实际上求的就是从一个状态到达另一个状态的</p></li>
</ol>
<h4 id="flodd-fill">3.1.1 Flodd Fill</h4>
<p>洪水覆盖</p>
<p>水可以向周围覆盖。覆盖过的格子又可以覆盖。</p>
<p>不断加入新的格子，直到不能覆盖。</p>
<p>可以在线性时间复杂度内，找到某个点所在的连通块。
100个格子会导致爆栈</p>
<p>在生产空间，栈内存可以设定到内存一样大的 默认1M.
1M/每一层的空间=最大层</p>
<p>算法：思维+代码</p>
<p>常见的连通有两种： 1. 四连通： 只要有公共边就叫连通 人们常认为的模型
2. 八连通： 只要有公共点就叫连通 八连通</p>
<h4 id="最短路模型">3.1.2 最短路模型</h4>
<p>这里实际上是所有边权都一样的最短路模型</p>
<p>单源最短路</p>
<p>在线性时间内，可以得到所有点到某点的最短路</p>
<p>如何输出路径？</p>
<p>对于路径的数组，其实可以pre数组。</p>
<p>因为BFS本身就是按层搜，所以不用其他算法一样存储距离
很多时候从哪个点开始，其实只是为了最后处理结果方便一点而已</p>
<p>!!! BFS实际上就是每条边权为1的最短路模型</p>
<p>为什么可以？
其实来源于迪杰斯特拉最短路算法，它本身是维护一个优先队列，取队列中的最大值和最小值。而当边的权重都是1的时候。BFS所维护的队列就是一个单调增的队列，也就是说队头最小值，队尾最大值</p>
<p>BFS队列中的顺序实际上就是到起点的距离递增的顺序来扩展的</p>
<p>队列： 1. 两段性：最多有两段 2. 单调性： 初始， 假设</p>
<p>证明队首出队的元素一定是最小值 &gt;
反证法，如果出队的元素不是最小值，那么一定是由队列中后面的元素，转了一圈后，然后连接到该点。而由队列的单调性，后面所描述的距离一定是大于之前的距离的，所以矛盾。</p>
<p>每个元素只会入队一次，入队后值就确定，等于说它的值只会被更新一次。</p>
<h4 id="多源bfs">3.1.3 多源BFS</h4>
<p>实际上就是把所有多源路径距离置为0，添加到队列中即可</p>
<h4 id="最小步数模型">3.1.4 最小步数模型</h4>
<p>第二类的最短路的模型</p>
<ol type="1">
<li>如何存状态？ hash法，map(c++11) &gt; 康拓展开, map,
unordered_map</li>
</ol>
<p>思路：
将整个棋盘压缩成的状态。每次按搜索策略搜索，每个走过的状态标记下已经走过。直到到达最终状态为止。</p>
<h4 id="双端队列广搜">3.1.5 双端队列广搜</h4>
<p>专门用来处理边权为0或1的图。</p>
<p>怎么理解？ 将边权为0的放到队列开头，边权为1的放到队列结尾。
仍然满足单调性、两段性</p>
<p>这里因为有边权为0的边的存在，一个点可能会更新多次 #### 3.1.6
双向广搜</p>
<p>对于第二类算法，其实它总共有的状态数为格子的阶乘，太多了</p>
<p>宽搜，因为会存储当前层元素，所以会MLE. 如果状态太多，也会TLE.</p>
<p>实际上，每一层元素是呈指数上升的</p>
<p>双向搜素为什么有效？ 其实可以通过图来观察搜素空间，是变小的</p>
<p>一种直观的感受 6^10, 2*6^5</p>
<p>一般来说，只会用到最小步数模型。</p>
<p>一个优化，每次选择当前队列扩展元素较小的方向来扩展 #### 3.1.7 A*</p>
<p>目标跟双向广搜是一样的</p>
<p>队列换成优先队列， 小根堆</p>
<p>小根堆：
关键字：真实距离（从起点走到当前点的真实距离）+估价距离（从当前点到终点的估计距离）</p>
<p>选一个关键字最小的t 当终点第一次出队时 break; for t的所有邻边:
将邻边入队, 更新距离</p>
<p>图中所有边权都是任何都可以，只要没有非负回路？</p>
<p>迪杰斯特拉算法: 所有估价距离都取0的算法</p>
<p>成立条件：</p>
<p>d(state) + g(state) d(state) + f(state)</p>
<p>f(state) &lt;= g(state)：估价函数小于真实函数 必须要有解才能用
无解的话也需要对所有状态操作一遍，而且由于相比于BFS使用的队列是nlogn,
所以更耗时</p>
<p>如何证明成立？ 假设出队的元素，最小的为dist, 它不是最小的 即 dist
&gt; d最优 那么必然存在最优路径上的某个点u（起点一定在上面）, d[u]+f[u]
&lt;= d[u]+g[u]=d最优。</p>
<p>而队列中最优距离一定是最小的数，即d[u]+f[u]一定是最小的， dist &lt;=
d[u]+f[u] &lt;= d最优， 矛盾</p>
<p>只能保证终点出队的时候，终点一定是最优的点 &gt;
算法进阶指南写错的一点 &gt; 其实是最优路径上的点都是最优</p>
<p>对于其他点，入队出队都不一定是最优距离 <!--  -->
每个点也并不是只扩展一次, 每个点入队多次 Dijkstra f in [0, g]</p>
<p>BFS: 入队的时候判重， 即不再使用<br />
Dijkstra: 出队的时候判重 A*: 出队后不能判重，终点出队才能判重</p>
<p>估计距离： 能用A*算法题目不多</p>
<p>spfa可能会搜索空间多 A*是为了尽可能减少搜索空间</p>
<h5 id="八数码">八数码</h5>
<p>估价函数为当前点的位置与真实位置的曼哈顿距离之和</p>
<h3 id="dfs">3.2 DFS</h3>
<h4 id="dfs之连通性模型和搜索顺序">3.2.1 DFS之连通性模型和搜索顺序</h4>
<p>BFS: 队列 1. 连通性 2. 内部的某个部分能否走到另一个部分 3.
整个看成一个整体 4. 搜索空间减小</p>
<p>DFS: 代码短，但是第一次到达某个点
时间复杂度都是一样的，每个点只需要遍历一次</p>
<p>注意爆栈问题，输入一个数据，想一下会不会在极限情况下爆栈</p>
<p>手动地把递归改为非递归</p>
<p>注意两种模型： 一种是棋盘内部搜索。棋盘内每个点只需要搜索一次，
内部搜索
一种是整个棋盘搜索（对于这种类型时需要恢复现场的），外部搜索</p>
<p>外部搜索即可以处理路径数的问题，又可以处理最优化的问题</p>
<p>暴搜： 2^n, NP完全问题</p>
<h4 id="dfs之剪枝优化">3.2.2 DFS之剪枝优化</h4>
<p>常用的剪枝策略 1.
优化搜索顺序：大部分情况下，我们应该优先搜索分支较少的节点 2.
排除等效冗余：不考虑顺序的情况下，尽可能使用组合 3.
可行性剪枝：搜索到一半发现不合法，提前退出 4.
最优性剪枝：无论如何当前搜索到的结果都比最优取值差，剪枝 5.
记忆化搜索(DP) *</p>
<h3 id="迭代加深">3.3 迭代加深</h3>
<p>BFS:
宽搜的空间复杂度，因为需要把每一层中的所有元素存下来，所以是指数级别的
DFS: O(n)</p>
<p>max_depth 逐步扩大，从0开始</p>
<p>设置一个max_depth, 走完一个，然后再走一个</p>
<p>DFS: 具体的时间复杂度估计就行了，很难具体量算</p>
<h2 id="最短路问题">4. 最短路问题</h2>
<p>最难的点在于问题的转化和抽象 0.7</p>
<p>最大流是更难的一点</p>
<h3 id="单源最短路">4.1 单源最短路</h3>
<ol type="1">
<li>边权均非负
<ul>
<li>朴素Dijkstra: 稠密图，效率高 &gt;
其实就是单源最短路问题：从一个点开始扩展，不断扩展到所有点</li>
<li>堆优化Dijkstra: 稀疏图</li>
</ul></li>
<li>有负权边
<ul>
<li>Bellmair Ford</li>
<li>Spfa</li>
</ul></li>
</ol>
<p>综合运用：和DFS, 二分， DP, 拓扑排序结合</p>
<h3 id="多源最短路">4.2 多源最短路</h3>
<p>关键：使用距离的三角不等式来做各种问题</p>
<p>使用最短路来试图解决某些动态规划问题</p>
<p>floyd floyd: 多源最短路</p>
<ol type="1">
<li>最短路</li>
<li>传递闭包</li>
<li>找最小环</li>
<li>恰好经过k条边的最短路：倍增的思想</li>
</ol>
<p>floyd的原理： d[i,j]==inf, d[i,i]=0 for k: 1..n for i: 1..n for j:
1...n d[i,j]=min(d[i,k]+d[k,j]</p>
<p>floyd, bellman_ford: DP dijkstra: 贪心</p>
<p>d[k,i,j]:
所有从i出发，最终走到j，且中间只经过节点编号不超过k的所有路径 &gt;
注意理解是节点标号. 不包含i,j 路径长度最小值</p>
<p>集合划分 1. 中间经过k: 经过i-&gt;k. d[k-1,i, k]+d[k-1,k,j] 2.
中间不经过k: 说明经过的是d[k-1,i,j]</p>
<h3 id="最小生成树">4.3 最小生成树</h3>
<p>最小生成树中所有的边都是无向边</p>
<p>在当前的连通情况下。选择未连接点中到该连通块最小的点的边。 &gt;
假设不是选取的最小的边。否则可以构造更小的生成树 &gt; 根据环来做</p>
<p>kruskal: 基于并查集，选择两个顶点不在一个连通块的情况</p>
<p>核心证明：如果当前不选，可以在最优解（一棵树）中加上。然后形成一个环，形成一个环一定存在小于该边权的边，因此该边一定可以存在最优解中</p>
<p>最长路：正环 最短路：负环 是否存在某个环？ ### 4.4 spfa求负环
负环和正环的定义其实是对称的</p>
<p>负环是什么？
在求最短路时，如果原图中存在负环，那么dist[t]就会一直得到更新。</p>
<p>如果有负环，往往最短路求的就不准了。</p>
<p>抽屉原理。 求负环的常用方法, 基于spfa: 1.
统计每个点入队的次数，如果某个点入队n次，则说明存在负环。 &gt;
被更新了n次以上，每个边更新点一次 2.
统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于n，则也说明存在环</p>
<p>推荐第二种，因为在某种情况下，1为n^2, 2为n</p>
<p>新图上超级源点</p>
<ol type="1">
<li>spfa存在负权边，会被更新，不是-inf.</li>
<li>为什么等价于将所有点入队</li>
</ol>
<blockquote>
<p>理解负环一定是在最短路上运用的！
但是这里并不是说最短路占用更多的节点。而是利用了最短路，每次更新，实际上是根据一条新边来更新一个新点。
而负环其实就是看一个环的点数是否大于n了。
有负环，在这个算法中边一直都能被更新</p>
</blockquote>
<p><em>{fi} / </em>{ti} 最大 =&gt; 01分数规划 求一个环上的。</p>
<p>(0, 1000]. &gt; mid.</p>
<p>找一个判断的结果来做 <em>{fi} &gt; Mid * </em>{ti} &gt;
点权可以放到出边或者入边上是等价的</p>
<p>_{fi - mid*ti} &gt; 0 图中是否正环</p>
<p>通过最长路来做。</p>
<h3 id="差分约束">4.5 差分约束</h3>
<p>最短路径：最长路的最小值</p>
<h3 id="最近公共祖先">4.6 最近公共祖先</h3>
<ol type="1">
<li>向上标记法：
对点a向上走到根节点的路径进行标记，同时对b点做，当向上走的祖先相同时，即得到O(n)</li>
<li>倍增fa[i,j]: 表示从i开始向上走2^j能到达的节点。 0 &lt;= j &lt;=
logn; depth[i]表示深度，层数，即到根节点的距离+1
<ul>
<li>j = 0, f[i, j]=i的父节点</li>
<li>j &gt; 0, f[i, j] = f(f[i, j-1],j-1) &gt; x,y 基于二进制拼凑的思想.
t&gt;=2^k, t包含k位 &gt; 哨兵：
如果从i开始跳2^j步会跳过根节点，那么fa[i,j]=0, depth[0]=0 &gt; 步骤:
预处理O(nlogn)? 查询O(mlogn) &gt; 1. 先把x,y跳到同一层。
depth[x]-depth[y]. depth(f[x,k]) &gt;= depth(y) logn。 从大到小 &gt; 2.
让两个点一直往上跳，跳到同时是公共祖先的下一层为止。 跳到不等时
logn</li>
</ul></li>
<li>Tarjan: 离线求LCA 查询O(n+m) &gt;
DFS，合并两个集合可以用并查集来做。 遍历，合并，查询一次。 O(1),
合并和查询的时间都是O(1)
<ul>
<li><ol start="2" type="1">
<li>已经搜索过的点</li>
</ol></li>
<li><ol type="1">
<li>正在搜索的点</li>
</ol></li>
<li><ol start="0" type="1">
<li>还未搜索的点 &gt; 根据并查集来做！</li>
</ol></li>
</ul></li>
</ol>
<h3 id="有向图的强连通分量">4.7 有向图的强连通分量</h3>
<p>一般来说，对于一般的图很难做。所以我们常见的想法就是先将一个图缩点为有向芜湖安图DAG,
拓扑图，然后用关键路径来做</p>
<p>求连通分量</p>
<p>DFS: 在搜索过程中这四种边 - 树枝边 (x, y) - 前向边 (x, y) - 后向边
(x, y) - 横叉边 (x, y) &gt;
注意，向左是横叉边，但是向右就不是横叉边了；因为右边的横叉边； &gt;
后向边都是往回走的；前向边不用管</p>
<p>? x它是否在某个强连通分量SCC中 情况1：存在后向边，指向祖先节点
情况2：走到了横叉边，横叉边走到了祖先节点。</p>
<p>时间戳</p>
<p>以前的方法是：一遍DFS，再BFS来着 Tarjan算法求强连通分量SCC
对每个点定义两个时间戳 dfn[u]表示遍历到u的时间戳
low[u]表示从u开始走，所能遍历到的最小时间戳
u是其所在的强联通分量的最高点，等价于dfn[u] == low[u]
此时就把当前的连通分量找出来</p>
<p>时间复杂度 O(n + m)</p>
<p>后续做法： 1. 缩点: DAG for i = 1, i &lt;=n, i ++ for i的所有领点j:
if i,j 不在同一SCC中 加一条新边，id(i) -&gt; id(j);
按照连通分量递减的顺序就是拓扑序列 所有到这个点的顺序已经确定</p>
<p>求拓扑序列： 深度搜索，宽度搜索</p>
<h3 id="无向图连通分量">4.8 无向图连通分量</h3>
<ol type="1">
<li>边双连通分量 e-DCC 极大的不包含桥的连通块
极大：不存在一个包含它的并且比它多的连通分量</li>
</ol>
<p>tarjan算法： - 树枝边 - 前向边 - 后向边 时间戳的思想： dfn[x], low[x]
如何找到桥？ x-y是桥 &lt;-&gt; dfn[x] &lt; low[y]
如何找所有边的双连通分量？ - 将所有桥删掉，剩下的连通分支都是 -
使用栈来找 dfn[x]==low[x]: x所包含的子树就是双连通分量</p>
<p>冗余路径：如果两个路径没有公共边，等价于边的双连通分量
最少加几条边可以构成边的双连通分量
缩点后其实就是一棵树，所有度数为1的点都至少要加一条边。 ceil(cnt/2) =
(cnt+1)/2 证明： 充分性：反证法 必要性：</p>
<ol start="2" type="1">
<li>点双连通分量 v-DCC 极大的不包含割点的连通块</li>
</ol>
<p>反直觉，每个割点至少属于两个连通分量 两个割点之间的边不一定是桥
任何桥的两个端点不一定是割点，如两个点的情况
点连通分量不一定是边连通分量 边连通分量不一定是点连通分量</p>
<p>如何求割点？ x-&gt;y: low[y] &gt;= dfn[x] 1.
如果x不是根节点，那么x是割点 2. 如果x是根节点，那么至少有两个子节点yi,
满足low[yi] &gt;= dfn[x] 电力：统计连通块个数
cnt；依次枚举从哪个块中删，再枚举删除哪个点？s.
依次枚举每个割点然后求全局最大值</p>
<p>如何求双连通分量？ if (dfn[x] &lt;= low[y]) { cnt ++; if (x非根节点
|| cnt &gt; 1) x是割点 将栈中元素弹出，直至弹出y为止
且x也属于该“点双连通分量” } 如果是个孤点的话也是双连通分量。</p>
<p>难点在于答案是怎么算出来的？ ### 4.8 二分图</p>
<ol type="1">
<li>二分图、不存在奇数环，染色法不存在矛盾</li>
<li>匈牙利算法、匹配、最大匹配、匹配点，增广路径</li>
<li>最小点覆盖、最大独立集、最小路径点覆盖、最小路径重复点覆盖
最大匹配数 = 最小点覆盖 = 总点数 - 最大独立集 = 总点数 -
最小路径覆盖</li>
</ol>
<p>点覆盖：每个边都能找到一个点覆盖
最大独立集：选出最多的点，使得选出的点之间没有边
最大团：选出最多的点，使得选出的点两两都有边</p>
<ol start="4" type="1">
<li>最优匹配，KM 最小费用流</li>
<li>多重匹配，每个点可以匹配多个点 最大流</li>
</ol>
<h3 id="欧拉回路和欧拉路径">4.9 欧拉回路和欧拉路径</h3>
<h3 id="拓扑排序">4.10 拓扑排序</h3>
<h2 id="基本数据结构">5. 基本数据结构</h2>
<h3 id="并查集">5.1 并查集</h3>
<p>两个优化：路径优化，按秩合并 1. 记录每个集合大小：绑定到根节点上 2.
每个点到根节点的距离，绑定到每个元素上</p>
<p>带权并查集: 相对距离 扩展域 O(k): 枚举的思想</p>
<h2 id="补充">6 补充</h2>
<p>RSA密钥原理 Q*P=N
N作为公钥，P，Q作为密钥，P知道Q的密钥，分别被双方拥有。实际上是基于大整数分解非常困难的原因。
&gt;
A知道B的密钥，公钥，AB都知道，所以B就可以访问A，A就可以验证是否符合要求。</p>
<p>井田制 &gt; 田字型的土地，土地由农民自己，然后向中心交税</p>
<p>为什么炮兵的炮弹不会被山地阻挡？ &gt; 因为它的运动轨迹是抛物线的</p>
<ul>
<li>DP:
<ul>
<li>数字三角形模型： &gt; 当前步，简单地方格，向右走和向上走
<ul>
<li>扩展：走k次如何计算？</li>
</ul></li>
<li>最长上升子序列模型： &gt; 使用单调队列的方法构造上升子序列？？</li>
<li>背包问题：完全背包和多重背包，形如多少个物品，每个物品有对应的属性，多个，每个属性有自己的约束，求最值和方案数
<ul>
<li>可能扩展
<ul>
<li>预处理，预先排序。把几个属性合在一起看</li>
<li>多重背包问题的重叠</li>
<li>分组背包：有多个依赖：转换为离散值，当太复杂时，过渡到树形DP*</li>
</ul></li>
<li>不熟练点
<ul>
<li>求具体方案</li>
<li>属性</li>
</ul></li>
</ul></li>
<li>状态机模型：
状态直接考虑会依赖到上一层以上的状态，所以将上一层分为离散的状态来考虑</li>
<li>状态压缩DP: 将上一层的状态用二进制来表示</li>
</ul></li>
</ul>
<p>记忆化搜索模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int dp(int l, int r) &#123;</span><br><span class="line">    int&amp; v = f[l][r];</span><br><span class="line">    if (v &gt;= 0) return v;</span><br><span class="line">    // 计算过程</span><br><span class="line"></span><br><span class="line">    return v=get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return f(1, n);</span><br></pre></td></tr></table></figure>
<p>现象-&gt; 逻辑（写法）：应试教育</p>
<p>最大独立集：有很多点，很多边</p>
<p>不包含一个字符串, KMP 包含多个字符串，树形DP</p>
<p>闫式最优化问题分析法</p>
<p>在一个有限集合中秋最值，或者个数。 &gt;
有可能方案是无限集，通过贪心证明，结果在有限集中
将所有情况划分到集合中，从而来查看集合与集合之间的关系</p>
<p>古代的烽火传递：
现在一般都用光纤等，电波等传递信号，而古代的时候是怎么传递信号的呢。用的是可见光，即烟能够向上空飘去，点表示敌人来犯。</p>
<p>白天用烟，晚上用火。</p>
<p>容错机制。 在可见范围内多放几座信号塔</p>
<p>物理化学是第二次工业革命的产物，信息技术才是第三四次工业革命的产物</p>
<p>一个行业要在前几年入，但有风险是肯定的。不能有很好的晋升机会，现在大公司都在裁员</p>
<p>一个经济周期往往会不断的波动，但是整个平均值是在提高的，平均值就是生产力的增长。
在不久的将来很多人就可以不工作
每天的需要是什么？吃饭、电力、暖气、WIFI、睡觉</p>
<p>经济周期好的时候放债具有更好的收益。债务放出来说明整个社会的钱变多了，说明社会的平均工资变多了。
债务达到一个峰值没有跟生产力匹配的时候就会产生泡沫。
经济就会下行，资本就会进入寒冬，没有人放债。
当它低于一个下行值时，又会上升</p>
<p>数组越界，爆栈</p>
<p>错误，检查for循环的终止条件是否正确</p>
<p>注意由于对齐原理，结构体有时间开辟的空间更大</p>
<p>对于BFS,DFS，其实还需要考虑的一个问题就是，这个点访问几次</p>
<p>奇怪的问题 queue<int> q; cout &lt;&lt; 一大堆数</p>
<p>迪杰斯特拉在非负权边上做都可</p>
<p>define 会多两条指令</p>
<h3 id="最短路-vs-dp">最短路 vs DP</h3>
<p>两个是有着不同的交集的</p>
<p>起点：(0,0) 终点: f[0,0], f[0,1], ..., f[0,m]</p>
<p>状态转移方程 f[i,j] = min(f[i,j], f[i-1,j] + w)
其实f[i,j]就可以看作是一个点。然后加的值表示权</p>
<p>然后，好像对于方案数为什么是相加，豁然开朗</p>
<p>f[n,m]到起点的最长路径。</p>
<p>绝大部分DP是拓扑图上的最短路问题</p>
<p>DP和最短路的交集就是拓扑图 DP未交的地方未想到例题</p>
<p>启示： DP依赖关系不具有拓扑序，可以用最短路来做</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/algorithm/" rel="tag"># algorithm</a>
              <a href="/tags/acwing/" rel="tag"># acwing</a>
              <a href="/tags/improve/" rel="tag"># improve</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/09/16/algorithm-basic-class/" rel="prev" title="algorithm basic class">
      <i class="fa fa-chevron-left"></i> algorithm basic class
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/09/16/clean-code-reading-note/" rel="next" title="clean code: reading note">
      clean code: reading note <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-gitalk">gitalk</a></li>
            <li class="tab"><a href="#comment-livere">livere</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane gitalk" id="comment-gitalk">
              <div class="comments" id="gitalk-container"></div>
            </div>
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80NjU1Mi8yMzA2Mg=="></div>
  </div>
  
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%A7%88"><span class="nav-number">1.</span> <span class="nav-text">1. 概览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dp"><span class="nav-number">2.</span> <span class="nav-text">2. DP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 数字三角形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 最长上升子序列问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#basic"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 basic</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2"><span class="nav-number">3.</span> <span class="nav-text">3. 背包问题： 背包九讲</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#further"><span class="nav-number">3.1.</span> <span class="nav-text">3.2 further</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E6%B3%A8"><span class="nav-number">4.</span> <span class="nav-text">备注</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%9A-vs-%E6%81%B0%E5%A5%BD-vs-%E8%87%B3%E5%B0%91"><span class="nav-number">5.</span> <span class="nav-text">最多 vs 恰好 vs 至少</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.</span> <span class="nav-text">状态机模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%A6%82%E8%A7%88"><span class="nav-number">6.1.</span> <span class="nav-text">题目概览</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp"><span class="nav-number">7.</span> <span class="nav-text">状态压缩DP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%8B%E7%9B%98%E5%BC%8F%E5%9F%BA%E4%BA%8E%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="nav-number">7.1.</span> <span class="nav-text">1. 棋盘式（基于连通性）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4dp"><span class="nav-number">8.</span> <span class="nav-text">区间DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E5%BD%A2dp"><span class="nav-number">9.</span> <span class="nav-text">树形DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E4%BD%8Ddp"><span class="nav-number">10.</span> <span class="nav-text">数位DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp"><span class="nav-number">11.</span> <span class="nav-text">斜率优化DP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">11.1.</span> <span class="nav-text">2. 集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94"><span class="nav-number">11.2.</span> <span class="nav-text">对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A0"><span class="nav-number">12.</span> <span class="nav-text">3. 搜素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bfs"><span class="nav-number">12.1.</span> <span class="nav-text">3.1 BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#flodd-fill"><span class="nav-number">12.1.1.</span> <span class="nav-text">3.1.1 Flodd Fill</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%A8%A1%E5%9E%8B"><span class="nav-number">12.1.2.</span> <span class="nav-text">3.1.2 最短路模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%BA%90bfs"><span class="nav-number">12.1.3.</span> <span class="nav-text">3.1.3 多源BFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E6%AD%A5%E6%95%B0%E6%A8%A1%E5%9E%8B"><span class="nav-number">12.1.4.</span> <span class="nav-text">3.1.4 最小步数模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E5%B9%BF%E6%90%9C"><span class="nav-number">12.1.5.</span> <span class="nav-text">3.1.5 双端队列广搜</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AB%E6%95%B0%E7%A0%81"><span class="nav-number">12.1.5.1.</span> <span class="nav-text">八数码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dfs"><span class="nav-number">12.2.</span> <span class="nav-text">3.2 DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dfs%E4%B9%8B%E8%BF%9E%E9%80%9A%E6%80%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F"><span class="nav-number">12.2.1.</span> <span class="nav-text">3.2.1 DFS之连通性模型和搜索顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dfs%E4%B9%8B%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96"><span class="nav-number">12.2.2.</span> <span class="nav-text">3.2.2 DFS之剪枝优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1"><span class="nav-number">12.3.</span> <span class="nav-text">3.3 迭代加深</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98"><span class="nav-number">13.</span> <span class="nav-text">4. 最短路问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-number">13.1.</span> <span class="nav-text">4.1 单源最短路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-number">13.2.</span> <span class="nav-text">4.2 多源最短路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">13.3.</span> <span class="nav-text">4.3 最小生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F"><span class="nav-number">13.4.</span> <span class="nav-text">4.5 差分约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">13.5.</span> <span class="nav-text">4.6 最近公共祖先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-number">13.6.</span> <span class="nav-text">4.7 有向图的强连通分量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-number">13.7.</span> <span class="nav-text">4.8 无向图连通分量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E5%92%8C%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84"><span class="nav-number">13.8.</span> <span class="nav-text">4.9 欧拉回路和欧拉路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">13.9.</span> <span class="nav-text">4.10 拓扑排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">14.</span> <span class="nav-text">5. 基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">14.1.</span> <span class="nav-text">5.1 并查集</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">15.</span> <span class="nav-text">6 补充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF-vs-dp"><span class="nav-number">15.1.</span> <span class="nav-text">最短路 vs DP</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yun-Pan Wang"
      src="/images/default-avatar.png">
  <p class="site-author-name" itemprop="name">Yun-Pan Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">115</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AugF" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AugF" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wangyp@smail.nju.edu.cn" title="E-Mail → mailto:wangyp@smail.nju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/Joswxe" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;Joswxe" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.google.com/" title="https:&#x2F;&#x2F;www.google.com" rel="noopener" target="_blank">Google</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://cn.bing.com/" title="https:&#x2F;&#x2F;cn.bing.com" rel="noopener" target="_blank">Bing</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">Baidu</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">[object Object]</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">466k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:04</span>
</div>!

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '9552a863f697c06e137f',
      clientSecret: '65716dc606be017204585b55c9858ede23eae0b9',
      repo        : 'augf.github.io',
      owner       : 'AugF',
      admin       : ['AugF'],
      id          : '72aead7c5a8ec5631cf18e1bbc1fe60b',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
