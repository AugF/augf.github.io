<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"augf.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="快排 &gt; 难分，易于归并 &gt; eg: 第k个数 归并 &gt; 易分，难合 &gt; eg: 逆序对 二分：整数，浮点数 &gt; 二分，多种场合，分治的取一情况。分割两种不同的性质 高精度,A+B, A-B, A*a, A&#x2F;a &gt; A+B, tmp临变量。 末尾存储，a[0]存个位。 前缀和差分 &gt; 前缀和[;,r], s[r]-s[l-1]. 一维和二维。">
<meta property="og:type" content="article">
<meta property="og:title" content="algorithm basic class">
<meta property="og:url" content="https://augf.github.io/2019/09/16/algorithm-basic-class/index.html">
<meta property="og:site_name" content="Life&#39;s Notes">
<meta property="og:description" content="快排 &gt; 难分，易于归并 &gt; eg: 第k个数 归并 &gt; 易分，难合 &gt; eg: 逆序对 二分：整数，浮点数 &gt; 二分，多种场合，分治的取一情况。分割两种不同的性质 高精度,A+B, A-B, A*a, A&#x2F;a &gt; A+B, tmp临变量。 末尾存储，a[0]存个位。 前缀和差分 &gt; 前缀和[;,r], s[r]-s[l-1]. 一维和二维。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-09-16T00:02:32.000Z">
<meta property="article:modified_time" content="2021-05-27T01:05:35.000Z">
<meta property="article:author" content="Yun-Pan Wang">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="acwing">
<meta property="article:tag" content="basic">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://augf.github.io/2019/09/16/algorithm-basic-class/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>algorithm basic class | Life's Notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Life's Notes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">岁月数载，愿不负韶华</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/16/algorithm-basic-class/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          algorithm basic class
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-16 08:02:32" itemprop="dateCreated datePublished" datetime="2019-09-16T08:02:32+08:00">2019-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/" itemprop="url" rel="index"><span itemprop="name">acwing</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/basic/" itemprop="url" rel="index"><span itemprop="name">basic</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/basic/summary/" itemprop="url" rel="index"><span itemprop="name">summary</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>快排 &gt; 难分，易于归并 &gt; eg: 第k个数</p>
<p>归并 &gt; 易分，难合 &gt; eg: 逆序对</p>
<p>二分：整数，浮点数 &gt;
二分，多种场合，分治的取一情况。分割两种不同的性质</p>
<p>高精度,A+B, A-B, A*a, A/a &gt; A+B, tmp临变量。
末尾存储，a[0]存个位。</p>
<p>前缀和差分 &gt; 前缀和[;,r], s[r]-s[l-1]. 一维和二维。 &gt;一维前缀和
<span class="math inline">\(a_l+a_{l+1}+...+a_r = S_r - S_{l-1}\)</span>
&gt; 一次O(n),后面线性时间查询 &gt; 差分:
多次为某个区间中的数进行操作，单位时间即可解决</p>
<p>双指针 &gt; 模板很好用，找单调性</p>
<p>位运算： 怎么析取每一位1，怎么找到最低位1 &gt; 位操作才是</p>
<p>离散化 &gt;在一个小的区间上反复做操作和查询</p>
<p>区间合并 &gt; 为后面做准备。 怎么处理特殊情况？让情况考虑完全！</p>
<p>单链表和双链表 &gt; 单： e[N],ne[N],idx,head=-1; e[idx++]=x;
注意！删除头元素！
数组中自然下标对应的是按顺序插入的值，不考虑删除的情况; &gt; &gt;
注意节点的值存储在e[i]中 &gt; &gt; 常用在图和hash表的存储中 &gt; 双：
e[N],l[N],r[N],idx,r[0]=1,l[1]=0; e[idx++]=x;
从2开始计数，删除时直接用指针即可</p>
<p>栈和队列 &gt; 栈: st[N],tt st[++tt]=x; tt?No:Empty &gt;
队列：q[N],hh,tt=-1 q[++tt]=x hh&lt;=tt ? No: Empty</p>
<p>单调栈和单调队列（滑动窗口） &gt;
首先给出暴力做法，然后去掉没有用的元素，发现剩余的元素具有单调性。
没有用的元素考虑使用栈或者队列将其抛弃，剩余的元素则进行保留。 &gt;
对单调性的东西，可以考虑用栈来访问最近最值元素，队列来访问全局最近最小元素？，另外由于单调性还可以用二分法进行模拟。
&gt; 实现： &gt; 单调栈： 队中存储的就是元素 &gt; 滑动窗口：
队中存储的是元素的下标 &gt; 时间复杂度优化：
每个元素最多进栈和出栈一次，优化为了O(n); &gt; ?
二元关系的下界知道，怎么知道一个问题的下界是多少？ <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">单调栈</span><br><span class="line">st[N], tt=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">    int x;</span><br><span class="line">    while(tt &amp;&amp; st[tt]&gt;=x) tt--;</span><br><span class="line">    if(tt) puts(&quot;-1&quot;);</span><br><span class="line">    else printf(&quot;%d&quot;,st[tt]);</span><br><span class="line">    st[++tt]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">单调队列</span><br><span class="line">a[N], q[N], hh, tt=-1;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">    if(hh&lt;=tt &amp;&amp; q[tt]&lt;i-k+1) hh++;</span><br><span class="line">    while(hh&lt;=tt &amp;&amp; a[q[tt]]&lt;=a[i]) tt--;</span><br><span class="line">    q[++tt]=i;</span><br><span class="line">    if(i&gt;=k-1)&#123;</span><br><span class="line">        cout&lt;&lt;q[hh]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>KMP &gt;
用于搜索模板串在子串上出现的位置，思想是提前对模板串做信息标志，即利用最大后缀。
&gt; next[i]: 以i为终点的，最长连续后缀的长度。 next[1]=0; // 初始化
&gt; 关键为next数组, 时间复杂度,
匹配的时候while不执行和while执行时均摊可以知道，while最多减m次 ？？？
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for(int i=2, j=0;i&lt;=n;i++)&#123;</span><br><span class="line">    while(j &amp;&amp; p[i]!=p[j+1]) j=next[j]; //j=0,表示一个都还没成功匹配</span><br><span class="line">    if(p[i]==p[j+1]) j++;</span><br><span class="line">    next[i]=j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i=1,j=0;i&lt;=m;i++)&#123;</span><br><span class="line">    while(j &amp;&amp; s[i]!=p[j+1]) j=next[j];</span><br><span class="line">    if(s[i]==p[j+1]) j++;</span><br><span class="line">    if(j==n)&#123;</span><br><span class="line">        printf(&quot;%d&quot;,i-j+1); // 返回从1开始的s的下标</span><br><span class="line">        j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Trie树 &gt; 利用相同的前缀，进行搜索；将每个字母当做一个节点。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">son[N][26],cnt[M],idx; // 这里M应该是最多出现的节点的个数，因为这里M是节点的计数</span><br><span class="line">这里的N是最大出现的层数，即字符串的最大长度。</span><br><span class="line">str[N];</span><br><span class="line"></span><br><span class="line">int add(char str[N])&#123;</span><br><span class="line">    p=0;</span><br><span class="line">    for(int i=0;str[i];i++)&#123;</span><br><span class="line">        int u=str[i]-&#x27;a&#x27;;</span><br><span class="line">        if(!son[p][u]) son[p][u]=idx++;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">时间复杂度 插入O(n),查找O(n); 可用于在大批的字符串中进行查找</span><br></pre></td></tr></table></figure></p>
<p>并查集 &gt; 将两个元素合并，询问两个元素是否在一起; 用树来模拟 &gt;
1. 如何判断根 2. 如何求x的集合编号 3. 如何合并 &gt;
可用于一切集合合并的问题 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int find(int x)&#123;</span><br><span class="line">    if(p[x]!=x) p[x]=find(p[x]);</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;=n;i++) p[i]=i;</span><br><span class="line"></span><br><span class="line">M: p[find(a)]=find(b);</span><br><span class="line">Q: find(a)==find(b);</span><br></pre></td></tr></table></figure></p>
<p>堆 &gt; down(i), up(i); i从1开始， 变小往上走，变大往下走 &gt;
堆排序，建堆O(n), 修复一个元素O(n). O(klogk):找前k个元素？？ &gt;
模拟堆，额外维护一个第几个插入与堆中元素的链表</p>
<p>哈希表 &gt; 注意区别离散化，离散化是借助前缀和来做 &gt; 如何哈希？
如何解决冲突？ 开放寻址法+拉链法 &gt; 无序性，O(1) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">关键find函数，找到元素或者找到该插入元素的位置</span><br><span class="line">拉链法</span><br><span class="line">h[N],e[N],ne[N],idx;</span><br><span class="line">int insert(int x)&#123;</span><br><span class="line">    int k=(x%N+N)%N;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    ne[idx]=h[k];</span><br><span class="line">    h[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    int k=(x%N+N)%N;</span><br><span class="line">    for(int i=h[k];i!=-1;i=ne[i])&#123;</span><br><span class="line">        if(e[i]==x) return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">memset(h,-1,sizeof(h));</span><br><span class="line"></span><br><span class="line">开放寻址法：找坑法</span><br><span class="line">如何填满了会出问题，所以经验上会用2-3倍空间</span><br><span class="line">const int N=200003,null=0x3f3f3f3f;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    int k=(x%N+N)%N;</span><br><span class="line">    while(h[k]==null &amp;&amp; h[k] != x)&#123;</span><br><span class="line">        k++;</span><br><span class="line">        if(k==N) k=0;</span><br><span class="line">    &#125;</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br><span class="line">memeset(h,0x3f,sizeof(h)); // 关键null要大于x数值的范围</span><br></pre></td></tr></table></figure></p>
<p>字符串哈希 &gt; 前缀哈希，正常按高到低来。由p进制来转换为十进制数。
&gt; 经验值： p=131,13331, Q: 2^64; &gt;
[l,r]的哈希值h[r]-h[l-1]*p[r-l+1] &gt;
所以只需要比较两个哈希值是否相等就能知道两个字符串是否相等。如果h和p提前计算好就是O(1),作用快速比较两个字符串是否相等
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ULL h[N],p[N];</span><br><span class="line">char str[N];</span><br><span class="line"></span><br><span class="line">ULL get(int l, int r)&#123;</span><br><span class="line">    return h[r]-h[l-1]*p[r-l+1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p[0]=1;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    p[i]=p[i-1]*p;</span><br><span class="line">    h[i]=h[i-1]*p+str[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>STL初步 vector 变长数组，倍增思想 size() dequeue 特别慢 string
可用作模拟栈, pair queue(), priorityqueue stack
set有序序列，基于平衡树实现 O(logN) map a["adad"]=1, a.count()? 好用！
unorder_set,.._map,哈希，O(1), 单独头文件 bitset(): bitset&lt;10000&gt;
s; ~,&amp;,|,^</p>
<p>DFS: 回溯，暴力搜索，恢复现场 1. 简单的框架 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 回溯法: u代表了每一层</span><br><span class="line">int dfs(int u)&#123;</span><br><span class="line">    if(u==n)&#123;</span><br><span class="line">        //print</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!st[i])&#123;</span><br><span class="line">            st[i]=true;</span><br><span class="line">            dfs(u+1);</span><br><span class="line">            st[i]=false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 2.
树和图的框架 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">h[N],e[N],ne[N],idx;</span><br><span class="line">st[N];</span><br><span class="line"></span><br><span class="line">void add(int x,int y)&#123;</span><br><span class="line">    e[idx]=y,ne[idx]=h[x],h[x]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注意这里是图的遍历框架，所以跟前面的不一样，考虑的不是到达某一显示的层；而是将图中所有节点搜索完得到结果</span><br><span class="line">void dfs(int u)&#123;</span><br><span class="line">    st[u]=true;</span><br><span class="line"></span><br><span class="line">    for(int i=h[u];i!=-1;i=ne[i])&#123;</span><br><span class="line">        int j=e[i];</span><br><span class="line">        if(!st[j])&#123;</span><br><span class="line">            // 预处理</span><br><span class="line">            int t = dfs(j);</span><br><span class="line">            // 后处理</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BFS: 最短路的性质 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">h[N],e[N],ne[N],idx;</span><br><span class="line">int d[N],q[N];</span><br><span class="line"></span><br><span class="line">void bfs()&#123;</span><br><span class="line">    // 声明数组</span><br><span class="line"></span><br><span class="line">    // 初始化加入第一个元素</span><br><span class="line"></span><br><span class="line">    while(queue不空)：</span><br><span class="line">        t&lt;-队头</span><br><span class="line">        枚举所有出边：</span><br><span class="line">            if(constraint(x))&#123;</span><br><span class="line">                更新d[j];</span><br><span class="line">                入队；</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    // 队列中的元素就是拓扑序列</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最短路问题 - 单源最短路 - 正权边 &gt; Dijkstra算法 O(n^3) &gt;
d[i]=0; for(i:1-n) min, S&lt;-t, update min &gt; 堆优化的Dijkstra算法
O(mlogN) - 负权边 &gt; Bellman_ford() &gt; spfa() - 多源最短路 floyd,
动态规划</p>
<p>最小生成树 Prim算法 朴素版 算法思想 d[1]=0, d[2..n]=INF
while(q.size()) (t=q.min() for v: t-v: if(!st[v])
d[v]=min(d[v],d[t][v]);) O(n^2): n轮，每轮1-m Kruskal O(mlogm)
从小到大选边， mlogm进行排序</p>
<p>二分图 染色法 O(n+m):对所有边和点进行遍历 匈牙利算法O(nm)
找最大匹配</p>
<p>数论 质数 从2开始具有某种性质的整数； 判定方法：试除法：d|n, n/d |n,
d&lt;=n/d 分解n的质因数：不断砍质数 &lt;=n/i
筛质数：筛选出2~n之间的所有质数 - 从小到大筛数的倍数 - 筛素数的倍数：
埃式筛法 - 利用乘积来筛：线性筛法 &lt;=n</p>
<p>约数
试除法求约数：成对出现。然后在排序，可以计算出排序的时间复杂度远小于一般情况
约数个数：自然数基本定理 a=p1^a1 p2^a2 ... pk^ak
约数之和：(p1<sup>0+...+p1</sup>a1)(p2<sup>0+...+p2</sup>a2)...
(利用了组合数学)</p>
<p>最大公约数 辗转相除法</p>
<p>欧拉函数 p(n): 1~n之间与n互质的数 如何求？容斥原理，去掉不互质的
N-N/p1-N/p1+..进行统计 N(1-1/p1-1/p2-... + 1/p1p2) 然后公式改写可以得到
N(1-1/p1)(1-1/p2)...(1-1/pk) - 公式法：计算出某一个数的欧拉函数 -
筛法：计算多个数的欧拉函数 phi[primes[j]*i]=primes[j]*phi[i] //
primes[j]是i的第一个质因数 分为质数 最小质因数是该数的因子
最小质因数不是该数的因子 使用线性筛法的模板来解题</p>
<p>费马定理 a^(phi[p]) mod p = 1</p>
<p>a^k mod p的快速幂:
将等比数列，等差数列之类的东西很容易用循环结构来写，这样从某种程度就会让问题的难度降低很多</p>
<p>快速幂求逆元： aa^-1 mod p = 1 根据费马定理 a^(p-1) mod p=1,
所以逆元为a^(p-2) logP</p>
<p>扩展欧几里得算法 ax+by=gcd(a,b)
求x和y：本身其实是有多个解的，注意这里的循环结构是非常妙的！</p>
<p>线性同余方程 ax =b mod m, 转化为ax-my mod m=b,
然后再扩充解，如果(a,m)|b不成立的话，无解</p>
<p>中国剩余定理：
第一种方法：使用公式法来做；第二种做法：使用线性同余方程的合并来做</p>
<p>组合计数 - 10万组 2000 递推 C(n,m)=C(n-1,m)+C(n-1,m-1) O(n^2) - 1万组
10^5 运用逆元的思想 fib[a] infib[b] infib[a-b] mod n, N<em>logN - 20组
10^18 使用卢斯卡定理 C(a,b)=C(a mod p, b mod p)</em>C(a/p, b/p) mod p
后面mod p 必须有否则不成立, p这里一般不会太大 -
无模运算：直接求a!中p的个数, 用大整数乘法来做</p>
<p>有序的01序列 卡特兰数，转化为图形，数轴翻转进行理解 (2n)! / n!(n+1)!
= 1/(n+1) C(2n,n) 应用很多，如栈的顺序</p>
<p>高斯消元 手动模拟人工计算的工程 1. 对列进行循环 2. 寻找首元素最大的行
3. 如果为不存在或为0， continue 4. 交换最大行和首元素行 5.
将当前行首元素置为1，从后往前循环 6. 将后面的行的首元素变为0 7.
对有多组解、无解、唯一解情况进行判断</p>
<p>异或：不进位的加法 1. 枚举列 2. 找非零行 3. 交换 4. 消零</p>
<p>容斥原理 韦恩图
有什么用？能减少枚举的数量的个数？如果找到某种性质的话
比如：1~n之间能被p1,p2,...等多个数整除的数的个数？使用容斥原理 k(2^k-1)
复杂度</p>
<p>简单博弈 公平组合游戏 Nim游戏： 必败状态=0和必胜状态!=0, 自然数的异或
Nex游戏，sg(x)终止状态为0状态，反推最小非负整数的运算，每一个都是到不了状态
&gt; 每个可以根据形成一个单独图，sg(b1,b2)=sg(b1)^sg(b2) 实例：
Nim游戏、台阶-Nim游戏、集合-Nim游戏、拆分Nim游戏</p>
<p>背包问题 - 01背包 i v max(w) 每个物品选或不选 f[i][v]=w:
所有只使用前i个物品且总体积小于v的取法的权重的Max
根据最后一个元素i放或不放进行拆分 f[i][v]=max(f[i][v],
f[i-1][v-v[i]]+w[i]) N<em>V </em>1 N - 完全背包 每个物品可以选任意次
f[i][v]=w 所有只使用前i个物品且总体积小于v的取法的权重的Max
根据最后一个元素i取多少次进行限制 由容量大小确定取的次数
根据递推关系可以简单写成 f[i][v]=max(f[i][v], f[i][v-w]+w) N<em>V</em>1
N - 多重背包问题 每个物品有si个 &gt;
思路将0~si,用1,2,4,..,2^k,c枚举转化为01背包问题 NlogS<em>V</em>1 NlogS -
分组背包问题 每组物品中只能选一个或不选 f[i][v]= N
所有只从前i组中选择且总体积不小于v的取法的权重的最大
根据每组选哪个元素来分类 f[i][v] = max(f[i][v], f[i][v-v[i][k]]+w[i][k])
// k=0~k-1 N<em>V</em>K N*K &gt;
这里用组的概念代替了单个背包，所以也多出了多种选择</p>
<p>线性DP &gt; 考虑的方式都是线性的</p>
<ul>
<li><p>数字三角形 从上到下的权重最长的路径 f[i][j]
所有从起点走到(i,j)的路径的权重和的最大值
根据前一方向的来源，左上方还是右下方 f[i][j]=max(f[i-1][j], f[i-1][j-1])
+ a[i][j] n^2*1 n^2 &gt; 因为出口有多条路，所以数据结构不可缩减</p></li>
<li><p>最长上升子序列 &gt; 注意发现的话，可以看出这里的做法是很妙的 f[i]
所有以第i个数为结尾的上升子序列的结合长度的最大值
考虑上升子序列中上一元素的位置 f[i]=max(f[j]+1) j:0~i-1 n<em>n n
非DP,优化 n</em>logn
发现长度的最后一个位置具有递增关系，可以用二分法搜索进行优化 &gt;
代码！！！</p></li>
</ul>
<p>最长公共子序列 f[i][j]
所有由第一个序列的前i个字母和第二个序列的前j个字母构成的最长公共子序列的Max
根据第i个和第j个字母是最长公共子序列的结尾元素，优化后可得
f[i][j]=max(f[i-1][j],f[i][j-1], f[i-1][j-1]+1) N<em>M</em>1 N*M</p>
<p>最短编辑距离 f[i,j]
将a[1,i]编辑成b[1,j]的所有操作方式的集合，操作方式有插入、删除、替换
根据最后一次属于哪种操作方式进行分类 f[i,j]=min(f[i-1,j], f[i,j-1],
f[i-1,j-1]+(a[i]!=b[j]))</p>
<p>区间DP &gt; 二维的i,j一般为区间的起始和终点坐标 石子合并 前缀和的运用
大整数相乘 f[i][j]
所有将第i堆石子和第j堆石子合并成一堆石子的合并方式的代价的最小值
按最后一次合并的位置进行划分 f[i,j] = max_k (f[i,k]+f[k,j]+pj)
k=i,..,j-1 n*n n^2<br />
&gt; 这里循环用了len和i，值得借鉴</p>
<p>计数类DP 属性为数量，直接相加得到最终结果 整数划分 f[i,j]
从0~i中选择整数，组成恰好是j的所有方式的集合的总数量
按i加入的次数进行分类 完全背包问题 f[i,j] = f[i-1,j] + f[i,j-v[i]] ans =
f[i,i]</p>
<p>f[i,j] 使用j个元素构成的数恰好是j的所有方式的集合的数量
最小的元素是否是1 f[i,j] = f[i-1,j-1] + f[i-j, j] ans = sum_i f[n,i]</p>
<p>数位统计DP 比如计数问题，对数位上出现的数进行统计</p>
<p>状态压缩DP f[i][j], 某一个位使用二进制位来表示整体的状态方程
蒙德里安的梦想 &gt; 非常妙的一种做法，想到每个小格进行递推得到方程式
矩形可以有多少中1*2的小矩形的填充方法，首先考虑横着的矩形，竖着放的矩形就唯一确定了。
对于横着放的矩形，总共的方案数，研究每列上每个状态的情况！！ 多加理解
最短Hamilton路径 为什么要用这个？ f[i][j]
所以从0走到j，走过的所有点的状态是i的所有路径的长度 &gt;
用状态压缩是因为这里的路径不是按自然序来的，可能有多种组合方式</p>
<p>树形DP 没有上司的舞会 容易，直接用父子关系即可建立DP关系 &gt;
注意最大值这里可能会犯错</p>
<p>记忆化搜索 滑雪 &gt;
非常妙的一个东西！对于方格型DP,想到了用方向来分类做，非常好</p>
<p>贪心 证明 A=B: A&lt;=B &amp;&amp; A&gt;=B 区间问题 - 右端点排序 1.
区间选点问题，数轴选最少的点覆盖所有的区间 &gt;
排序，从前到后枚举每个区间，ed=-2e9,如果当前区间被覆盖，即区间的左端点小于ed,下一个；否则，更新ed
证明：最小不用; cnt&lt;=Ans, cnt覆盖了所有不相交的点，是基本情况</p>
<ol start="2" type="1">
<li>最大不相交区间数量 &gt; 同上 证明：最大不用；cnt&gt;=Ans,
Ans选择的是两两没有交集的区间，那么是点覆盖区间的基本情况，所以必然点的数量大于区间的数量</li>
</ol>
<ul>
<li>左端点排序</li>
</ul>
<ol type="1">
<li><p>区间选组，选择每组内部不相交组的，所分的最小组数 &gt; 排序，
一定是左端点最大的（意味着不可替换性）L[i] &lt;=
所有组的Max_r，则要开辟一个新的组；否则，选择其中r最小的组进行加入，并更新该组的r
正确性：最小不用；Ans&gt;=cnt L[i]
成为新组前一定是形成了cnt+1个相交的区间，这些相交的区间必然花费等量的组，于是得证</p></li>
<li><p>区间覆盖，给定区间，如何用最少的相交区间将其覆盖，也就是怎么安排可以使得任务量最少
&gt;
排序，在所有能覆盖某一点start,选择最大右端点的，作为新的start，依次类推得到最优解
正确性：Ans&lt;=cnt显然， Ans&gt;cnt,
如果与该算法不同，即选择的不是最右的，那么任何最优的算法均能转换为该算法得到的结果，因此大于。</p></li>
</ol>
<p>Huffman树，合并n组东西，如何合并才能使总代价最小。
Huffman树的结构，用层数来解决。</p>
<p>贪心算法</p>
<ul>
<li>排队打水问题 &gt;
贪心题一般是猜一个做法，然后思考为什么是对的。调整法和反证法</li>
</ul>
<p>调整法，对于其实要满足某种顺序，比如正序或者降序的序列，可以假定有两个不满足该序列，然后从而推出矛盾（因为有目标值的存在）</p>
<p>如果不是按照从小到大的顺序排序，必然存在两个逆序的数。此时得出的结果必然小于交换这两个数得出的结果</p>
<ul>
<li><p>货仓选址 &gt; 用数学和用函数来进行建模 &gt; f(x) = |x_1-x| + |x_2
- x| + .. &gt; 猜是中位数 考虑进行分组
二维，基于随机的思路；如果总和变小就有情况获取</p></li>
<li><p>推公式 &gt;
贪心某种常用的做法其实是推公式，然后使用不等式从而得到最优解 &gt;
均值不等式，调和不等死，柯西不等式，绝对值不等式，几何不等式 &gt;
贪心大多问题都是数学上研究过的问题</p></li>
</ul>
<p>贪心得到的答案 &gt;= 最优解 贪心得到的答案 &lt;= 最优解 &gt;
同时比较大小，请注意要学会进行比较。不考虑不变项，然后加上和减去一个无关的变量
&gt; 此贪心的策略只会使最优解结果变小</p>
<ul>
<li>从数据范围反推算法复杂度以及算法内容（一般情况下，题目的时间为1s或者2s.
所以，C++代码中的操作次数控制在1e7最佳）
<ol type="1">
<li>n&lt;=30, 指数级别，dfs+剪枝，状态压缩dp</li>
<li>n&lt;=100, O(n^3) floyd, dp</li>
<li>n&lt;=1000, O(n^2) O(n^2 logn) dp,二分</li>
<li>n&lt;=1e4, O(n sqrt(n)) 块状链表特别难写，用不到</li>
<li>n&lt;=1e5, 最常见的是nlogn算法。线段树和树状数组特别复杂，没讲。
求凸包、求半平面交</li>
<li>n&lt;=1e6, O(n): hash, 双指针扫描, kmp, ac自动机;
常数比较小的O(nlogn): sort(即前面的系数特别小), 树状数组，heap,
ac自动机、线性筛素数 &gt; 树状数组和线段树都是用来解决线段的</li>
<li>n&lt;=1e7, O(n)</li>
<li>n&lt;=1e9, O(sqrt(n)) 判断质数，快速幂</li>
<li>n&lt;=1e18, O(logn) 最大公约数</li>
</ol></li>
<li>如何分析代码时间复杂度?
<ol type="1">
<li>纯循环，dp分析</li>
<li>递归，主定理，套公式求即可, todo</li>
<li>logn的分析，二分</li>
<li>双指针！！ 内层循环只加不减,两层</li>
<li>数据结构，单链表，删除和插入O(1); 栈，O(1);
单调栈，单调队列O(1）</li>
<li>kmp内层循环最多执行n次 22:44</li>
<li>并查集（!!!记住）O(1)，find最坏logn的效率，加状态压缩；再加按秩合并，loglogn</li>
<li>堆，插入和删除需要up和down, 走一遍，O(logn); 原始建堆 o(n)???</li>
<li>hash表，碰撞的概率特别低，平均来说，增删改查都是O(1) &gt;
和快排类似，最坏情况下非常坏，但概率低</li>
<li>搜索和图论：从最基本的出发
<ul>
<li>排列： 最后一层输出答案O(n), 查看树的分支来计算n!n</li>
<li>图的遍历：遍历所有的点，然后对每个点选择遍历所有的边。O(n+m)</li>
<li>迪杰斯特拉:n^2 mlogm (m&lt;=n^2&gt;)</li>
<li>bellsman-ford: nm</li>
<li>spfa, 匈牙利算法，最大流算法；? 实际很快，分析很慢</li>
<li>floyd, prim n^2 kruskal</li>
</ul></li>
<li>数学
<ul>
<li>欧式筛法， 调和级数 n/1+n/2+n/3 nlogn的级别，自然数的和;
如果是质数， n/1+n/2+n/3+n/5+n/7+... nloglogn的级别</li>
<li>最大公约数，辗转相除法，logn</li>
<li>快速幂 logk的级别</li>
</ul></li>
<li>动态规划问题的计算量=状态数量*状态转移的计算量
<ul>
<li>树形DP: 每个点只会遍历一次，遍历其所有的边 O(m)</li>
<li>滑雪： n^2 * 1</li>
</ul></li>
<li>贪心： 排序+循环</li>
</ol></li>
</ul>
<p>1 Byte = 8 bit 1 KB = 1024 Byte 1 MB = 1024<em>1024 Byte 1 GB =
1024</em>1024 Byte</p>
<p>int 4 Byte char 1 Byte double, long long 8 Byte *point
4Byte(32位机器) 8Byte(64位机器) bool 1 Byte</p>
<p>64MB = 2^26 Byte 2^26 / 4 - 2^24, 1600 0000 1e7</p>
<p>直接用代码算即可 &gt; sizeof v + sizeof w + sizeof w 单位是字节 &gt;
但注意有时算的时候开了很大的空间，但是没用是没事的，因为操作系统不会把数据一下子全部给你,
会一点一点给。 所以memset(), 只需要设计到要用的量即可 &gt;
注意递归栈也需要空间， logn</p>
<blockquote>
<p>对于网速来说， 8M/s 指的是8M位， 实际上每秒最多只能下载1MB的数据；
对于流量来说是兆字节 # 总结 数据结构的使用 最值，堆
区间和，区间数组，树状数组，线段树 有序链表，平衡树，set</p>
</blockquote>
<p>技巧：一维转为二维</p>
<p>开始审题很重要，不要什么都没有就往前面跑，首先心理要有一个很好的思路
还有模板哪些步骤一开始只是套路，越到后面越没有必要去实实在在地在意它，这样是完全地浪费功夫的感觉</p>
<ul>
<li>高精度压位 int 2<em>10^10 加法一般压9位 乘法一般压4位
10000</em>10000=1e &gt;
实际上的想法就是在进行高精度计算的时候，一位一位用char来做太费时间和内存了；可以考虑用int来做，
加法9位9位地压，乘法4位4位地压</li>
</ul>
<p>从高位开始读数： 整个数一直左移 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char str[7]=&#x27;121213&#x27;</span><br><span class="line">for(int i=0, t=0;i &lt; n;i++)&#123;</span><br><span class="line">    s= s*10 + str[i]-&#x27;0&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从低位开始读数 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char str[7]=&#x27;121212&#x27;</span><br><span class="line">for(int i=0, s=0,t=1;i&lt;n;i++)&#123; // t表示每一位的进制，每位的数乘以每位的进制</span><br><span class="line">    s += (a[i]-&#x27;0&#x27;)*t;</span><br><span class="line">    t*=10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DP的属性可以有布尔值之间的传递，长度，最值</p>
<p>DFS 递归 BFS 队列 循环 # 错误 - Segmelut Flait
数组，全局变量局部不可访问 数组长度未开够 使用删代码法</p>
<p>将函数return false; 如果问题未改变，则说明不是该函数的问题 -
TLE时间受限 算法出错 局部变量初试为初始化 循环变量名抄错</p>
<p>c++ inline
编译器在执行不会将其转化为函数调用，少了函数栈的空间，一般适用于简单的函数
register int 将变量保存在寄存器中</p>
<p>遍历想想也就两大类啊，深度优先和宽度优先 宽度优先就是层次遍历</p>
<p>宽度优先具有最小的性质，一定能够得出到根节点的最短性。但是宽度优先需要耗费很大的空间，至少存储两层的节点，所以极其耗费空间</p>
<p>深度优先虽然没有最小的性质，但是空间复杂度低，只需要空间复杂度为树的高度的空间</p>
<p>书上的公式是书面语，不是大白话，讲究优美性，实际理解时往往需要抽象我们所理解的大白话。</p>
<p>讲题的境界： 怎么想出来的？正确性</p>
<p>动作记忆！！！</p>
<p>C++中0，NULL，nullptr是一个东西</p>
<p>声音越小越有气势，更重要的是听别人的东西，把别人的东西听懂</p>
<h2 id="待做">待做</h2>
<p>https://blog.csdn.net/weixin_39778570/article/details/86484020
基本算法篇 - 模拟 - 枚举 - 排序 - 分治 - 二分 - 倍增 - 贪心</p>
<p>链表 指针 二叉树 二叉搜索树</p>
<blockquote>
<p>二叉搜索树，父节点， 左孩子节点的函数值严格小于父节点，
右孩子节点的函数值严格大于父节点</p>
</blockquote>
<p>后序遍历： 左、右、中 前序遍历： 中，左，右 中序遍历： 左，中，右</p>
<p>进一步总结 ## 总结</p>
<p>DFS两种框架</p>
<p>第一种 起始点未定, 用层数来表明，子节点都很清晰 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int n;</span><br><span class="line">int path[]</span><br><span class="line">dfs(int i)&#123;</span><br><span class="line">    if(i==n)&#123;</span><br><span class="line">        collect path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        if(check(i))&#123;</span><br><span class="line">            p[i] = 1;  //  赋值</span><br><span class="line"></span><br><span class="line">            dfs(s);</span><br><span class="line"></span><br><span class="line">            p[i] = 0;  // 恢复</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(0)</span><br></pre></td></tr></table></figure></p>
<p>第二种 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int st[N];</span><br><span class="line">int path[N];  //?</span><br><span class="line"></span><br><span class="line">dfs(int v)&#123;</span><br><span class="line">    st[v] = true; // 保证遍历不重复，不需要恢复</span><br><span class="line">    path[i] = f;</span><br><span class="line"></span><br><span class="line">    if(end)  collect</span><br><span class="line">    for(w: vw)</span><br><span class="line">        if(!st)  dfs(w);</span><br><span class="line"></span><br><span class="line">    path[i] = -1; // 其他变量需要恢复</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>BFS的写法 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int fun( )&#123;</span><br><span class="line"></span><br><span class="line">    q.push(v);</span><br><span class="line">    while(q.size()) &#123;</span><br><span class="line">        auto t=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;4;i++)</span><br><span class="line">            if(check(i)) q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> // ? 层次怎么体现？？</span><br></pre></td></tr></table></figure></p>
<p>DP的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f[0][0] = ?</span><br><span class="line">for(i:1~n)</span><br><span class="line">    for(j:1~m)</span><br><span class="line">        f[i][j] = f[i-1][j-1]</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;f[n][m]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int f(int i,int j)&#123;</span><br><span class="line">    if(f[i][j]!=-1) return f[i][j];</span><br><span class="line">    if(base) &#123;</span><br><span class="line">        初值</span><br><span class="line">    &#125;</span><br><span class="line">    res=?</span><br><span class="line"></span><br><span class="line">    for(i:1~n)</span><br><span class="line">        for(j:1~m)</span><br><span class="line">            res=f(i-1,j-1);</span><br><span class="line">    return f[i][j]=res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dfs(0,0)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dp[0][0]</span><br><span class="line"></span><br><span class="line">bool dp(int i,int j)&#123;</span><br><span class="line">    if(f[x][y]!=-1) return f[x][y];</span><br><span class="line">    if(base) &#123;</span><br><span class="line">        return ; // 这里一般是f[i][j]具有某种具体含义的，比如两个字符串匹配，A的前i个字母和B的前j个字母这类极大值情况具有意义的</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[x][y] = dp[x+1][y+2] // 看这里的状态是否好推演</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DP集合划分的方式总结</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/algorithm/" rel="tag"># algorithm</a>
              <a href="/tags/acwing/" rel="tag"># acwing</a>
              <a href="/tags/basic/" rel="tag"># basic</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/09/15/python-pylint/" rel="prev" title="python pylint">
      <i class="fa fa-chevron-left"></i> python pylint
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/09/16/algorithm-acwing-improve/" rel="next" title="algorithm acwing improve class">
      algorithm acwing improve class <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-gitalk">gitalk</a></li>
            <li class="tab"><a href="#comment-livere">livere</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane gitalk" id="comment-gitalk">
              <div class="comments" id="gitalk-container"></div>
            </div>
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80NjU1Mi8yMzA2Mg=="></div>
  </div>
  
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%85%E5%81%9A"><span class="nav-number">1.</span> <span class="nav-text">待做</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yun-Pan Wang"
      src="/images/default-avatar.png">
  <p class="site-author-name" itemprop="name">Yun-Pan Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">115</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AugF" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AugF" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wangyp@smail.nju.edu.cn" title="E-Mail → mailto:wangyp@smail.nju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/Joswxe" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;Joswxe" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.google.com/" title="https:&#x2F;&#x2F;www.google.com" rel="noopener" target="_blank">Google</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://cn.bing.com/" title="https:&#x2F;&#x2F;cn.bing.com" rel="noopener" target="_blank">Bing</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">Baidu</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">[object Object]</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">466k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:04</span>
</div>!

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '9552a863f697c06e137f',
      clientSecret: '65716dc606be017204585b55c9858ede23eae0b9',
      repo        : 'augf.github.io',
      owner       : 'AugF',
      admin       : ['AugF'],
      id          : '50151924f5049e9cb29e4e8d5b64dadc',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
