<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"augf.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="数据结构 1. 链表与邻接表 strut Node{ int val; Node *next; }; &#x2F;&#x2F;不讲！ new Node(); &#x2F;&#x2F; 动态在堆中申请非常慢！ &gt; 可以在初始化时弄多个。  数组模拟单链表   单链表： 邻接表（存储图和树） e[N], ne[N]下标,head, idx &gt; 有个问题，删除后空闲节点不好回收；一般来说不需要管删除的点，浪费即浪">
<meta property="og:type" content="article">
<meta property="og:title" content="algorithm acwing data-struture">
<meta property="og:url" content="https://augf.github.io/2019/09/19/algorithm-acwing-data-struture/index.html">
<meta property="og:site_name" content="Life&#39;s Notes">
<meta property="og:description" content="数据结构 1. 链表与邻接表 strut Node{ int val; Node *next; }; &#x2F;&#x2F;不讲！ new Node(); &#x2F;&#x2F; 动态在堆中申请非常慢！ &gt; 可以在初始化时弄多个。  数组模拟单链表   单链表： 邻接表（存储图和树） e[N], ne[N]下标,head, idx &gt; 有个问题，删除后空闲节点不好回收；一般来说不需要管删除的点，浪费即浪">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-09-19T04:09:15.000Z">
<meta property="article:modified_time" content="2021-05-27T01:05:35.000Z">
<meta property="article:author" content="Yun-Pan Wang">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="acwing">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://augf.github.io/2019/09/19/algorithm-acwing-data-struture/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>algorithm acwing data-struture | Life's Notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Life's Notes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">岁月数载，愿不负韶华</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/algorithm-acwing-data-struture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          algorithm acwing data-struture
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 12:09:15" itemprop="dateCreated datePublished" datetime="2019-09-19T12:09:15+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/" itemprop="url" rel="index"><span itemprop="name">acwing</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/basic/" itemprop="url" rel="index"><span itemprop="name">basic</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/basic/data-struture/" itemprop="url" rel="index"><span itemprop="name">data-struture</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>数据结构</p>
<h1 id="链表与邻接表">1. 链表与邻接表</h1>
<p>strut Node{ int val; Node *next; }; //不讲！</p>
<p>new Node(); // 动态在堆中申请非常慢！ &gt; 可以在初始化时弄多个。</p>
<blockquote>
<p>数组模拟单链表</p>
</blockquote>
<ul>
<li><p>单链表： 邻接表（存储图和树） e[N], ne[N]下标,head, idx &gt;
有个问题，删除后空闲节点不好回收；一般来说不需要管删除的点，浪费即浪费，只是想快，不用考虑内存泄露的方法。
&gt; 写工程时，才需要考虑多久 &gt; 单链表只能向后看，向前只能从头遍历。
O(1)时间插入，O(n)时间; 尾插法O(1), 记录一下即可
注意从0开始存储内容，所以remove和add都是k-1，还要特别注意remove
head;</p></li>
<li><p>双链表： 优化某些问题 e[N],l[N],r[N],0表示头，1表示尾 init:
r[0]=1,l[1]=0, idx=2; 注意不需要连起来
务必注意，从2开始存储元素，所以remove和add都需要映射为k-1+2=k+1</p></li>
</ul>
<p>struct Node{ int e,l,r; }nodes[N]; remove
<code>nodes[nodes[k].l].r=nodes[k].r</code> &gt; 不推荐 # 2. 栈与队列
栈： tt,0 队列：hh,tt &gt; 边界看个人习惯，0或-1</p>
<h1 id="单调栈">3. 单调栈</h1>
<blockquote>
<p>给定一个序列，求一个数左离它最近小于它的数 暴力做法费时
善于发现数据的性质
时间复杂度：每个元素进站一次和最多出站一次，所以算法复杂度为O(n);</p>
</blockquote>
<h1 id="单调队列">4. 单调队列</h1>
<blockquote>
<p>求滑动窗口中的最大值和最小值， 凡是能抽象出来。
一个严格单调队列的最小值就是其头和尾。
队列的大小不会超过滑动窗口的大小！！！</p>
</blockquote>
<blockquote>
<p>单调栈和单调队列的做法都是通过暴力分析，然后用栈和队列来模拟，并且去掉没有用的元素。然后再剩余的元素有没有单调性，有的话就可以考虑栈和队列。
栈是最近最小，队列是全局最小。然后因为单调还可以用二分法来进行查找。</p>
</blockquote>
<p>多重背包也可以用滑动窗口来优化，因为滑动窗口可以做</p>
<p>对队列的研究，什么时候入队，什么时候出队？</p>
<p>！！！这里队列里居然存的是下标，天啦一下子就避免了情况的讨论。 &gt;
存下标会很容易来判断什么时候进行元素弹出</p>
<blockquote>
<p>在实际做的时候，会开O_2和O_3优化，此时速度就与stl相差没多少了
但是在做算法题时，拿数组模拟的队列和栈比stl快。
比赛方是不会开优化的！</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e6+10;</span><br><span class="line"></span><br><span class="line">int q[N];</span><br><span class="line">int a[N];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i=0; i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    int hh=0,tt=-1;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        // 判断对头是否划出了窗口</span><br><span class="line">        if(hh&lt;=tt &amp;&amp; i-k+1 &gt; q[hh]) hh++;</span><br><span class="line">        while(hh&lt;=tt &amp;&amp; a[q[tt]]&gt;=a[i]) tt--; //</span><br><span class="line">        printf(&quot;hh: %d, tt: %d\n&quot;,hh,tt);</span><br><span class="line">        </span><br><span class="line">        q[++tt]=i; // 注意这里模拟的不是实际的物理位置. !!因为hh&gt;tt,当前元素没找出来，注意</span><br><span class="line">        if(i&gt;=k-1) printf(&quot;---%d \n&quot;,a[q[hh]]);</span><br><span class="line">        </span><br><span class="line">        for(int j=hh;j&lt;=tt;j++) printf(&quot;%d &quot;,a[q[j]]);</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="kmp">5. KMP</h1>
<blockquote>
<p>S字符串,P模板串 从1开始</p>
</blockquote>
<p>暴力 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i:1..n</span><br><span class="line">j:2..m</span><br></pre></td></tr></table></figure></p>
<p>优化：一直向取的距离足够大 &gt; 最少移动距离，最大后缀</p>
<p>next[i]=j: 以i为终点的，所能匹配的最长距离.
关键！一定要理解透，这里比如next[1]=0,表示第一个节点没有匹配的内容。
&gt; 务必注意是当前！ p[1,j]=p[i-j+1,i]</p>
<p>i,j为S和P的指针。 所以在i失配的话。 &gt;
模板串移动的是最长的，所以从模板串的角度来看是最优的！</p>
<blockquote>
<p>算法时间复杂度是O(n)的，再快不可能有更快的了！</p>
</blockquote>
<blockquote>
<p>j最多加m次，j大于0， while循环最多减m次。所以时间复杂度为2m。</p>
</blockquote>
<p>注意比较的对象：s[M],p[N] # 6. Trie树
高效存储和查找字符串及其次数的数据结构
将字符串拆分为各个字母，组合成一个多叉树。 &gt; 相比于kmp，利用了前缀
&gt; 如：abcdef, root-&gt;a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f-&gt;$ &gt;
对于串树，一般只包含大写或小写字母！一定有限制</p>
<p>son[N][26],cnt[N],idx 理解：trie树内部每个节点占用一个idx,
idx的取值范围为0-N
son[idx][1]指向关联的下个节点，cnt[idx]以此idx为结尾的单词的个数。</p>
<p>所以不可能有son[1][2]和son[1][3],不对有的，这里是指针</p>
<h1 id="并查集">7. 并查集</h1>
<ul>
<li>将两个集合合并</li>
<li>询问两个元素是否在一个集合中 BF: belong[x],
判断两个元素是否在一个集合belong[x]==belong[y];合并需要将一个集合中的所有元素改为另一个
并查集在近乎O(1)的时间内快速支持两个操作。</li>
</ul>
<blockquote>
<p>原理：用树来做，树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点
问题1. 如何判断树根，if(p[x]==x): 特殊情况的处理 问题2.
如何求x的集合编号：while(p[x]!=x) x=p[x]; 时间复杂度
问题3，如何合并两个集合： p[x]是x的集合，p[y]是y的集合，则p[x]=y;</p>
</blockquote>
<p>路径压缩优化：当找到根节点时，把路径上的所有节点都指向根节点. O(1)
&gt;
这里也可以应用一个简单的启发式策略——按秩合并。该方法使用秩来表示树高度的上界，在合并时，总是将具有较小秩的树根指向具有较大秩的树根。简单的说，就是总是将比较矮的树作为子树，添加到较高的树中。为了保存秩，需要额外使用一个与
uset 同长度的数组，并将所有元素都初始化为
0。这样找祖先会减少递归迭代的次数，最坏只有logN次。 暂时这里不采用！</p>
<p>代码核心最关键的就是find()函数！！！</p>
<blockquote>
<p>集合合并的所有问题都可以用
看题目中哪些操作可以优化，考虑什么时候用什么数据结构；操作有什么特点，最小值，堆。
区间和啊， 区间数组，树状数组，线段树！！ 有序链表，平衡树，set来做</p>
</blockquote>
<h1 id="堆">8. 堆</h1>
<p>如何手写一个堆？stl - 插入一个数 - 求集合中的最小值 - 删除最小值</p>
<p>扩展 - 删除任意一个元素 - 修改任意一个元素</p>
<blockquote>
<p>stl中的堆就是优先队列！！priorityqueue 小根堆
从1开始编号，2i表示左孩子节点，2i+1表示右孩子节点 基本操作 down(x){} //
往下移，跟孩子中最小的进行交换。说明最上面的数变大了所以要往下沉，那么是否无法交换了就说明没有必要往下移动了。
up(x){} // 往上移，只需要与根节点进行比较</p>
</blockquote>
<p>变小往上走，变大往下走</p>
<p>数据结构 heap,size</p>
<ul>
<li>插入一个数： heap[++size]=x,up(size)</li>
<li>求最小值： heap[1]</li>
<li>删除最后一个元素: heap[1]=heap[size], size--,down(1);</li>
<li>删除任意一个元素： heap[k]=heap[size],
down(k),up(k)(只执行一个);</li>
<li>修改任意一个元素: heap[k]=x,down(k),up(k) 完全二叉树。</li>
</ul>
<blockquote>
<p>堆排序，把数列建成一个堆，每次把堆顶元素输出</p>
</blockquote>
<ul>
<li>如何建堆？ &gt; 一个一个将数进行插入 nlogn. &gt; O(n),
从n/2开始down到1. n/4+ 2<em>n/8+3</em>n/16 +...=O(n) &gt;
从下往上down可以保证每个儿子都是好的</li>
</ul>
<p>模拟堆， 删除第k个插入的点 &gt; ph[j]=k
第j个插入的点在堆中对应第k个元素 &gt; hp[k]=j
堆中第k个元素对应第j个插入的点 需要存储映射</p>
<h1 id="哈希表">9. 哈希表</h1>
<h2 id="简介">9.1 简介</h2>
<ul>
<li>存储结构 开放寻址法、拉链法</li>
<li>字符串哈希方式</li>
</ul>
<blockquote>
<p>N: 1e5 ,1e6 把值域大的数映射到值域比较小的数 1.
哈希函数，模的数为质数，距离2的整数幂远，数学证明了冲突概率是最小的 2.
冲突 cstring: memset</p>
</blockquote>
<blockquote>
<p>感觉上</p>
</blockquote>
<blockquote>
<p>注意，哈希表能使实际求的时候时间复杂度变低，但是并不意味着空间大小会变小</p>
</blockquote>
<h3 id="方法">9.2 方法</h3>
<h4 id="开放寻址法厕所找坑位法">9.2.1 开放寻址法（厕所找坑位法）</h4>
<p>查找、删除、添加
如果都满了的话find会陷入死循环，但是经验上来说会用2,-3倍的空间大小。
INT_MAX=0x3f3f3f3f; memset()按字节，不能处理vector，
strcopy()遇到<code>\0</code>就结束。 &gt; 哈希表时间复杂度都是O(1)，
用到哈希表O(n). &gt;
不需要sort一遍，如果sort就会从O(n)-&gt;O(nlogn)，变慢</p>
<blockquote>
<p>对比前面的离散化的思想，不过离散化区间和那道题实际上运用了前缀和来做。
#### 9.2.3 字符串哈希方式
对比与KMP，用于查找模板串是否存在，不一定要用KMP算法。</p>
</blockquote>
<p>字符串前缀哈希 h[1]="A" h[2]="ABC" &gt; h[n]:
表示前n个字符串的哈希值； h[0]=0;</p>
<h5 id="问题">问题：</h5>
<ol type="1">
<li>如何定义某个前缀的哈希值？把字符串转化为数字！
把字符串看作是P进制的数（Godel编码） 如"ABCD", 注意需要保证唯一性！！！
对应十进制的数：1<em>p^3 + 2</em>p^2 + 3<em>p^1 + 4</em>p^0</li>
<li>这个数会很大，进行取模, 这里Q会远小于数值: mod Q</li>
</ol>
<p>结果将任何一个字符串映射为了0 ~ Q-1.</p>
<p>注意！ 不能把某一位的字母映射为0, 需要映射为从1开始的数。
假定人品足够好，不考虑冲突；经验值是p取131或13331, Q取2^64,unsigned long
long,
所以就不需要取模了，任意一个数都会自动溢出，在绝大概率保证不会出现冲突。</p>
<p>好处： 可以求出字符串所有子串的哈希值：所以就可以用来作字符串的查找
字符串：[l,r]的哈希值h[r]-h[l-1]*p[r-l+1] &gt;
把所有的看成数位，所以每个数段都有其哈希值。那么，因为最高位当做零位就意味着位数一定？？不需要！！！
因此就可以在线性时间内求出每一段的哈希值。</p>
<p>讨论预处理， h(i)=h(i-1)+str(i); &gt;
因为这里h()相当于取Q的模，所以h就是没有操作 ##### 想想
这里就是超级牛逼的，比KMP还厉害很多！ 问某两端是否完全相同</p>
<p>这里感觉上利用了前缀和的思想以及其他，将字符串通过Godel编码（数的进制的方式），映射为数。
因为每一个前缀都是唯一的，所以必然就前缀唯一 ？？
那怎么知道这多个前缀是否是某一特定的字符串的呢？还有怎么插入数据的？</p>
<p>等下这里完全就没有了哈希的概念！！，它是制定了规则。不是前缀树，需要插入一系列字符串进行查找某个字符串是否存在。
就是根据规则，进行计算数就行了，就比较某个区间的计算出来的结果是否相同</p>
<p>但是，预处理的话，一位是对应着多种结果啊，这些是要事先计算出来吗？</p>
<h5 id="作用">作用</h5>
<p>快速比较两个字符串是否相等。 O(n), O(1)</p>
<p>可解的题： 搜索哈希，直接搜 兔子 回文串 后缀数组 二维哈希</p>
<p>KMP可以用来求循环节。</p>
<h1 id="stl初步">10. STL初步</h1>
<p>vector, string ,queue, priority_queue, stack, dequeue,
set,map,multiset,multimap unordered_set, .... //
c++中实现的哈希表？？？？ bitset 状态压缩</p>
<p>vector 变长数组，倍增思想。 string substr(),
c_str()//对应char数组指针 queue 队列 push， front, pop priorityqueue,
堆，优先队列，push, top(),pop() stack, push, top, pop() dequeue双端队列,
支持随机访问； set,map, 基于平衡树（红黑树）来实现的，动态维护有序序列
unordered, 基于哈希表来实现的 &gt; 需要添加对应的头文件</p>
<p>bitset, 压位 List</p>
<p>set: find() O(n) C++ vector基本用法</p>
<h2 id="vector">vector</h2>
<p>vector<int> a(10,n); size() // O(1) empty() //返回 clear() 特有
系统为某一个进程分配空间时，所需时间与空间大小无关，与申请次数有关。
所以1000和1000次1不一样 倍增的思想</p>
<p>申请一个数组长度n=10^6, 一共要申请logN次，额外copy次数平均为1 front()
back() push_back() pop_back() begin() end() [] a.end()=a[size]
迭代器可以看成是指针 a&lt;b, 支持比较运算，基于字典序</p>
<h2 id="pair">pair</h2>
<p>pair&lt;int,int&gt; p; p.first(), p.second();
支持比较预算，按字典序，以first为第一关键字，second为第二关键字
p=make_pair(10,"yxc") C++11: p={20,"abd"} &gt; 某个东西有两种属性 &gt;
三种不同的属性pair&lt;int, pair&lt;int,int&gt;&gt;</p>
<blockquote>
<p>pair vs struct, 比一般的结构体 string可以用作栈 ## string size()
length() empty(), clear() a+="def", a+='c'; a.substr(0,2) 起始地址，长度
a.c_str()</p>
</blockquote>
<h2 id="queue">queue</h2>
<p>size(), empty(), 没有clear()函数q=queue<int>(); push(), front(),
back(), pop()</p>
<h2 id="priority_queue默认大根堆">priority_queue默认大根堆</h2>
<p>push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素
无clear元素</p>
<p>如何使用小根堆？ 插入时使用负数
priority_queue&lt;int,vector<int>,greater<int>&gt; heap; //
定义小根堆</p>
<h2 id="栈">栈</h2>
<p>push, top,pop,size, empty</p>
<h2 id="deque">deque</h2>
<p>效率非常低 size(), empty(), clear() front()/back()
push_back()/pop_back() push_front()/pop_front() begin()/end() [] ##
set/multiset,map/multimap size() empty() clear() O(1) set/multiset
O(logN) insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数
begin()/end() ++, --返回前驱和后继 O(logN) erase() (1)
输入是一个数，删除所有x, O(k+logn) (2) 输入是一个迭代器, 删除这个迭代器
lower_bound()/upper_bound() !!!! lower_bound()
返回大于等于x的最小的数的迭代器 upper_bound()
返回大于x的最小的数的迭代器，不存在返回end() map/multimap insert()
插入的是一个pair erase() 输入的参数是pair或迭代器 find() []
时间复杂度是O(logN)?? &gt; map&lt;string,int&gt; a; a["yxc"]=1
lower_bound(), upper_bound() &gt; 支持排序</p>
<p>unordered_set,unordered_map,unordered_multiset, unordered_multimap
和上面类似，增删改查的时间复杂度均为O(1)
但是不支持lower_bound()/upper_bound(), 迭代器的++,-- &gt;
凡是排序的都不支持</p>
<p>bitset() &gt; 1024 bool, 1024B=1KB; 用字节来存 1024/8=128 &gt;
什么时候用？ 比如10000*10000 bool, 10^8 B, 100MB, 空间限制是64MB
biset&lt;10000&gt; s; //这里10000指的是个数 ~s取反， &amp;, |, ^
&gt;&gt;, &lt;&lt; ==, != [] 某位 count() 返回有多少个1 any/none()
any()判断至少有一个1 none()判断是否全为0 set() 把所有位置为1 set(k,v)
将第k位变为v reset() 把所有为变为0 flip() 把所有位取反 flip(k)
把第k位取反</p>
<h2 id="注意">注意</h2>
<p>scanf读char时有空格和回车不能处理，读字符串可以进行过滤</p>
<p>比较序列中两个元素的某个关系的最值，如果该关系是双方等价的，那么可以不用存储该元素的数组
先插入再查询可以避免处理空，只是多一个时间复杂度</p>
<p>每次做题前把思路想清楚！！</p>
<p>思考回溯法，在循环前加入语句和循环后加入语句的区别有什么呢</p>
<p>模运算很有意思！！</p>
<p>路径的距离来做</p>
<p>if (a &amp;&amp; b), 注意是b不等于0时为真</p>
<p>segment flase: N常数空间开辟不对，或者循环溢出等等 ## 课后题 ###
最大异或数</p>
<blockquote>
<p>发现这里的思路跟我自己想的还是有很大差别，比如说我的想法就是直接分析题。怎么得到一组数中所有的最大的异或数。
这里的做法就是O(n<sup>3)-&gt;O(n</sup>2) 记住一定要从暴力解开始出发
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Trie树来做</span><br><span class="line">int res=0;</span><br><span class="line"></span><br><span class="line">// a1,a5;a5,a1; 规定小于数</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123; // 枚举第一个数</span><br><span class="line">    for(int j=0;j&lt;r;j++)&#123;  // 试图找最大的数</span><br><span class="line">        max=res(max,ai^aj);</span><br><span class="line">    &#125; // 枚举第二个数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">首先考虑如何寻找最大的异或数。 </span><br><span class="line">首先找第30位是0的数</span><br><span class="line">倒序找数</span><br></pre></td></tr></table></figure>
注意这里M的取值是看实际情况中Trie树中最多有多少个节点，所以要看多种情况来做。
每个叶节点代表一个集合，表示所有能往下走的数。</p>
</blockquote>
<blockquote>
<p>与一开始想法不同的点是，倒序排序的，把所有树给撑满，自己的想法这点出问题了
举例子</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res= res*2+u;</span><br><span class="line">res +=1&lt;&lt;i;</span><br><span class="line"></span><br><span class="line">res=1101 -&gt; 11011  二进制乘法的感觉</span><br></pre></td></tr></table></figure>
<h3 id="食物链">食物链</h3>
<blockquote>
<p>首先应该分析题，发现题中种类关系是如此少，以至于所有关系放在一个类中即可</p>
</blockquote>
<blockquote>
<p>哇，居然从路的路径长度入手来看，nb。
由距离进行定义，使用模的关系！！厉害，看每个人和领袖之间的距离关系
所以说，构造的时候实际上使用的增加最小长度的路径</p>
</blockquote>
<blockquote>
<p>三类，吃、被吃、同类</p>
</blockquote>
<p>算法 &gt; 初始化，每个节点都是根节点，所以初始化为0</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/algorithm/" rel="tag"># algorithm</a>
              <a href="/tags/acwing/" rel="tag"># acwing</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/09/19/nju-course-mapreduce-experiment/" rel="prev" title="nju-course mapreduce experiment">
      <i class="fa fa-chevron-left"></i> nju-course mapreduce experiment
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/09/19/algorithm-acwing-dp/" rel="next" title="algorithm acwing dp">
      algorithm acwing dp <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-gitalk">gitalk</a></li>
            <li class="tab"><a href="#comment-livere">livere</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane gitalk" id="comment-gitalk">
              <div class="comments" id="gitalk-container"></div>
            </div>
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80NjU1Mi8yMzA2Mg=="></div>
  </div>
  
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-number">1.</span> <span class="nav-text">1. 链表与邻接表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">2.</span> <span class="nav-text">3. 单调栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="nav-number">3.</span> <span class="nav-text">4. 单调队列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#kmp"><span class="nav-number">4.</span> <span class="nav-text">5. KMP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">5.</span> <span class="nav-text">7. 并查集</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">6.</span> <span class="nav-text">8. 堆</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">7.</span> <span class="nav-text">9. 哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">7.1.</span> <span class="nav-text">9.1 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">7.1.1.</span> <span class="nav-text">9.2 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95%E5%8E%95%E6%89%80%E6%89%BE%E5%9D%91%E4%BD%8D%E6%B3%95"><span class="nav-number">7.1.1.1.</span> <span class="nav-text">9.2.1 开放寻址法（厕所找坑位法）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">7.1.1.1.1.</span> <span class="nav-text">问题：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">7.1.1.1.2.</span> <span class="nav-text">作用</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#stl%E5%88%9D%E6%AD%A5"><span class="nav-number">8.</span> <span class="nav-text">10. STL初步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#vector"><span class="nav-number">8.1.</span> <span class="nav-text">vector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pair"><span class="nav-number">8.2.</span> <span class="nav-text">pair</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#queue"><span class="nav-number">8.3.</span> <span class="nav-text">queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#priority_queue%E9%BB%98%E8%AE%A4%E5%A4%A7%E6%A0%B9%E5%A0%86"><span class="nav-number">8.4.</span> <span class="nav-text">priority_queue默认大根堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">8.5.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deque"><span class="nav-number">8.6.</span> <span class="nav-text">deque</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">8.7.</span> <span class="nav-text">注意</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A3%9F%E7%89%A9%E9%93%BE"><span class="nav-number">8.7.1.</span> <span class="nav-text">食物链</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yun-Pan Wang"
      src="/images/default-avatar.png">
  <p class="site-author-name" itemprop="name">Yun-Pan Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">115</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AugF" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AugF" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wangyp@smail.nju.edu.cn" title="E-Mail → mailto:wangyp@smail.nju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/Joswxe" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;Joswxe" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.google.com/" title="https:&#x2F;&#x2F;www.google.com" rel="noopener" target="_blank">Google</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://cn.bing.com/" title="https:&#x2F;&#x2F;cn.bing.com" rel="noopener" target="_blank">Bing</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">Baidu</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">[object Object]</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">466k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:04</span>
</div>!

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '9552a863f697c06e137f',
      clientSecret: '65716dc606be017204585b55c9858ede23eae0b9',
      repo        : 'augf.github.io',
      owner       : 'AugF',
      admin       : ['AugF'],
      id          : '68e089e2f4e08c50109c90f52db134b4',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
