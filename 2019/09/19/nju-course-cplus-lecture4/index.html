<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"augf.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="重点 泛型程序设计 一个程序实体能对多种类型的数据进行操作或描述的特性称为类属性。具有类属性的程序实体通常有： 1. 类属函数 2. 类属类 类属也是一种多态，称为参数化多态。 比如说用通用指针。 如上所示，C++提供了两种实现类属函数的机制 - 采用通用指针类型的参数(C语言的做法) - 函数模板 通用指针 整个世界就是由1构成的，可以升为万物的。 void *，所有的父类。">
<meta property="og:type" content="article">
<meta property="og:title" content="nju-course-cplus-lecture4">
<meta property="og:url" content="https://augf.github.io/2019/09/19/nju-course-cplus-lecture4/index.html">
<meta property="og:site_name" content="Life&#39;s Notes">
<meta property="og:description" content="重点 泛型程序设计 一个程序实体能对多种类型的数据进行操作或描述的特性称为类属性。具有类属性的程序实体通常有： 1. 类属函数 2. 类属类 类属也是一种多态，称为参数化多态。 比如说用通用指针。 如上所示，C++提供了两种实现类属函数的机制 - 采用通用指针类型的参数(C语言的做法) - 函数模板 通用指针 整个世界就是由1构成的，可以升为万物的。 void *，所有的父类。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-09-19T01:51:16.000Z">
<meta property="article:modified_time" content="2021-05-27T01:05:35.000Z">
<meta property="article:author" content="Yun-Pan Wang">
<meta property="article:tag" content="nju">
<meta property="article:tag" content="course">
<meta property="article:tag" content="cplus">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://augf.github.io/2019/09/19/nju-course-cplus-lecture4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>nju-course-cplus-lecture4 | Life's Notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Life's Notes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">岁月数载，愿不负韶华</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/nju-course-cplus-lecture4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          nju-course-cplus-lecture4
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:51:16" itemprop="dateCreated datePublished" datetime="2019-09-19T09:51:16+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">course</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/" itemprop="url" rel="index"><span itemprop="name">nju</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/cplus/" itemprop="url" rel="index"><span itemprop="name">cplus</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="重点">重点</h1>
<h2 id="泛型程序设计">泛型程序设计</h2>
<p>一个程序实体能对多种类型的数据进行操作或描述的特性称为类属性。具有类属性的程序实体通常有：
1. 类属函数 2. 类属类</p>
<p>类属也是一种多态，称为参数化多态。</p>
<p>比如说用通用指针。</p>
<p>如上所示，C++提供了两种实现类属函数的机制 -
采用通用指针类型的参数(C语言的做法) - 函数模板</p>
<h3 id="通用指针">通用指针</h3>
<p>整个世界就是由1构成的，可以升为万物的。 void
*，所有的父类。通用的都是byte.</p>
<p>这些东西然后不断地转换为其他的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> 函数定义：</span><br><span class="line"> void sort(void *base, unsigned int count, unsigned  int element_size, int (*cmp)(const void*, const void*))&#123;</span><br><span class="line">     // 这里函数参数和也可以诶，发现我完全想复杂了。也就是说这里的话，只要弄个函数名做参数，其实也不所谓，没有我想的那么复杂，哈哈哈！两步就可以了</span><br><span class="line">     // 取第i个元素</span><br><span class="line">     (byte *)base + i*element_size</span><br><span class="line"></span><br><span class="line">    // 比较第i个和第j个元素的大小，利用调用者提供的回调函数cmp实现</span><br><span class="line">    (*cmp)((byte *)base + i*element_size, (byte*)base + j*element_size)</span><br><span class="line"></span><br><span class="line">    // 交换第i个和第j个元素</span><br><span class="line">    byte *p1 = (byte *)base + i*element_size;</span><br><span class="line">    byte *p2 = (byte *)base + j*element_size;</span><br><span class="line">    for(int k=0;k &lt; element_size;k++)&#123;</span><br><span class="line">        byte temp=p1[k]; p1[k]=p2[k]; p2[k]=temp;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> 这里的byte为typedef unsigned char byte;</span><br><span class="line"></span><br><span class="line">void sort(void *base, //需排序的数据（数组）首地址</span><br><span class="line">             unsigned int count, //数据元素的个数</span><br><span class="line">             unsigned int element_size, //一个数据元素所需的空间大小</span><br><span class="line">             int (*cmp)(const void *, const void *) ) //比较两个元素的函数</span><br><span class="line">&#123;   //不论采用何种排序算法，一般都需要对数组进行以下操作：	</span><br><span class="line">     //取第i个元素</span><br><span class="line">        (char *)base+i*element_size</span><br><span class="line">     //比较第i个和第j个元素的大小 （利用调用者提供的回调函数cmp实现）</span><br><span class="line">        (*cmp)((char *)base+i*element_size,</span><br><span class="line">                    (char *)base+j*element_size)</span><br><span class="line">     //交换第i个和第j个元素</span><br><span class="line">        char *p1=(char *)base+i*element_size,</span><br><span class="line">	     *p2=(char *)base+j*element_size;</span><br><span class="line">        for (int k=0; k&lt;element_size; k++)</span><br><span class="line">        &#123;	char temp=p1[k]; p1[k] = p2[k]; p2[k] = temp;</span><br><span class="line">        &#125; </span><br><span class="line">&#125; //上面的char用byte替代更好！typedef unsigned char byte;</span><br></pre></td></tr></table></figure>
<p>调用者需要调用 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int A_compare(const void* p1, const void* v2)&#123;</span><br><span class="line">    if(*(*A)p1 &lt; *(A*)p2) return -1;</span><br><span class="line">    else if(*(*A)p1) &gt; *(A*)p2) return 1;</span><br><span class="line">    else return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类属排序函数的使用</span><br><span class="line">int a[100];</span><br><span class="line">sort(a,100,sizeof(int),int_compare);</span><br><span class="line">double b[200];</span><br><span class="line">sort(b,200,sizeof(double), double_compare);</span><br><span class="line">A c[300]; // 如果这里A是类，就显示出了将比较符号重载的有效性</span><br><span class="line">sort(c,300,sizeof(A),A_compare)</span><br></pre></td></tr></table></figure> 品味！</p>
<h3 id="函数模板">函数模板</h3>
<p>函数模板是指带有类型参数的函数定义，其一般格式如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T1, class T2,...&gt;</span><br><span class="line">&lt;返回值类型&gt; &lt;函数名&gt;(&lt;参数表&gt;)&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void sort(T elements[], unsigned int count)&#123;</span><br><span class="line">    // 取第i个元素</span><br><span class="line">    elements[i]</span><br><span class="line">    // 比较第i个和第j个元素的大小</span><br><span class="line">    elements[i]&lt; elemnets[j]</span><br><span class="line">    // 交换第i个和第j个元素</span><br><span class="line">    T temp = elements[i];</span><br><span class="line">    elements[i] = elements[j];</span><br><span class="line">    elements[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; 来一起感叹，太他妈牛逼了。这template省去了好多麻烦！好高层的一种抽象，太棒了，果然！牛逼死了</span><br><span class="line"></span><br><span class="line">int a[100];</span><br><span class="line">sort(a, 100);</span><br><span class="line">double b[200];</span><br><span class="line">sort(b,200);</span><br><span class="line">A c[300];</span><br><span class="line">sort(c, 300);</span><br></pre></td></tr></table></figure></p>
<p>函数模板的使用——实例化 - 函数模板定义了一系列重载的函数 -
要使用函数模板所定义的函数，称为模板函数，首先必须对函数模板进行实例化：给模板参数提供一个类型作为值，从而生成具体的函数。
- 函数模板的实例化通常是隐式的 - 由编译程序来做，模板实参推演</p>
<p>当编译程序无法根据调用时的参数类型来确定所调用的模板参数，这时，需要在程序中显式第实例化函数模板。</p>
<p>除了类型参数外，函数模板也可以带有非类型参数，使用时需要显式实例化。
template&lt;class T, int size&gt; void f(T a){ T temp[size]; }</p>
<h3 id="类模板">类模板</h3>
<p>如果一个类的成员的类型可变，则该类称为类属类。在C++中，类属类用类模板实现。
template&lt;class T1, class T2&gt; class <类名>{}</p>
<p>使用 Stack<int> st1;</p>
<p>!!!
类模板中的静态成员仅属于实例化后的类，不同类模板实例之间不共享类模板中的静态成员。
template <class T> class A{ static int x; }</p>
<p>注意！在自己定义时，需要把模板的定义和实现都放在头文件中。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// file1.h</span><br><span class="line">template &lt;class T&gt; </span><br><span class="line">class S //类模板s的定义</span><br><span class="line">&#123;  T a;</span><br><span class="line">  public:</span><br><span class="line">    void f();</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;class T&gt; </span><br><span class="line">void S&lt;T&gt;::f() //类模板s的实现  如果放在对应的file1.cpp中，会显示该实例不存在</span><br><span class="line">&#123; ......</span><br><span class="line">&#125;</span><br><span class="line">extern void func();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
使用者通过包含这个头文件，把模板的源代码全包含进来，以备实例化所需。
因此，模板是基于源代码的复用、</p>
<ul>
<li>重复实例的处理
模板的复用会导致多模块的编译结果中存在相同的实例：</li>
</ul>
<ol type="1">
<li>相同的函数模板实例</li>
<li>相同的类模板成员函数实例 相同代码的存在会造成目标代码庞大！
如何处理？</li>
</ol>
<ul>
<li>由开发环境来解决：编译第二个模块的时候不生成这个函数</li>
<li>由连接程序来解决：舍弃多余的那一个</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">关于类模板的友元</span><br><span class="line">template &lt;class T&gt; class A;</span><br><span class="line">template &lt;class T&gt; void f3(A&lt;T&gt;&amp; a) &#123; ... &#125;</span><br><span class="line">template class&lt;T&gt;</span><br><span class="line">class A</span><br><span class="line">&#123; T x,y;</span><br><span class="line">  ......</span><br><span class="line">  friend void f1(A&lt;T&gt;&amp; a); //友元f1不是模板！</span><br><span class="line">  template &lt;class T1&gt; friend void f2(A&lt;T1&gt;&amp; a); //f2与A多对多实例化</span><br><span class="line">  friend void f3&lt;T&gt;(A&lt;T&gt;&amp; a); //f3与A一对一实例化(用相同参数类型)</span><br><span class="line">&#125;;</span><br><span class="line">void f1(A&lt;int&gt;&amp; a) &#123; ... &#125;</span><br><span class="line">template &lt;class T&gt; void f2(A&lt;T&gt;&amp; a) &#123;...&#125;</span><br><span class="line">......</span><br><span class="line">A&lt;int&gt; a1; //实例化A&lt;int&gt;</span><br><span class="line">A&lt;double&gt; a2; //实例化A&lt;double&gt;</span><br><span class="line">f1(a1); //OK，调用f1(A&lt;int&gt;&amp;)</span><br><span class="line">f1(a2); //链接错误! 调用f1(A&lt;double&gt;&amp;)，但它不存在！</span><br><span class="line">f2(a1); //实例f2&lt;int&gt;是A&lt;int&gt;和A&lt;double&gt;的友元</span><br><span class="line">f2(a2); //实例f2&lt;double&gt;是A&lt;int&gt;和A&lt;double&gt;的友元</span><br><span class="line">f3(a1); //实例f3&lt;int&gt;是A&lt;int&gt;的友元，但不是A&lt;double&gt;的友元！</span><br><span class="line">f3(a2); //实例f3&lt;double&gt;是A&lt;double&gt;的友元，但不是A&lt;int&gt;的友元！</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：友元是外部，在说明友元时也需要在外部进行说明。</p>
</blockquote>
<h3 id="c标准库">C++标准库</h3>
<p>在C++标准库中，除了C标准库保留下来的一些功能外，其它功能大都以模板形式给出，这些模板构成了C++的标准模板库。
STL实现了数据结构和算法的复用，体现了泛型程序设计的精髓。
STL支持了一种编程思想模式。</p>
<p>STL主要包含： -
容器类模板：用于存储序列化数据元素，比如：向量、队列、栈、集合等 -
算法（函数）模板：用于对容器中数据元素进行一些常用的操作，如：排序、查找、求和等
- 迭代器类模板：实现了抽象的指针功能，它用于指向容器中的元素。 -
迭代器是容器和算法之间的桥梁：传给算法的不是容器，而是指向容器中元素的迭代器，算法通过迭代器实现对容器中数据元素的访问和遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    int x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    while(x&gt;0)&#123;</span><br><span class="line">        v.push_back(x);</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt;::iterator it1=v.begin();</span><br><span class="line">    vector&lt;int&gt;::iterator it2=v.end();</span><br><span class="line">    cout&lt;&lt;&quot;Max= &quot;&lt;&lt;*,ax_element(it1, it2)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&quot;Sum=&quot;&lt;&lt;accumulate(it1, it2, 0)&lt;&lt;endl;</span><br><span class="line">    sort(it1, it2);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;Sorted result is:\n&quot;;</span><br><span class="line">    for_each(it1, it2,[](int x)&#123;cout&lt;&lt;x&lt;&lt;&#x27;&#x27;; return;&#125;)</span><br><span class="line">    cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="容器">容器</h4>
<p>容器是由长度可变的同类型元素所构成的序列。
STL中包含了很多种容器，虽然这些容器提供了很多相同的操作，但采用了不同的内部实现方法，所以不同的容器适合不同的应用场合。
容器由类模板来实现</p>
<ul>
<li><p>vector&lt;&gt;
需要快速定位任意位置上的元素以及主要在元素序列的尾部增加、删除元素的场合
在头文件vector中定义，用动态数组实现</p></li>
<li><p>list&lt;&gt; 用于经常在元素序列中任意位置上插入或删除元素的场合。
list, 双向链表实现</p></li>
<li><p>dequeue&lt;&gt;
用于主要在元素序列的两端增加、删除元素以及需要快速定位任意位置上的元素的场合
dequeue, 用分段的连续空间结构实现</p></li>
<li><p>stack&lt;&gt; 用于仅在元素序列的尾部增加、删除元素的场合
基于deque实现</p></li>
<li><p>queue&lt;&gt; 用于仅在元素序列的头部增加、删除元素的场合
基于dequeue实现</p></li>
<li><p>priority_queue&lt;&gt;
与queue的操作类似，不同之处在于：每次增加，删除元素之后，它将元素位置进行调整，使得头部元素总是最大的。每次删除操作总是把最大的元素去掉。
在queue中定义，一般基于vector和heap实现</p></li>
<li><p>map&lt;关键字类型，值类型&gt; multimap</p></li>
<li><p>容器中每个元素是一个pair结构类型，该结构有两个成员：first和second，关键字对应first,
值对应second,元素是根据其关键字排序的。用于需要根据关键字来访问元素的场合</p></li>
<li><p>对于map，不同元素的关键字不能相同；对于multimap,不同元素的关键字可以相同</p></li>
<li><p>map中定义</p></li>
<li><p>set<元素类型> multiset</p></li>
<li><p>相对于map和multimap, 合一了</p></li>
<li><p>set中定义</p></li>
<li><p>basic_string&lt;&gt;</p></li>
<li><p>与vector类似，不同之处在于其元素作为字符类型，并提供了一系列与字符串相关的操作</p></li>
<li><p>string和wstring分别是它的两个实例：
basic_string<char>和basic_string<wchar_t></p></li>
<li><p>在string中定义</p></li>
</ul>
<h4 id="容器的操作">容器的操作</h4>
<ul>
<li>获取指定位置的元素</li>
<li>增加元素</li>
<li>删除元素</li>
<li>查找元素</li>
<li>获取容器首、尾元素的迭代器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">T &amp;front();</span><br><span class="line">T &amp;back();  // vector, list,dequeue,queue</span><br><span class="line"></span><br><span class="line">void push_front(const T&amp;x) void pop_front;  //list,deque</span><br><span class="line">void push_back(const T&amp;x) void pop_back; //vector,list,dequeue</span><br><span class="line"></span><br><span class="line">void push(const T&amp;x) // 尾部stack, queue, priority_queue</span><br><span class="line">void pop() // 尾部stack, 头部queue, priority_queue</span><br><span class="line"></span><br><span class="line">T &amp;top();  const T&amp;top() const;  尾部stack , 头部priority_queue</span><br><span class="line"></span><br><span class="line">iterator begin();</span><br><span class="line">const_iterator begin() const;  除queue,priority queue, stack</span><br><span class="line">// 为什么有两种？有啥不一样的用的地方吗？</span><br><span class="line"></span><br><span class="line">iterator end();</span><br><span class="line">const_iterator end() const; 同上</span><br><span class="line"></span><br><span class="line">iterator insert(iterator pos, const T&amp; x);</span><br><span class="line">void insert(iterator pos, InputIt first, InputIt last);</span><br><span class="line">// pos 插入一个呼呼多个元素， vector, list, deque</span><br><span class="line"></span><br><span class="line">iterator erase(iterator pos)</span><br><span class="line">iterator erase(iterator first, iterator last);</span><br><span class="line">// vector, list, deque, map/multimap, set, basic_string</span><br><span class="line"></span><br><span class="line">T &amp;operator[](size_type pos)</span><br><span class="line">// pos上的引用， vector, deque, basic_string</span><br><span class="line"></span><br><span class="line">ValueType &amp; operator[](const KeyType&amp; key); // map</span><br><span class="line"></span><br><span class="line">T&amp; at(size_type pos);</span><br><span class="line">相比于[], 进行了越界检查； vector,deque,basic_string</span><br><span class="line"></span><br><span class="line">iterator find(const T&amp; key);</span><br><span class="line">// 根据关键字查找，找到返回；否则返回最后一个元素的下一个位置</span><br></pre></td></tr></table></figure>
<blockquote>
<p>值得注意的是，如果容器的元素类型是一个类，则针对该类需要： 1.
自定义拷贝构造函数和赋值操作符重载函数。 2. 重载比较操作符&lt;</p>
</blockquote>
<h4 id="迭代器">迭代器</h4>
<p>迭代器是实现了抽象的指针（智能指针）。它们指向容器中的元素。 &gt;
哇，抽象指针，牛逼</p>
<p>在STL中，迭代器是作为类模板来实现的，它们可以分为以下几种： -
输出迭代器output iterator - 用来修改它所指向的容器元素 - 间接访问操作
*输出迭代器 - ++操作</p>
<ul>
<li><p>输入迭代器input iterator</p>
<ul>
<li>用于读取它指向的容器元素</li>
<li>间接访问操作 *p</li>
<li>元素成员间接访问-&gt;</li>
<li>++, ==, !=操作</li>
</ul></li>
<li><p>前向迭代器 &gt;
哇，这个就应该是方向有关吧。只能一个方向，不过好奇的是这个方向有规定只能从头到尾吗？感觉上应该两种都被允许
用于读取、修改它所指向的容器元素 元素间间接访问操作和元素成员间接访问.
同义获取关联的对象 &gt;
如果是int，则访问的是其值，就对应于第一种情况；如果是类，就对应于第二种情况。
++,==,!=操作</p></li>
<li><p>双向迭代器 用于读取，修改它所指向的容器元素
元素间接访问操作和元素成员间接访问操作 ++,--,==,!=</p></li>
<li><p>随机访问迭代器 用于读取、修改它所要指向的容器元素
元素间接访问操作、元素成员间接访问和随机访问元素操作
++,--,&gt;=,&lt;,&gt; &gt;
随机访问吗？应该是对于固定存储的吧？不然实现算法复杂度不一样唉，真好奇实现方法。
&gt; 对！下面得到了回答</p></li>
</ul>
<p>从上到下，从派生类到基类</p>
<p>哦，来啦</p>
<p><strong>各容器的迭代器类型</strong> - vector,deque, basic_string,
begin/end返回的是随机访问迭代器 - list,map,set返回的是双向迭代器 &gt;
这两个因为内部的物理实现结构不一样 -
对于queue,stack,priority_queue,不支持迭代器 &gt;
为啥，不支持前向后向吗？queue本身支持，但是因为queue,stack有其特定的持有顺序所以不支持吗？特殊功能，而priority_queue更是由于实现复杂。每一次动荡代价不一样。</p>
<blockquote>
<p>迭代器的作用就是每个变量的指示，最多的应用自己所见到的就是遍历。所以怎么说感觉上应该能得到下一个元素的地址的那种</p>
</blockquote>
<h4 id="算法">算法</h4>
<p>分类 调序算法 编辑算法 查找算法 算术算法 集合算法 堆算法
元素遍历算法</p>
<p>STL算法体现了一种高度抽象： - 每一个算法都完成一个特定的功能 -
大部分算法都是遍历指定的容器元素，对满足条件的元素执行默认的或自定义的操作。
-
使用者只需要提供：容器（迭代器）、操作条件以及自定义操作，而控制逻辑则有算法内部实现。循环不用操心</p>
<p>算法处理的是容器的迭代器，这样的好处很明显，能够提高算法对容器的适应性。虽然容器各不相同，一个算法往往可以接受相容的多种迭代器</p>
<p>一个算法能接收的迭代器的类型时通过算法模板参数的名字来体现的。一个算法能接收与参数类型相容的所有种类的迭代器。
&gt;
这里应该不是都是最大的权限即随机访问迭代器吧？这样虽然特别妙？不对指针不应该是指向基类吗？那么怎么的？感觉上应该是限定的</p>
<p>然后就规定一下显式的操作说明吧：
参数容器的作用范围应该一样。一般地，参数(src_first, src_last,
dst_first)</p>
<p>自定义操作
有些算法要求使用者提供一个函数或函数对象作为自定义的操作条件，因为往往返回结果为false或true.
所以可以看作谓词。 Pred: 一元谓词，需要一个元素作为参数
BinPred:二元谓词，需要两个元素作为参数 eg: count_if(InIt first,InIt
last, Pred cond); &gt; 注意这里的默认参数，感觉上应该与vector<int>x,
这里的int, 即class相关。 即一元谓词，二元谓词的参数。对的！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;numeric&gt;</span><br><span class="line">accumulate() // 累积算法,返回值</span><br><span class="line">transform() // 变换，映射算法</span><br></pre></td></tr></table></figure>
<p>发现越到后面越有点像数据库的内容了。</p>
<ul>
<li>作业 STL算法应用——在学生容器中做统计 学生：name, sex, birth_place,
major 功能：init, sort, display, match_major. &gt;
match_major内容特别多，可以考虑用函数对象来做</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">利用函数对象来解决上面的问题</span><br><span class="line">class MatchMajor</span><br><span class="line">&#123;	   Major major;</span><br><span class="line">	public:</span><br><span class="line">	   MatchMajor (Major m)</span><br><span class="line">	   &#123;	major = m;</span><br><span class="line">	   &#125;</span><br><span class="line">	   bool operator ()(Student&amp; st)</span><br><span class="line">	   &#123; return st.get_major() == major;</span><br><span class="line">	   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">count_if(students.begin(),students.end(),</span><br><span class="line">			              MatchMajor(COMPUTER))；</span><br><span class="line">count_if(students.begin(),students.end(),</span><br><span class="line">			              MatchMajor(PHYSICS))；</span><br><span class="line">count_if(students.begin(),students.end(),</span><br><span class="line">			              MatchMajor(XXX))；</span><br><span class="line"></span><br><span class="line">// 扩展</span><br><span class="line"></span><br><span class="line">    bool operator ()(Student&amp; st)</span><br><span class="line">    &#123; return st.get_major() == major &amp;&amp; st.get_sex() == sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">count_if(students.begin(),students.end(),</span><br><span class="line">             MatchMajorAndSex(COMPUTER,FEMALE)) //计算机女生</span><br><span class="line"></span><br><span class="line">// lambda表达式</span><br><span class="line">count_if(students.begin(),students.end(),</span><br><span class="line">        [](Student &amp;st) &#123; return (st.get_major() == COMPUTER)</span><br><span class="line">			     &amp;&amp; (st.get_sex() == FEMALE); &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//统计出生地为&quot;南京籍计算机专业&quot;的学生人数</span><br><span class="line">cout &lt;&lt; &quot;出生地为\&quot;南京\&quot;的学生人数是：&quot; </span><br><span class="line">      &lt;&lt; count_if(students.begin(),students.end(),</span><br><span class="line">  [](Student &amp;st) &#123; return (st.get_major() == COMPUTER) </span><br><span class="line">          &amp;&amp; (st.get_birth_place().find(&quot;南京&quot;)!= string::npos);&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的思想很妙，但对象作为函数传递时，默认调用的就是A()，无参数的，所以此时就显示出了重载()运算符的好处</p>
<blockquote>
<p>当实体完全是为了存储数据使用的时候，此时就演化为了数据库这门课程</p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/nju/" rel="tag"># nju</a>
              <a href="/tags/course/" rel="tag"># course</a>
              <a href="/tags/cplus/" rel="tag"># cplus</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/09/19/nju-course-cplus-lecture3-summary/" rel="prev" title="nju-course-cplus-lecture3-summary">
      <i class="fa fa-chevron-left"></i> nju-course-cplus-lecture3-summary
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/09/19/nju-course-cplus-lecture4-summary/" rel="next" title="nju-course-cplus-lecture4-summary">
      nju-course-cplus-lecture4-summary <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-gitalk">gitalk</a></li>
            <li class="tab"><a href="#comment-livere">livere</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane gitalk" id="comment-gitalk">
              <div class="comments" id="gitalk-container"></div>
            </div>
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80NjU1Mi8yMzA2Mg=="></div>
  </div>
  
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E7%82%B9"><span class="nav-number">1.</span> <span class="nav-text">重点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.1.</span> <span class="nav-text">泛型程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E6%8C%87%E9%92%88"><span class="nav-number">1.1.1.</span> <span class="nav-text">通用指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.2.</span> <span class="nav-text">函数模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.3.</span> <span class="nav-text">类模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-number">1.1.4.</span> <span class="nav-text">C++标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">容器的操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">算法</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yun-Pan Wang"
      src="/images/default-avatar.png">
  <p class="site-author-name" itemprop="name">Yun-Pan Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">115</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AugF" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AugF" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wangyp@smail.nju.edu.cn" title="E-Mail → mailto:wangyp@smail.nju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/Joswxe" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;Joswxe" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.google.com/" title="https:&#x2F;&#x2F;www.google.com" rel="noopener" target="_blank">Google</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://cn.bing.com/" title="https:&#x2F;&#x2F;cn.bing.com" rel="noopener" target="_blank">Bing</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">Baidu</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">[object Object]</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">466k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:04</span>
</div>!

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '9552a863f697c06e137f',
      clientSecret: '65716dc606be017204585b55c9858ede23eae0b9',
      repo        : 'augf.github.io',
      owner       : 'AugF',
      admin       : ['AugF'],
      id          : 'f40fa2911f0a23b18c5737237487296b',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
