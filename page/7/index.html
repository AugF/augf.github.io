<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ypwang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Life&#39;s Notes">
<meta property="og:url" content="https://ypwang.github.io/page/7/index.html">
<meta property="og:site_name" content="Life&#39;s Notes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yun-Pan Wang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ypwang.github.io/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Life's Notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Life's Notes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">岁月数载，愿不负韶华</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/nju-course-cplus-lecture6-0d4b502fed85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/nju-course-cplus-lecture6-0d4b502fed85/" class="post-title-link" itemprop="url">nju-course-cplus-lecture6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:56:10" itemprop="dateCreated datePublished" datetime="2019-09-19T09:56:10+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">course</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/" itemprop="url" rel="index"><span itemprop="name">nju</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/cplus/" itemprop="url" rel="index"><span itemprop="name">cplus</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="重点">重点</h1>
<p>Windows简介 消息驱动的程序结构 基于Windows
API的过程式Window应用陈旭设计
基于MFC和"文档-视"结构的面向对象Windows应用程序设计</p>
<h2 id="windows简介">Windows简介</h2>
<p>Window是一种基于图形界面的多任务操作系统 -
系统中可以同时运行多个应用程序 - 每个应用程序通过窗口与用户进行交互 -
用户通过鼠标的单击，双击，拖放，菜单选择以及键盘输入来进行操作</p>
<p>Windows功能以两种方式提供： -
工具（应用程序）：资源管理器、记事本、画图，。。。直接使用 - 函数库:
作为Windows的API。</p>
<p>单文档应用 - 只能对一个文档的数据进行操作 -
只有结束当前文档的操作后，才能进行下一个文档的操作 多文档应用 -
可以同时对多个文档的数据进行操作 -
不必等到一个文档的所有操作结束，就可以对其它文档进行操作，对不同文档的操作是在不同的子窗口进行的
对话框应用 - 以对话框的形式操作一个文档数据 -
对文档数据的操作以各种control空间来实现 -
程序以按确定或取消等按钮来结束</p>
<p>Windows应用程序的结构属于消息（事件）驱动的结构：
程序的任何一个动作都是在接受到一条消息后发生的</p>
<p>Windows的消息有： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WM_KEYDOWN/WM_KEYUP（键盘按键）</span><br><span class="line">WM_CHAR（字符）</span><br><span class="line">WM_LBUTTONDOWN/WM_LBUTTONUP/WM_LBUTTONDBLCLK/WM_MOUSEMOVE （鼠标按键）</span><br><span class="line">WM_COMMAND（菜单）</span><br><span class="line">WM_PAINT（窗口内容刷新）</span><br><span class="line">WM_TIMER（定时器消息）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
每个Windows应用程序都有一个消息队列，Windows系统会把各个应用程序的消息放入各自的消息队列。
大部分的消息都关联到某个窗口 - 每个窗口都有一个消息处理函数</p>
<p>Windows应用程序不断从自己的消息队列中获取消息并调用相应窗口中的消息处理函数来处理获得的消息。
这个“取消息-处理消息”的过程构成了消息循环。
当取到某个特定消息后，消息循环结束。</p>
<p>主程序 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//初始化</span><br><span class="line">...</span><br><span class="line">// 进入消息循环</span><br><span class="line">while(取消息)   消息队列</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    //处理消息 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 消息处理函数：
注意：每个消息的处理时间不宜太长，否则会造成程序"假死"现象(程序不响应其它消息)
&gt;
这个消息队列应该是最外面的队列吧，那么对于最里面的队列。每个队列都是这样做的吗？好奇！</p>
<h2 id="基于window-api的过程式windows应用程序设计">基于Window
API的过程式Windows应用程序设计</h2>
<p>每个Windows应用程序都必须提供一个主函数WinMain，其主要功能是: -
注册窗口类：窗口的基本信息：名字、基本风格、消息处理函数、图标、光标、背景颜色;
每类窗口都需要注册 - 创建应用程序的主窗口，其他窗口等需要时再创建 -
进入消息循环，直到接收到WM_QUIT消息后，消息循环结束。</p>
<p>程序还要为每类窗口提供一个消息处理函数，用于处理发送到它的消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR IpCmdLine, int nCmdShow // 主窗口显式方式)</span><br><span class="line">WinMain()&#123;</span><br><span class="line">    // 注册窗口类</span><br><span class="line">    RegisterClass(.., WindowProc, &quot;my window class&quot;);</span><br><span class="line">    ...</span><br><span class="line">    // 创建主窗口</span><br><span class="line">    HWND hWnd;</span><br><span class="line">    hWnd = CreateWindow(&quot;my window class&quot;, ..., x,y, width,height,...)</span><br><span class="line">    ShowWindow(hWnd, nCmdShow)</span><br><span class="line">    ...</span><br><span class="line">    // 进入消息循环</span><br><span class="line">    while(GetMessage(&amp;msg, NULL, 0, 0))&#123; // 消息队列</span><br><span class="line">        ...</span><br><span class="line">        DispatchMessage(&amp;msg) // 消息处理函数</span><br><span class="line">    &#125;</span><br><span class="line">    return msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 窗口处理函数</span><br><span class="line">LRESULT CALLBACK WindowProc(HWND hWnd, // 窗口标志 </span><br><span class="line">                            UINT message, // 消息标识, WPARAM wParam, LPARAM lParam...) &#123;</span><br><span class="line">    switch(message) &#123;</span><br><span class="line">        case WM_KEYDOWN:</span><br><span class="line">            wParam   //wParam为按键在键盘上的位置，扫描码</span><br><span class="line">        case WM_CHAR: // 字符健消息</span><br><span class="line">            wParam</span><br><span class="line">        case WM_COMMAND: // 菜单消息</span><br><span class="line">            switch(wParam) //wParam是菜单项的标识</span><br><span class="line">            &#123;</span><br><span class="line">                case ID_FILE_OPEN:</span><br><span class="line">                case ID_START_TIMER:</span><br><span class="line">            &#125;</span><br><span class="line">        case WM_LBUTTONDOWN: // 鼠标左键按下消息</span><br><span class="line">            IParam</span><br><span class="line">        case WM_PAINT: // 窗口刷新消息</span><br><span class="line">        case WM_TIMER: // 定时器消息</span><br><span class="line">        case WM_CLOSE: // 请求关闭窗口消息</span><br><span class="line">            DestoryWindow(hWnd); // 撤销窗口</span><br><span class="line">            break;</span><br><span class="line">        case WM_DESTROY: // 窗口被关闭消息</span><br><span class="line">            PostQuitMessage(0);</span><br><span class="line">            break;</span><br><span class="line">        defalut:</span><br><span class="line">            return DefWindowProc();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息处理函数中还可以生成新的消息，方式有两种: - PostMessage
消息放入消息队列 - SendMessage 直接调用消息处理函数 他们的参数为: HWND
hWnd, UINT Msg, WPARAM wParam, LPARAM lParam. 消息参数1和2 &gt;
hWnd接收消息的窗口标识，应该是把窗口进行了分类的感觉吧。Msg实际也是将消息标识进行了分类</p>
<p>消息处理函数应是可再入的
由于消息处理在处理一条消息时可能会主动产生一些新消息，这些消息并不放入消息队列，而是直接调用消息处理函数来处理这些消息，遮掩，就有可能导致小夏处理函数的一次执行还未结束，另一次执行就开始的现象，这可能会引起数据的不一致错误。
&gt;
这里消息的概念是平行的，假设每个消息可能对实际的函数产生不一样的结果。</p>
<p>因此，消息处理函数应该是一个可重入函数，即函数调用者要自带工作区（数据空间）：
- 函数需要的数据需要通过参数来传递 - 函数不能有static存储类的局部变量 -
在函数中访问全局变量也可能导致函数不可再入 &gt;
实话说，不懂什么意思，函数需要自己调用吗？还是怎么的？</p>
<p>资源 每个Windows应用程序，除了程序代码外，还包含一些资源描述：
菜单：菜单ID, 菜单项ID/显示文字 对话框:对话框类型，尺寸与位置</p>
<p>资源描述有规定的格式，存储在相应的资源文件(.rc)中，经编译后将作为Windows应用程序的一部分被链接到应用程序的目标文件中。
资源可以用VC++的资源管理器来进行可视化编辑。 &gt;
这里的资源也就对应着C++的内容</p>
<h3
id="面向对象的windows应用程序设计">面向对象的Windows应用程序设计</h3>
<p>基于Windows API的程序设计是一种基于过程抽象的程序设计范式。
通过调用API函数编写程序的粒度太细、太繁琐，开发效率不高。
如何以更大粒度的程序元素（如对象）来开发Windows应用程序？ -
Microsoft的MFC类库提供了以面向对象范式进行应用程序开发的支持。</p>
<p>窗口对象 - 显示程序的处理数据 - 处理Windows的消息、实现与用户的交互 -
窗口对象之间可以存在聚集关系</p>
<p>文档对象 - 管理在各个窗口中显示和处理的数据 -
文档对象与窗口对象之间可以存在着一对多的关系</p>
<p>应用程序对象 - 管理属于它的窗口对象和文档对象 - 实现消息循环 -
与他的窗口对象及文档对象之间构成 聚集关系。</p>
<blockquote>
<p>聚集关系实际上就是指窗口之间的互相联系。
理解：窗口对象主要是显示程序，窗口对象之间可以互相存在关系；文档对象即主要指的是每个窗口中的数据，可以考虑窗口中的数据。
窗口就是数据的显示层，而文档就是指的具体数据。应用程序对象就是main函数的感觉。</p>
</blockquote>
<p>对Windows应用，应用程序对象和主窗口对象只有一个，子窗口对象和文档对象则可以有多个，它们在程序运行的不同时刻创建。</p>
<p>例如，对于一个多文档的Windows应用程序 -
在程序开始运行时，首先创建应用程序对象; -
由应用程序对象来创建主窗口对象； -
在程序运行过程中，用户选择主窗口菜单项"文档|打开"，创建一个稳定那个对象以及相应的子窗口对象。
&gt; 也就是说文档对象其实是叶节点的感觉，是最底层的东西。</p>
<p>MFC Microsoft Foundation Class library 微软基础类库</p>
<p>MFC是微软公司提供的支持以面向对象范式进行Windows应用程序开发的一个基础类库
-
MFC提供了一些类来描述应用中对象的基本功能，应用程序可以通过集成这些类来实现各自的特殊功能。
&gt; 在这里，想起qt中，本身有Dialog, Frame等对象，实际上感觉也是如此的。
- MFC还提供了一种基于"文档-视"结构的应用框架。 &gt;
所谓框架需要进行好好理解，所谓框架一般来说是指的在实际问题过程中不断向前发展。一般来说最好了解框架的历史。但是实际上如果一开始接触不到这个信息的话，只有先进行框架的原理和功能，以及如何使用等方面进行先理解。当理解明白后，直接使用。注意！不要迷信框架，最后把如何从很复杂的东西抽象到框架的过程理解明白。当然，第一步肯定是要会用框架。</p>
<p><img data-src="00001.png" /> &gt;
由图可以看出，首先CObject分为了应用的框架Application Architecture,
异常Exceptions, 文件服务File Services, 基本类型Arrays, Lists, Maps,
Internet Services, 以及Graphical Drawing, Control Support, Menus, ODBC
Database Support, DAO Database Support, Synchronization, Windows
Sockets等高级专题。 &gt; 对于Application
Architecture用可以分为CCmdTarget即能处理Windows消息的类，往下派生CWind,分为以下几类，
Frame Windows, Control Bars, Property Sheets以及 Dialog Boxes
以及Views以及Controls等等。 &gt;
还有一部分Class不是从CObject派生的，也就是说不是采用的面向对象范式。
&gt; Internet Server API, Run-time Object Model Support, Structures,
Support Classes, Typed Template Collections, OLE Type Wrappers, OLE
Automation Typesm Synchronization.</p>
<p><img data-src="00002.png" /> &gt;
可以看出CCmdTarget被分为了好几类，CWinThread, CWinApp 线程的，
CDocument文档的， CDocTemplate文档类型的。 <img data-src="00003.png" /></p>
<h4 id="mfc提供的主要类">MFC提供的主要类</h4>
<ul>
<li>窗口类
<ul>
<li>基本窗口类CWnd
<ul>
<li>实现窗口的基本功能: &gt;
一般的消息处理、窗口大小和位置管理、菜单管理、坐标系管理、滚动条管理、剪切板管理、窗口状态管理、窗口间位置关系管理，等等
&gt; 是其他窗口类的基类</li>
</ul></li>
<li>框架窗口类
<ul>
<li>提供对标题栏、菜单栏、工具栏、状态栏以及属于它的子窗口的管理功能。</li>
<li>CFrameWnd: 提供了单文档应用主窗口的基本功能</li>
<li>CMDIFrameWnd: 提供了多文档应用主窗口的基本功能</li>
<li>CMDIChildWnd: 提供了多文档应用子窗口的基本功能 &gt;
一个窗口中有多个CView,CMDIChildWnd和CMDIFrameWnd一定对应吗？</li>
</ul></li>
<li>视类CView
<ul>
<li>实现程序数据的显示功能以及操作数据时与用户的交互功能</li>
<li>视窗口位于单文档应用主窗口CFrameWnd和多文档应用子窗口CMDIChildWnd的客户区（可显示区）</li>
</ul></li>
<li>对话框类CDialog
<ul>
<li>对话框是一种特殊的窗口，用于获取用户的输入信息。</li>
<li>每个对话框都包含了一些对话框控件（如：按钮、列表框、单选/多选框等），这些控件属于对话框对象的成员对象。</li>
<li>CDialog类封装了对话框的基本功能，它构成了所有对话框的基类。</li>
</ul></li>
</ul></li>
<li>文档类CDocument
<ul>
<li>对程序要处理的数据进行管理，包括磁盘文件I/O.</li>
<li>一个CDocument类的对象至少要对应一个CView类的对象 &gt;
这里也就是所谓的数据-展示的感觉 &gt;
刚刚最开始自己的感觉就是应该是数据与文档对应</li>
</ul></li>
<li>应用框架类 &gt; 这里是怎么组织的，真让人好奇
<ul>
<li>文档模板类
<ul>
<li>实现对文档、视窗口和框架窗口所构成的对象组的管理功能。（用于支持基于“文档=视”结构的应用框架）</li>
<li>CDocTemplate: 文档模板的基类 &gt; CView+CDocument</li>
<li>CSingleDocTemplate: 单文档模板基类</li>
<li>CMultiDocTemplate: 多文档模板类 &gt;
这里跟自己的理解是一样的吗？它的意思是这里进行管理的功能？</li>
</ul></li>
<li>应用类CWinApp
<ul>
<li>提供了对Windows应用程序的各部分进行组合和管理的功能，其中包括对主窗口和文档模板的管理以及实现消息循环等、
&gt;
换言之，应用类调用文档模板类，实现消息循环。文档模板类实现对文档、视窗口、框架窗口所构成的对象组的管理。文档即数据，视窗口即文档的数据，框架窗口即整个菜单栏，状态栏以及其他的等等</li>
</ul></li>
</ul></li>
</ul>
<p><img data-src="00004.png" /> - 绘图类 - 绘图环境类CDC -
实现Windows应用程序中的绘图功能：文本以及几何图形（线、矩形、椭圆等）的输出
- 要关联一个窗口以及一些绘图工具 - 绘图工具类CPen, CFont, CBrush -
实现笔、字体、刷子等绘图所需的绘图元素。 - 文件输入 -
CFile类：实现了基于字节流的文件I/O -
CArchive类：通过重载操作符&lt;<和>&gt;实现了对基本数据类型和MFC类对象的文件I/O.
- 常用数据类型 -
CPoint点坐标，CRect矩形信息，CSize矩形的宽度/高度，点之间的偏移量等 -
字符串类CString</p>
<h4 id="文档-视结构">文档-视结构</h4>
<ul>
<li>文档
<ul>
<li>用于存储和管理程序中的数据。</li>
</ul></li>
<li>视
<ul>
<li>显示文档数据以及实现对文档数据进行操作时与用户的交互功能</li>
</ul></li>
<li>文档与视一起可以实现：
<ul>
<li>数据的内部存储形式和数据的外部表现形式相互独立</li>
<li>一个文档对象对应一个或多个视对象，即，对于同一个文档数据可以用不同的方式进行显示和操作</li>
</ul></li>
</ul>
<p>MFC提供了一个基于“文档-视”结构的应用框架，主要由以下类构成： - CView
- CDocument - CFrameWnd - CDocTemplate - CWinApp
应用框架规定了各个组成部分之间的关系，它带来的好处是简化了程序的控制流程设计。</p>
<p>基于“文档-视”结构的多文档应用框架的控制逻辑 -
首先创建一个CWinApp类的应用对象，然后 -
调用CWinApp类的成员函数InitInstance类对应用对象进行初始化： -
创建一个CMultiDocTemplate类的文档模板对象，并调用CWinApp类的成员函数AddDocTemplate把它加入到应用对象中。
-
创建一个CMDIFramWnd类的主框架窗口对象，并记录在应用对象的数据成员m_pMainWnd中。
- 调用CWinApp类的成员函数Run,进入消息循环。 &gt; 也就是说CWinApp-&gt;
InitInstance;
类文档模板对象，主框架窗口对象。然后容纳其他的。最后就是进行消息循环，其实也是Run的一个封装。
- 用户选择菜单项"文件|打开"后，调用CWinApp类的成员函数OnFileOpen: -
显示打开文件对话框，让用户选择要打开的文件 -
根据文档模板创建三个对象：文档CDoument,子框架窗口CMDIChildWnd和视CView,
并建立起他们之间的关联。 -
调用CDocument对象的成员函数OnOpenDocument从磁盘文件读取数据: -
创建一个CArchive类的对象。 -
以CArchive类的对象作为参数调用CDocument的成员函数Serialize从磁盘读入数据并存放在文档对象中。
-
调用对应CView对象的成员函数OnInitialUpdate通知相应的视进行数据显示，这时，CView类的成员函数OnUpdate将会被调用，它会向CView对象发送WM_PAINT消息
- CView对象收到WM_PAINT消息后将调用CView的成员函数OnDraw显示文档的数据
&gt;
这里他们三者之间的联系未说明白。首先，前面已经说到了管理的是消息队列。现在就是当面对具体的消息(事件)时的动作，此时是如果选择文件/打开后，首先会建立CDoucent,
CView, CMDIChildren.
然后，在想这里的子框架的作用是否是打开不断的目录。其次，这里的CView类的成员函数发送WM_PAINT，应该会等待CDocument的一个消息后才会启动OnDraw吧，感觉上是这样的
- CView对象(视)与CDocument对象(文档)之间的交互 -
通过CView对象的成员函数GetDocument可获得相应的文档对象 -
通过CDocument对象的成员函数GetFirstViewPosition和GetNextView可获得相应
的视(可以有多个) -
修改文档数据后，可以通过CDocument对象的成员函数SetModifiedFlag设置修改标记为true,并调用CDocument对象的成员函数UpdateAllViews通知相应的视刷新显示
- 这时，CView对象的成员函数OnUpdate和OnDraw将会被调用。 &gt; 理解：
等于那个动作会调度CView，CView然后是CDocument的父亲，通过这些就可以显示函数。
- 用户选择菜单项“文件|保存” -
调用CDocument对象的成员函数OnSaveDoucument把文档数据保存到磁盘中： -
创建一个CArchive类的对象 -
以CArchive类的对象作为参数调用CDocument对象的成员函数Serialize把文档中的数据写入磁盘
- 调用CDocument对象的成员函数SetModifiedFlag设置修改标记为false. -
用户选择菜单项“文件|关闭” - 调用CDocument对象的成员函数OnFileClose; -
调用CDocument对象的成员函数IsModified判断文档是否被修改，如果被修改，提示用户保存数据，然后按菜单项"文件|保存"处理
- 调用CDocument对象的成员函数OnCloseDocument撤销相应的视和子框架窗口 -
撤销文档对象 - 用户选择菜单项“文件|退出”或关闭主窗口： -
向应用的主窗口（CMDIFrameWnd类的框架窗口）发送一条WM_CLOSE消息。 -
主窗口收到WM_CLOSE: - 关闭所打开的文档（包括相应的视和子框架窗口） -
撤销主窗口 - 向应用发送一条WM_QUIT消息 -
在CWinApp类的成员函数Run的消息循环中收到WM_QUIT消息后， - 退出消息循环 -
调用CWinApp对象的成员函数ExitInstance做程序退出前的一些处理。</p>
<p>CView <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- CDocument *m_pDocument;</span><br><span class="line">// 存储对应文档对象的指针</span><br><span class="line">- CDocument *GetDocument() const;</span><br><span class="line">// 获得对应的文档对象</span><br><span class="line">- virtual void onDraw(CDC *pDC)=0;</span><br><span class="line">// 处理窗口刷新消息:WM_PAINT;</span><br><span class="line">- virtual void onInitialUpdate();</span><br><span class="line">// 视对象创建时被调用</span><br><span class="line">- virtual void OnUpdate(CView *pSender, LPARAM IHint, CObject* pHint);</span><br><span class="line">// 文档对象的数据发生改变时调用该函数刷新相应的视对象。默认处理: 发送WM_PAINT消息。</span><br></pre></td></tr></table></figure> &gt; 不亏为抽象类的感觉</p>
<ul>
<li>CDocument <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- void AddView(CView *pView);</span><br><span class="line">// 给文档对象增加一个关联的CView类的对象，双向注册的感觉？.  通过参数的形式组合，倒也很正常。 不过是有GetDocument来调用它</span><br><span class="line">- void RemoveView(CView *pView);</span><br><span class="line">// 使一个CView类的对象脱离于文档对象的关联</span><br><span class="line">- virtual POSITION GetFirstViewPosition() const;</span><br><span class="line">// 获取关联的第一个CView对象的位置</span><br><span class="line">- virtual CView* GetNextView(POSITION&amp; rPosition) const;</span><br><span class="line">// 获取指定位置的CView对象，rPosition自动往后移动一个位置</span><br><span class="line">- void UpdateAllViews(CView* pSender, LPARAM IHint=0L, CObject* pHint=NULL);</span><br><span class="line">// 向关联的CView对象发送刷新消息。当pSender为NULL时，向关联的所有CView对象发送刷新消息。</span><br><span class="line">&gt; 怎么实现刷新？首先思考，这个刷新肯定是由某个动作触发的，那么把它加在其余的后面就可以了呗。对！</span><br><span class="line"></span><br><span class="line">void SetModifiedFlag(BOOL bModified=TRUE);</span><br><span class="line">设置文档修改标记。</span><br><span class="line">BOOL IsModified( );</span><br><span class="line">判断文档是否被修改。</span><br><span class="line">virtual BOOL OnSaveDocument(LPCTSTR 							lpszPathName ); </span><br><span class="line">把文档中数据保存到文件名为lpszPathName 的文件中去。</span><br><span class="line">virtual BOOL OnOpenDocument(LPCTSTR 							lpszPathName );</span><br><span class="line">从文件名为lpszPathName 的文件中读取文档数据。</span><br><span class="line">virtual BOOL OnNewDocument( );</span><br><span class="line">对文档数据进行初始化。</span><br><span class="line">virtual void OnCloseDocument( ); </span><br><span class="line">关闭文档。</span><br><span class="line">virtual void Serialize( CArchive&amp; ar ); </span><br><span class="line">用于文档数据的序列化（写入磁盘文件或从磁盘文件读出）。</span><br><span class="line">一般由OnSaveDocument和OnOpenDocument来调用</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CArchive档案类</span><br><span class="line">// 实现对基本数据类型和从CObject继承的对象的文件输入/输出操作</span><br><span class="line">CArchive重载了操作符&lt;&lt;和&gt;&gt;</span><br><span class="line">IsLoading();  // 输入</span><br><span class="line">IsStoring();  // 输出</span><br></pre></td></tr></table></figure>
<p>CDocTemplate文档模板类 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CDocTemplate类的构造函数（其参数为文档、视以及框架窗口的类信息）：</span><br><span class="line">CDocTemplate(UINT nIDResource,</span><br><span class="line">	  	CRuntimeClass* pDocClass, </span><br><span class="line"> 		CRuntimeClass* pFrameClass, </span><br><span class="line">	       CRuntimeClass* pViewClass );</span><br></pre></td></tr></table></figure></p>
<p>CWinApp <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">virtual BOOL InitInstance(); </span><br><span class="line">应用程序初始化，包括注册窗口类、创建/显示主窗口等。它由WinMain调用。</span><br><span class="line">virtual int Run();</span><br><span class="line">实现消息循环。它由WinMain调用</span><br><span class="line">virtual int ExitInstance();</span><br><span class="line">应用程序结束处理，由Run调用。</span><br><span class="line">virtual CWnd *GetMainWnd( ); </span><br><span class="line">获得主窗口对象指针。</span><br><span class="line">void AddDocTemplate(CDocTemplate* Template );</span><br><span class="line">把一个文档模板加入到CWinApp类的对象中</span><br><span class="line">afx_msg void OnFileNew( );</span><br><span class="line">提供对“File|New”菜单消息的处理功能。</span><br><span class="line">afx_msg void OnFileOpen( );</span><br><span class="line">提供对“File|Open”菜单消息的处理功能。</span><br></pre></td></tr></table></figure></p>
<p>Application Wizard应用向导 -
要在程序中建立应用框架中各对象的创建和操作代码将是一件很麻烦的工作。
VC++提供了一个应用向导，基于MFC的多文档应用程序，会自动建立5个雷，并分别为这些类写了一些必要的代码:
CMyApp CMainFrame CChildFrame CMyView CMyDoc
在应用向导建立的应用程序中有一个CMyApp类的全局对象theApp,它将在WinMain执行之前创建。
为了体现"纯"面向对象特性，在应用向导建立的应用程序中隐藏了主函数WinMain.
在隐藏的WinMain中， -
首先调用theApp的成员函数InitInstance对应用程序进行初始化 -
然后去调用theApp的成员函数Run进入消息循环
消息循环结束之后，将会调用theApp的成员函数ExitInstance进行程序结束前的一些处理。
在应用向导建立的应用程序中对消息处理函数进行了结构化处理: -
通过消息映射机制把Windows消息与相应类的成员函数关联起来 -
各个消息的处理分别由相应类的一个成员函数来实现。</p>
<p>类向导 为应用程序中从MFC派生的类增加/删除成员 -
消息处理成员函数（菜单、窗口、键盘、鼠标） - 基类中可重定义的成员函数 -
新定义数据成员（成员变量） - 对话框类与各个“控件”所对应的数据成员
为应用程序增加/删除基于MFC的类</p>
<h4 id="图形用户接口设计gui">图形用户接口设计GUI</h4>
<ul>
<li>菜单</li>
<li>对话框</li>
<li>绘图</li>
<li>坐标变换</li>
</ul>
<h5 id="菜单">菜单</h5>
<p>菜单是执行程序功能的一种手段。 -
一个程序可以有多个菜单，每个菜单都有一个标识。 -
菜单有菜单项构成，每个菜单项包含： - 标识 - 显示文字和提示文字 -
处理函数 - 菜单的外观设计可以用资源编辑器来完成 -
菜单处理函数可以用类向导来添加。 ##### 对话框
对话框是一种窗口，它是Windows应用程序与用户进行交互的一种重要手段。
每个对话框都包含了一些对话框控件（如：按钮、编辑、列表、组合等），这些控件属于对话框对象的成员对象（子窗口）
&gt; 子窗口这个概念原来等效于成员对象啊？
一个对话框往往需要对应一个对话框模板 - 每个对话框模板都有一个标识 -
对话框模板描述了对话框的组成，包括：对话框的标识和尺寸；对话框中各个控件的标识、类型、尺寸与位置等
- 对话框模板可用资源编辑器来设计 &gt;
哪些东西是可以机器化的呢？比如说，这里利用机器，UI来设计，其实就是应用了这里的东西的感觉。其实莫过于最奇妙的东西就是，消息的发送和传递。谁是参数？在注册的时候需要些什么东西？</p>
<p>每个对话框都对应着一个对话框类，它可以用类向导来管理： -
为对话框控件指定消息处理函数 - 为对话框指定成员变量</p>
<p>CDialog对话框类
程序中需要打开对话框时，首先要创建一个对话框类的对象，然后调用该类的成员函数DoMadal.如:
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CMyDlg dlg; // 创建一个对话框类的对象dlg.</span><br><span class="line">dlg.m_...=...; //通过dlg的成员变量设置对话框中各控制的初试内容。</span><br><span class="line">...</span><br><span class="line">if((dlg.DoModal()==IDOK)) // 显示对话框，返回值可以为IDOK何IDCANCEL &#123;</span><br><span class="line">    ... = dlg.m_...; // 取对话框控制中的内容。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 公共的对话框类 - CFileDialog: 文件打开/保存对话框 -
CFontDialog: 字体选择对话框 - CColorDialog: 颜色选择对话框 -
CPrintDialog: 打印设置对话框 - CFindReplaceDialog: 查找/替换对话框</p>
<h5 id="绘图--cdc类">绘图--CDC类</h5>
<p>设备环境类CDC用于实现Windows应用程序中的绘图功能。
进行绘图时，首先要创建一个CDC类或其派生类的对象，该对象将包含绘图时所需要的各种元素，包括:
- 绘图函数，如：输出文字、画线、画矩形、画椭圆等 -
绘图工具，如：字体、颜色、笔、刷子等
在创建CDC类或其派生类的对象时需要指出它所对应的窗口对象，绘图操作将在相应窗口中进行。
应用框架在调用CView的OnDraw成员函数时，会自动创建一个CDC类的对象，作为参数传给OnDraw.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">文本输出函数 </span><br><span class="line">virtual BOOL TextOut(int x,int y,LPCTSTR lpszString,int nCount);</span><br><span class="line">BOOL TextOut(int x,int y,const CString&amp; str);</span><br><span class="line">virtual int DrawText(LPCTSTR lpszString,int nCount,LPRECT lpRect,UINT nFormat );</span><br><span class="line">int DrawText(const CString&amp; str,LPRECT lpRect,UINT nFormat);</span><br><span class="line">设置字符和背景颜色</span><br><span class="line">virtual COLORREF SetTextColor( COLORREF crColor ); </span><br><span class="line">virtual COLORREF SetBkColor( COLORREF crColor ); </span><br><span class="line">COLORREF类型的值可以用宏“RGB(red,green,blue)”来表示，例如，RGB(255,0,0)表示红色；RGB(0,255,0)表示绿色； RGB(255,255,255)表示白色。</span><br><span class="line"></span><br><span class="line">几何图形输出函数</span><br><span class="line">画线段</span><br><span class="line">//定线段的起点坐标</span><br><span class="line">CPoint MoveTo( int x, int y );</span><br><span class="line">CPoint MoveTo( POINT point );</span><br><span class="line">//从起点坐标开始画线直到指定的终点坐标</span><br><span class="line">BOOL LineTo( POINT point );</span><br><span class="line">BOOL LineTo( int x, int y );</span><br><span class="line"></span><br><span class="line">画矩形。</span><br><span class="line">BOOL Rectangle( int x1, int y1, int x2, int y2 );</span><br><span class="line">BOOL Rectangle( LPCRECT lpRect );</span><br><span class="line"></span><br><span class="line">画椭圆，参数为外接矩形。</span><br><span class="line">BOOL Ellipse( int x1, int y1, int x2, int y2 );</span><br><span class="line">BOOL Ellipse( LPCRECT lpRect ); </span><br><span class="line"></span><br><span class="line">选择绘图工具函数</span><br><span class="line">选择系统提供的绘图工具</span><br><span class="line">virtual CGdiObject* SelectStockObject(int nIndex); </span><br><span class="line">选择自定义的笔。返回CDC中原来的笔的指针。</span><br><span class="line">CPen* SelectObject( CPen* pPen ); </span><br><span class="line">选择自定义的刷子。返回CDC中原来的刷子的指针。</span><br><span class="line">CBrush* SelectObject( CBrush* pBrush ); </span><br><span class="line">选择自定义的字体，返回CDC中原来的字体的指针。</span><br><span class="line">virtual CFont* SelectObject( CFont* pFont );</span><br><span class="line">注意：用完绘图工具之后，要把绘图工具从CDC类的对象中选出来，以免CDC类对象消亡时重复撤销它包含的绘图工具！ </span><br></pre></td></tr></table></figure>
<p>绘图工具 - 画笔（用于画线） - 构造函数的参数为笔型、笔宽以及颜色
<code>CPen(int nPenStyle, int nWidth, COLORREF crColor);</code> -
刷子（用于填充封闭图形） - 构造函数的参数为刷子的颜色
<code>CBrush(COLORREF crColor);</code> - 字体 -
先创建一个默认构造的CFont类的对象，然后调用该类的CreatePointFont成员函数完成字体的构造
<code>CFont();</code> <code>bool CFont::CreatePointFont(int nPointSize,
LPCTSTR lpszFaceName, CDC* pDC=NULL);</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void CMyView::OnDraw(CDC* pDC)</span><br><span class="line">&#123;	COLORREF old_text_color=pDC-&gt;SetTextColor(RGB(255,0,0)); 					//把字符颜色设置成“红”色。</span><br><span class="line">	COLORREF old_bk_color=pDC-&gt;SetBkColor(RGB(0,255,0)); 					//把字符背景颜色设置成“绿”色。</span><br><span class="line">	pDC-&gt;TextOut(0,0,&quot;hello&quot;); //在位置(0,0)处显示字符串&quot;hello&quot;</span><br><span class="line">	CPen pen(PS_SOLID,2,RGB(0,255,0)),*old_pen; //创建一个绿色的实线笔</span><br><span class="line">    old_pen = pDC-&gt;SelectObject(&amp;pen); //把新笔选进CDC类的对象中</span><br><span class="line">	CBrush brush(RGB(0,0,255)),*old_brush; //创建一个蓝色的刷子</span><br><span class="line">	old_brush = pDC-&gt;SelectObject(&amp;brush); //把新刷子选进CDC类的对象中</span><br><span class="line">    pDC-&gt;MoveTo(0,0); pDC-&gt;LineTo(200,200); //画一个绿色的线段</span><br><span class="line">	pDC-&gt;Rectangle(0,50,100,150); //画一个内部为蓝色、边为绿色的矩形</span><br><span class="line">	pDC-&gt;SelectObject(old_pen); //把原来的笔选回到CDC类的对象中</span><br><span class="line">	pDC-&gt;SelectObject(old_brush); //把原来的刷子选回到CDC类的对象中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CStudentsView::OnDraw(CDC* pDC)</span><br><span class="line">&#123; CStudentsDoc* pDoc = GetDocument();</span><br><span class="line">   CFont *old_font=(CFont *)pDC-&gt;SelectStockObject(ANSI_FIXED_FONT);</span><br><span class="line">   for (int i=0,num=pDoc-&gt;get_num_of_students(); i &lt; num; i++)</span><br><span class="line">  &#123; STUDENT_TYPE st;</span><br><span class="line">    pDoc-&gt;get_student(i,st);</span><br><span class="line">    CString temp;</span><br><span class="line">    temp.Format(&quot;%-10.10s%-10.10s%-4.4s%-10.10s%-20.20s%-40.40s&quot;,</span><br><span class="line">                st.number,st.name,st.sex,st.birthdate,st.birthplace,st.address);</span><br><span class="line">    if (i != current_student)</span><br><span class="line">    &#123; pDC-&gt;SetTextColor(RGB(0,0,0));</span><br><span class="line">       pDC-&gt;SetBkColor(RGB(255,255,255));</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123; pDC-&gt;SetBkColor(RGB(0,0,0));</span><br><span class="line">       pDC-&gt;SetTextColor(RGB(255,255,255));</span><br><span class="line">    &#125;</span><br><span class="line">    pDC-&gt;TextOut(0,i*20,temp);</span><br><span class="line">  &#125;</span><br><span class="line">  pDC-&gt;SelectObject(old_font);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CView的一些派生类 - CScrollView(带滚动功能的视) -
CEditView(具有编辑功能的视) - CFormView(具有表格功能的视) -
CHtmlView(具有Web浏览功能的视)</p>
<h5 id="坐标转换">坐标转换</h5>
<p>CScrollView <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">void CScrollView::SetScrollSizes( </span><br><span class="line">  		int nMapMode, </span><br><span class="line">  		SIZE sizeTotal, </span><br><span class="line">  		const SIZE&amp; sizePage = sizeDefault, </span><br><span class="line">  		const SIZE&amp; sizeLine = sizeDefault );</span><br><span class="line">nMapMode：映射方式（坐标的逻辑单位，坐标轴方向）</span><br><span class="line">例如：MM_TEXT（逻辑单位为像素点，坐标原点位于左上角，x轴从左向右，y轴从上往下。</span><br><span class="line">sizeTotal：文档内容的大小</span><br><span class="line">sizePage：文档滚动页的大小</span><br><span class="line">sizeLine：文档滚动行的大小</span><br><span class="line">需要在CScrollView的OnUpdate和OnSize中调用。</span><br><span class="line"></span><br><span class="line">void CStudentsView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) </span><br><span class="line">&#123; // TODO: Add your specialized code here and/or call the base class</span><br><span class="line">  CStudentsDoc* pDoc = GetDocument();</span><br><span class="line">  </span><br><span class="line">  // TODO: calculate the total size of this view</span><br><span class="line">  CSize sizeTotal,sizePage,sizeLine;   </span><br><span class="line">  sizeTotal.cx = 100; //文本宽度固定</span><br><span class="line">  sizeTotal.cy = pDoc-&gt;get_num_of_students()*20; //文本长度</span><br><span class="line">  RECT rect;</span><br><span class="line">  GetClientRect(&amp;rect); //获取视窗口的大小</span><br><span class="line">  sizePage.cx = rect.right-rect.left-8; //页宽度</span><br><span class="line">  sizePage.cy = rect.bottom-rect.top-20; //页长度</span><br><span class="line">  sizeLine.cx = 8; //行宽度</span><br><span class="line">  sizeLine.cy = 20; //行高度</span><br><span class="line"></span><br><span class="line">  SetScrollSizes(MM_TEXT,sizeTotal,sizePage,sizeLine);</span><br><span class="line"></span><br><span class="line">  Invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CStudentsView::OnSize(UINT nType, int cx, int cy) </span><br><span class="line">&#123; CScrollView::OnSize(nType, cx, cy);</span><br><span class="line">	</span><br><span class="line">  // TODO: Add your message handler code here</span><br><span class="line">  CStudentsDoc* pDoc = GetDocument();</span><br><span class="line">  </span><br><span class="line"> // TODO: calculate the total size of this view</span><br><span class="line">  CSize sizeTotal, sizePage, sizeLine; </span><br><span class="line">  sizeTotal.cx = 100;</span><br><span class="line">  sizeTotal.cy = pDoc-&gt;get_num_of_students()*20;</span><br><span class="line">  sizePage.cx = cx-8;</span><br><span class="line">  sizePage.cy = cy-20;</span><br><span class="line">  sizeLine.cx = 8;</span><br><span class="line">  sizeLine.cy = 20;</span><br><span class="line">  </span><br><span class="line">  SetScrollSizes(MM_TEXT,sizeTotal,sizePage,sizeLine);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img data-src="00005.png" /> 坐标转换函数
OnPrepareDC(&amp;dc,NULL); 为ScrollView初始化dc dc.DPtoLP(&amp;point);
从物理坐标转换到逻辑坐标 dc.LPtoDP(&amp;point);
从逻辑坐标转换到物理坐标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void CStudentsView::OnLButtonDown(UINT nFlags,</span><br><span class="line">                                                       CPoint point) </span><br><span class="line">&#123;</span><br><span class="line">  // TODO: Add your message handler code here </span><br><span class="line">  // and/or call default</span><br><span class="line">  </span><br><span class="line">  CClientDC dc(this);</span><br><span class="line">  OnPrepareDC(&amp;dc,NULL); //transform dc to   </span><br><span class="line">                                        //scrollview</span><br><span class="line">  dc.DPtoLP(&amp;point); // 物理坐标转逻辑坐标</span><br><span class="line"></span><br><span class="line">  current_student = point.y/20;   </span><br><span class="line"> </span><br><span class="line">  Invalidate(); //重新显示视窗口内容，OnDraw将被调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="一点反思">一点反思</h3>
<p>学习的几个过程 1.
首先，如果课件足够好，也可以不用记笔记，这样的效率高，但是能够记住吗？但是感觉上最有用的可能就是反思吧？也就是说并不意味着一定要记很多笔记。
记住，衡量的标准一直是上课预估后面不会做的易错点，还有精华的地方自己是否掌握了，这才是最重要的。</p>
<p>按照以前的学习态度，如果是自己在乎的知识。
首先，第一次一定要要么有好的课本，或者材料特别好。
看书，并且记自己不懂的地方。
第一次看书下来，主要讲什么的大体的脉络要清晰。</p>
<p>然后还要衡量所花的时间等诸多因素。</p>
<p>然后，再将笔记进一步总结。练过所有需要练习的局部知识点，然后开始自己。
学习知识点还有几遍，然后就是大量地做题，直到做到彻底掌握这个知识点为止。
最后，如果时间充裕再看其他知识点进行迁移，弄明白整个过程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/nju-course-cplus-lecture5-summary-e0699417912f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/nju-course-cplus-lecture5-summary-e0699417912f/" class="post-title-link" itemprop="url">nju-course-cplus-lecture5-summary</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:54:53" itemprop="dateCreated datePublished" datetime="2019-09-19T09:54:53+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">course</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/" itemprop="url" rel="index"><span itemprop="name">nju</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/cplus/" itemprop="url" rel="index"><span itemprop="name">cplus</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>总结</p>
<h1 id="输入输出">输入输出</h1>
<p>按输入输出的类型分为三种：控制台、文件、字符串（局部的内存区域） 1.
控制台 - C - 输出 &gt; putchar(), puts(), printf() %d,c,u,f - 输入 &gt;
getchar(), gets(), scanf() - C++ cin, cout, cerr直接, clog iomanip:
setw()? setiosflags(scientific, flags) setprecision cout.write();
cin.get(), cin.read(); cin.fail() // 是否输入成功，0表示成功 &gt;
一般地，对输出不需要判断文件结束，输入需要判断文件结束 - 操作符的重载：
继承的问题， display()</p>
<ol start="2" type="1">
<li>文件 永久保存数据的设备 文本(字符串)，二进制文件(机器表示)</li>
</ol>
<ul>
<li>C
<ul>
<li>输出 fopen(), fputc(), fputs(), fprintf(),size_t fwrite(sizeof())
//字节，二进制, fclose() &gt; 目录问题，路径写法。 打开方式: w创建,清除,
a尾 b; 不同操作系统，windows -&gt;</li>
<li>输入 fopen() NULL失败， &gt; r, b, fgetc(), fgets(), fscanf(),
fread(sizeof()). feof()判断是否到的文件的末尾</li>
<li>r+, w+, a+, b</li>
<li>fseek(), ftell, cur,end,set</li>
</ul></li>
<li>C++ 输出 out_file(), open, write, &lt;&lt; 输入 in_file(),read,
eof</li>
</ul>
<ol start="3" type="1">
<li><p>字符串 char buf[100]; ostrstream str_buf(buf,100);</p></li>
<li><p>其他 traits</p></li>
</ol>
<blockquote>
<p>思考，为什么独独设置了这三类？</p>
</blockquote>
<h1 id="异常处理">异常处理</h1>
<p>所谓异常，其实就是程序过程中出现的bug。其实主要可以分为以下几种。 1.
语法错误， 编译器会解决 2. 逻辑错误，很关键，要学会排错 -
不能运行，实现的逻辑有问题 - 能运行，有问题 - 输出错误 - 程序逻辑错误 -
有的函数的输入输出没有检查 - 编译出错 - 平台相关 3. 运行异常 -
程序对运行环境考虑不周 &gt; 这里很重要，务必注意程序的环境</p>
<p>鲁棒性，就是能应对足够多的异常。</p>
<p>处理异常的方法： 直接，当地抛出异常，即exit();
最大的问题可能就是当程序特别大的时候，程序员不知道什么地方出错了。</p>
<p>异地处理：参数值，新建参数值，全局变量，这些都不好。</p>
<p>推出抽象化，实际上也是通过全局变量来做的，不过交给了底层。上层可以用最简单的语句进行实现。</p>
<p>try{ 检测语句； }catch(类型 变量)</p>
<p>throw{} 一旦进行检测必然抛出，很优秀。
而且只抛出子层的，向上处理。没有就控制台。</p>
<p>上面是无法避免的可能出现的运行异常的处理。</p>
<p>只要不可控都要进行上面的处理。</p>
<p>下面聊到代码调试，如何测试bug</p>
<p>一般的怎么做就分析输出语句呗，看输出语句是否正确。 一种抽象assert();
易于定义位置。 以及可以一键清除。 ``<code>#define NDEBUG
#include&lt;cassert&gt;</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/nju-course-cplus-lecture5-6d947ee08682/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/nju-course-cplus-lecture5-6d947ee08682/" class="post-title-link" itemprop="url">nju-course-cplus-lecture5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:53:37" itemprop="dateCreated datePublished" datetime="2019-09-19T09:53:37+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">course</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/" itemprop="url" rel="index"><span itemprop="name">nju</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/cplus/" itemprop="url" rel="index"><span itemprop="name">cplus</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="重点">重点</h1>
<h2 id="输入输出">9. 输入/输出</h2>
<p>输入、输出具体的实现会音操作系统和计算机硬件的不同而有所不同，与平台相关。
在C++中，一种基于字节流的操作。</p>
<p>分为： 1. 面向控制台的I/O iostream - istream, ostream 2.
面向文件的I/O fstream, ifstream, ofstream 3. 面向字符串变量的I/O
strstream, istrstream, ostrstream</p>
<p>在c++中，ios_base基类，ios派生。 I/O类都是用类模板来实现的</p>
<blockquote>
<p>因为输入输出通常会设计到外设，即经常考虑把程序所需要运行的数据输出到外设和从外设输入。
C++STL中的输入输出被C++编译程序所接受。但是，因为具体平台相关性，还可以采用其他方式进行输入输出。例如：Visual
C++提供的MFC基础类中包含了具有输入、输出功能的类。
但是，指定注意的一点就是以非C++标准库方式进行输入输出不利于C++程序的移植</p>
</blockquote>
<h3 id="面向控制台的io">9.1 面向控制台的I/O</h3>
<h4 id="基于函数库的控制台输入输出">9.1.1
基于函数库的控制台输入、输出</h4>
<p>C语言标准库的功能，C++保留了这些功能 - 输出 putchar(int ch);</p>
<p>int puts(const char *p);</p>
<blockquote>
<p>什么是标准输入平台？这里应该就是控制台输入输出的意思。</p>
</blockquote>
<p>printf() // 返回输出 字符个数或返回负数 注意printf("")这里如果是%s,
不接受空格和回车的，如果需要空格%[0-9a-zA-Z ]这样显式指定。 &gt;
记得字符又被分为了好几种，比如打印字符，什么字符之类。</p>
<ul>
<li>printf常用格式控制字符及其含义</li>
</ul>
<table>
<thead>
<tr class="header">
<th>控制字符</th>
<th>类型</th>
<th>输出格式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>%c</td>
<td>int</td>
<td>字符</td>
</tr>
<tr class="even">
<td>%d</td>
<td>int</td>
<td>有符号十进制整数</td>
</tr>
<tr class="odd">
<td>%u</td>
<td>unsigned int</td>
<td>无符号十进制整数</td>
</tr>
<tr class="even">
<td>%x, %X</td>
<td>unsigned int</td>
<td>无符号16进制</td>
</tr>
<tr class="odd">
<td>%o</td>
<td>unsigned int</td>
<td>无符号8进制</td>
</tr>
<tr class="even">
<td>%s</td>
<td>char*</td>
<td>字符串</td>
</tr>
<tr class="odd">
<td>%e,%E</td>
<td>double</td>
<td>科学计数法的形式</td>
</tr>
<tr class="even">
<td>%f</td>
<td>double</td>
<td>一般形式</td>
</tr>
<tr class="odd">
<td>%%</td>
<td></td>
<td>字符%</td>
</tr>
</tbody>
</table>
<ul>
<li>输入 // 操作失败返回EOF int getchar();</li>
</ul>
<p>// 成功返回p，否则null char <em>gets(char </em>p);</p>
<blockquote>
<p>平台怎么处理空格和回车？是否会纳入考虑 scanf() //
返回实际输入并保存的数据个数或返回EOF %5f,
好像是指定位数来着？？测试</p>
</blockquote>
<h4 id="基于类库的控制台io">9.1.2 基于类库的控制台I/O</h4>
<p>C++的改变，用类来做。
问题：用库函数scanf和printf需要实现基本数据类型数据的输入和输出，实际操作的是格式串。
printf,scanf等于说是多参数，即输入的参数个数时可变的。这样冲某种意义上破坏了C++强类型的特点
&gt; C++强类型有什么特点？ &gt; 从某种意义上是不是有安全的概念？
另外，scanf和printf还有一个特点就是不能对用户自定义，只能操作基础的数据类型
。
而I/O类库提供了更为方便和安全的输入、输出操作，并且这些操作可以很容易地扩充到用户自定义类型的数据。</p>
<h5 id="预定义的控制台对象">1). 预定义的控制台对象</h5>
<p>在I/O类库中预定义了4个I/O对象，cin,cout,cerr以及clog，利用这些对象可以直接进行控制台的输入输出。
cin-&gt;istream. cout,cerr,clog-&gt;ostream
cout敌营这计算机系统的用于输出程序正常运行结果的标准输出设备，而cerr和clog则对应着计算即系统的用于输出程序错误信息的设备，通常都对应着显式器，但是cerr和clog不受输出重定向的影响。
&gt; linux的输出命令的感觉吗？ &gt;
重定向，也就是原本默认的标准输入，从新定义输出到文件。不受是不可操作的意思吗？？？？
并且cerr不对输出信息进行缓存，因此它有较快的响应效果。</p>
<h6 id="输出">输出</h6>
<p>对于指针的输出有一个特例，即输出指向字符串的指针时，不输出字符串的首地址，，而是输出字符串。</p>
<p>进一步，为了对输出格式进行进一步的控制，可以通过输出一些操纵符来实现。
例如： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int x =10;</span><br><span class="line">cout&lt;&lt;hex&lt;&lt;x&lt;&lt;endl; // 以十六进制输出x的值，然后换行。</span><br></pre></td></tr></table></figure> 其中，对于浮点数float,double和long
double,当输出格式为ios::scientific或ios::fixed时，精度设置操纵符setprecision用于设置小数点后的位数。
当什么没有时，用于设置浮点数有效数字的个数。</p>
<p>!!! 只对浮点数有效 &gt; setiosflags(ios::scientific) // 设置输出格式
&gt; resetiosflags(ios::scientific) // 取消输出格式</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>endl</td>
<td>输出换行符，并执行flush操作</td>
</tr>
<tr class="even">
<td>flush</td>
<td>使输出缓存的内容立即输出？？？</td>
</tr>
<tr class="odd">
<td>dec</td>
<td>十进制输出</td>
</tr>
<tr class="even">
<td>oct</td>
<td>八</td>
</tr>
<tr class="odd">
<td>hex</td>
<td>16</td>
</tr>
<tr class="even">
<td>setprecision(int n)</td>
<td>设置浮点数的精度</td>
</tr>
<tr class="odd">
<td>setiosflags(long flage)</td>
<td>设置/取消输出格式，flags的取值可以是:ios:scientific(指数形式),
ios:fixed(小数形式)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意: 设置一遍后均有效，然后应该是就近原则吧！
初始状态下，输出格式为自动方式，输出精度为6位有效数字。</p>
</blockquote>
<blockquote>
<p>很好奇cout是怎么解析&lt;&lt;符的？按照空格回车然后进行分隔吗？还是怎么的？</p>
</blockquote>
<blockquote>
<p>还存在其他类型吗？这样只对double类型进行了处理，一般来说输出应该不需要其他情况的输出了吧，对！
一般只有两种类型，double, str 还有其他需要控制输出的吗？？？</p>
</blockquote>
<blockquote>
<p>突然想起，输出扩展需要的有比如输出的数据对齐指定？待安排 ###### 输入
任何基本数据类型都可以通过cin对象和抽取操作符&gt;&gt;来进行输入。
在输入每个数据之间用空白符分开，最后输入一个回车符。另外也可以用一些操作控制符来控制输入的行为。
对于输入来说，感觉上也就字符串数据需要进行控制了吧，setw()用于指定输入字符的最大个数。</p>
</blockquote>
<blockquote>
<p>对，还需要清空输出吧？感觉上 cin &gt;&gt; setw(10) &gt;&gt; str; //
把输入的前9个字符和一个'\0'放入str中</p>
</blockquote>
<p>!!!!果然不出所料，果然对于输入流来说，当输入流没有用完时是接着用输入流的</p>
<p>get(), getline(*p, cout,delim) read() cin.get(ch); read();</p>
<blockquote>
<p>感觉这些输入地方太容易出错了，我之前就是这里老出错。不要有只取多少位数据的情况。</p>
</blockquote>
<p>特别地，cin的输入操作是无法读入空白符的，这时才可用上面的成员函数实现空白符的读入。
&gt; 所以此时一般扩展用getline</p>
<p>cin的输入操作是带输入缓存的，只有当用户输入“回车”时，输入的数据才会放入程序的变量中。
需要注意的是，基于类库的输入、输出操作中可能遇到问题（如没有正确输入数据等）。
因此，在操作后可通过下面的函数来判断操作是否成功。 bool ios::fail();
//true表示操作失败 怎么用？ &gt;
(cin&gt;&gt;ch2)返回的不是基本类型int,bool &gt; cin.fail()
那什么操作失败呢？ &gt; 比如int, 输入字符串</p>
<h4 id="抽取插入操作符和的重载">9.1.3
抽取、插入操作符&gt;&gt;和&lt;&lt;的重载。</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">    friend ostream&amp; operator &lt;&lt;(ostream&amp; out, const A &amp;a);</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator &lt;&lt;(ostream&amp; out, const A &amp;a)</span><br></pre></td></tr></table></figure>
<p>//
从某种意义上理解，ostream是stream的子类，所以可行。这里是类为啥又可以？</p>
<p>一般来说，只做输出。</p>
<p>有几种方法，如何在继承下使有效？ 1.
如果在基类定义，而没有在派生类定义，派生类只能输出一部分值。 2.
如果在派生类定义，不能解决间接调用的情况
特别是用基类的指针，不知道会动态绑定到哪种情况的时候，考虑使用封装。
即在每个类里面重载display()函数，在&lt;&lt;中只需要调用display()函数即可。</p>
<h3 id="面向文件的输入输出">9.2 面向文件的输入，输出</h3>
<p>程序运行结果有时需要永久地保存起来，以供其他程序或本程序下一次运行时使用:程序运行所需要的数据也常常要从其他程序或本程序上衣词运行所保存的数据中获得。用于永久保存数据的设备称为外部存储器，如磁盘、磁带、光盘等。</p>
<h4 id="文件概述">9.2.1 文件概述</h4>
<p>在外部存储器中保存数据的方式通常由两种：文件和数据库。
本程序设计教程只介绍一文件方式永久性地保存数据，数据库由其他专门的课程介绍。在C++中，把文件看成由一系列字节构成的字节串，称为流式文件，对文件中数据的操作通常是逐个字节顺序进行。在对文件数据进行读写前，首先要打开文件，打开文件的目的是：把程序内部一个表示文件的变量与外部的一个具体文件关系起来，并创建内存缓冲区，每个打开的文件都有一个隐式的读写位置指针，它指向文件的当前读写位置。在进行读写操作时，每读入，写出一个字节，文件位置指针会自动往后移动一个字节的位置。
文件读写完毕后，通常需要关闭文件，其目的是把暂存在内存缓冲区中的内容写入文件，并归还打开文件是申请的内存资源。
在文件中，数据的存储方式有两种，文本方式和二进制方式。
文本方式一般用于存储具有行结构的文字数据，如源程序或纯文本格式的数据等。二进制方式一般用于存储无显式结构的数据，数据的格式由应用程序来解释，如目标代码程序以及二进制数据等。
这两种方式的主要区别是，文本文件中只包含可显示字符和有限的几个控制字符（如,;而二进制文件可以包含任意的没有显式含义的二进制文件。为了进一步区分两种存储方式，我们用一个例子来说明。
对于一个还只能输123457，可以用来种方式保存到文件中： 1.
文本方式：依次把1,2,3,4,5,6,7的ASCII玛写入文件（共7个字节） 2.
二进制方式：把整数123457的计算机内部表示（如补码）分解为字节写入文件（如果整数内部为32位，则为4个字节）。
&gt; 以二进制方式组织的文件不利于文件在不同计算机平台上使用。 &gt;
因为不同计算机平台的内部表示不一样 &gt;
关于文件的压缩的思路估计也有这样的一份。</p>
<h4 id="基于函数库的文件io">9.2.2 基于函数库的文件I/O</h4>
<p>C++从C语言标准库中保留下来的输入、输出函数库包含了对文件进行输入、输出操作的函数。
<code>#include&lt;cstdio&gt;</code> ##### 1) 文件的输出操作 - 打开文件
打开外部文件输出数据fopen <code>FILE *fopen(const char *filename, const
char *mode); // 打开文件</code> mode表示打开方式：
w:打开一个外部文件用于写操作。如果外部文件已经存在，则首先把它的内容清除；否则先创建该外部文件。
a:打开一个外部文件用于添加（从文件末尾）操作。如果不存在，则首先创建文件
另外，在打开方式的后面还可以加上b,指出以二进制方式打开文件。默认打开方式为文本方式。对一文本方式打开的文件，当输出字符为，在某些平台（如DOS和Windows平台）将自动转换为'''两个字符写入外部文件
一般来说，以文本方式组织的文件要用文本方式打开；以二进制方式组织的文件要用二进制方式打开。
以w方式打开文件时，文件位置指针指向文件的头；以a方式打开文件时，文件位置指针指向文件的尾。
文件打开成功后，fopen将返回一个费控的"FILE*"指针，该指针指向与打开文件有关的一些信息（如文件的内存缓冲区等），它将被之后的文件输出操作函数使用。
&gt;
就是实际上内存是按块组织的，这个指针会指向一些节点。当不断输出文件时，需要进行改变指针以扩大文件写的内容，还有更改好多相关的东西。
如果文件打开失败，则fopen返回空指针NULL. - 输出操作</p>
<p>文件打开成功后就可以往文件中写入数据了。往文件中写入数据的函数主要有以下几个。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 输出一个字符，输出成功时返回输出的字符</span><br><span class="line">int fputc(int c, FILE *stream);</span><br><span class="line"></span><br><span class="line">// 输出一个字符串，输出成功时返回一个非负整数。</span><br><span class="line">int fputs(const char *string, FILE*stream);</span><br><span class="line"></span><br><span class="line">// 输出基本类型数据，返回输出的字符数</span><br><span class="line">int fprintf(FILE *stream, const char *format[,argument]...)</span><br><span class="line">// 看来这里我搞错了，</span><br><span class="line"></span><br><span class="line">// 按字节输出数据。参数size为字节块的尺寸；cout为字节块的个数。返回实际输出的字节块的个数</span><br><span class="line">size_t fwrite(const void *buffer, size_t size, size_t count, FILE *stream);// size_t:unsigned int;</span><br></pre></td></tr></table></figure> &gt;
感觉操作系统，最难的一块就在于要计算好待数据内容的大小。 &gt;
数据存储也是按字节方式的，所以fwrite也是二进制方式，对!</p>
<p>在上面的函数中，都有一个FILE*类型的指针参数，该指针参数是fopen成功打开文件后返回的。
前三个函数主要以文本方式输出数据，而第4个函数则是以二进制方式。</p>
<ul>
<li><p>关闭文件 <code>fclose(FILE *stream);</code></p></li>
<li><p>作业
从键盘键入一批学生的成绩信息并把他们以文本格式存入外部文件:scores.txt。
//
注意这里为什么是字符串输入。因为这些字符都是可显式字符，所以可以显式指定，就在文件中看见这些内容</p></li>
</ul>
<blockquote>
<p>扩展版本：使用C++中的类 请务必注意循环输入的判断条件
还有一些系统目录是没有权限，怎么说吧，除非知道相对目录很清楚的情况外，都用绝对目录来做吧</p>
</blockquote>
<h5 id="文件的输入操作">2) 文件的输入操作</h5>
<ol type="1">
<li>打开文件 打开外部文件输入数据要用下面的函数来实现 <code>FILE *fp =
fopen(const char *filename, char *mode)</code>;
filename是要打开的外部文件名；mode是打开方式。 它可以是'r',
表示打开一个外部文件用于读操作，这时外部文件必须存在，否则打开文件失败。
另外，可以在后面加上b，表示以二进制方式打开文件，默认打开方式为文本方式，在进行输入操作时，外部文件中连续两个字符(Window)自动转换为一个字符.
读入字符0x1A(Ctrl+Z)时表示文件结束。
文件打开成功后，fopen将返回一个非空的"FILE
*"类型的指针，该指针用于今后的文件输入操作函数。文件打开失败后，fopen返回空指针
文件打开成功后，文件位置指针指向文件头。</li>
<li>输入操作 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 输入一个字符，然后返回字符的编码</span><br><span class="line">fgetc(FILE *stream);</span><br><span class="line">&gt; 哇，这个操作完全可以用来做循环条件啊，牛逼</span><br><span class="line"></span><br><span class="line">// 输入一个字符串，函数正常结束时返回string的值，否则返回NULL。</span><br><span class="line">char *fgets(char *string, int n, FILE *stream)</span><br><span class="line"></span><br><span class="line">// 输入基本类型的数据，返回值表示读入并存储的数据个数</span><br><span class="line">fscanf()</span><br><span class="line"></span><br><span class="line">// 按字节输入数据。</span><br><span class="line">size_t fread(const void *buffer, size_t size, size_t count, FILE *stream);</span><br><span class="line"></span><br><span class="line">// 判断文件结束。当文件位置指针在文件末尾时，继续进行读操作会使得feof返回非零(true)</span><br><span class="line">int feof(FILE *stream);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>当从文件中读取数据时，必须知道文件的存储格式，包括数据的类型和存储方式等。
&gt; fscanf和fprintf(文本文件), fread和fwrite(二进制文件)对应 3.
关闭文件 fclose(FILE *stream)</p>
<ul>
<li>小练习
读取上一个中的数据，计算每个学生的平均成绩；统计男生人数。</li>
</ul>
<h5 id="文件的输入输出操作">3) 文件的输入、输出操作</h5>
<blockquote>
<p>在上面注意到一个点，输入和输出都涉及到文件打开方式，那么文件打开方式是否与实际情况相符合了呢？</p>
</blockquote>
<p>以w和a方式打开的文件只能对其进行输出操作；以r打开的文件只能进行输入操作。</p>
<p>mode扩展： - r+ 读写，文件必须存在 - w+ 读写。
文件不存在会创建一个空文件，否则情况一寸照的文件 &gt;
前面这两种不过是+号更多了一种功能，跟本身功能关系很大的 - a+
打开一个外部文件用于读、添加操作。如果文件不存在，则首先创建一个空文件。以这种方式打开的文件，输出操作总是在文件尾进行。</p>
<p>另外，在这些后面可以加上t,b, 文本，二进制。对！已经测试过！"w+b"</p>
<h5 id="随机输入输出">4) 随机输入/输出</h5>
<p>一般情况下，文件的读写操作都是顺序进行的，即在进行输入输出操作时，必须按顺序读入，这样降低了文件访问的小。
每个打开的文件都有一个位置指针，指向当前读写文字，每读入或写出一个字符，文件的位置指针都会自动往后移动一个位置。
<code>fseek(FILE *stream, long offset,int origin)</code>
其中，origin指出参考位置，它可以是SEEK_CUR, SEEK_END,
SEEK_SET;offset是移动的字节偏移量，正值往后移动，负值往前移动。
fseek返回值为0表示移动成功，否则表示移动失败。
当前位置可以通过<code>ftell(FILE *stream)</code> &gt; ?
是返回的基于开头的字节数吗？？？ &gt; 需要练习 <strong>练习</strong>
读入第二个学生的信息，把该学生的专业修改为COMPUTER。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">...// 省略了Sex,Date,Major及Student的定义</span><br><span class="line">int main()&#123;</span><br><span class="line">    FILE *fp = fopen(&quot;d:\\students.dat&quot;, &quot;r+b&quot;)</span><br><span class="line">    if( fp==NULL) &#123;</span><br><span class="line">        printf(&quot;打开文件失败&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Student st;</span><br><span class="line">if (fseek(fp,sizeof(st),SEEK_SET)==0)&#123; // 文件指针指向第二个学生数据</span><br><span class="line">    fread(&amp;st,sizeof(st), 1,fp); //读入第二个学生信息</span><br><span class="line">    st.major=COMPUTER;</span><br><span class="line">    fseek(fp,-sizeof(st),SEEK_CUR);</span><br><span class="line">    fwrite(&amp;st,sizeof(st),1,fp); //修改后的第二个学生数据写入文件</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);  // 这里student 为结构体，所以不用重载，sizeof直接可以用，如果是类是否需要重载呢？</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure> ####
9.3.3 基于类库的文件I/O
前面展示了C的部分，下面展示使用I/O类库进行外部文件的输入、输出。
<code>#incldue&lt;iostream&gt;,  #include&lt;fstream&gt;</code> ##### 1)
输出
首先创建一个ofstream类(是ostream的派生对象)，使之与某个外部文静建立联系：
1. 直接方式 <code>ofstream outfile(文件名，打开方式)</code> 2. 间接方式
<code>ofstream outfile; outfile.open()</code> 打开方式ios::out 同w,
ios::app同a
打开方式还可以是上面的值与ios::binary按位或|的结果。默认为文本方式。
打开文件是否成功判断 <code>if(!out_file) 失败;   out_file.fail(),
!out_file.is_open()</code>
文件成功打开后，可以使用插入操作符“&lt;&lt;”,或ofstream的一些成员函数来进行输出操作.
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">out_file&lt;&lt;x;</span><br><span class="line">out_file.write((char *)&amp;x, sizeof(x));// 以二进制方式输出数据。</span><br><span class="line">out_file.close();</span><br></pre></td></tr></table></figure> <strong>练习</strong> 用I/O类库来实现9-1的程序功能。</p>
<blockquote>
<p>值得注意的是，对ostream和istream重载的插入操作符也能是ofstream和ifstream的对象。</p>
</blockquote>
<h5 id="输入">2) 输入</h5>
<p>同输出， 打开方式ios::in，同r。
<code>in_file.read((char*)&amp;x,sizeof(x));
//以二进制形式读入文件</code> 判断文件是否结束 <code>ios::eof(); //
返回非0表示上一次读操作中遇到了文件末尾</code></p>
<p><strong>练习</strong> ##### 3) 输入/输出与随机存取 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; istream::seekg(&lt;位置&gt;) // 指定绝对位置</span><br><span class="line">istream&amp; istream::seekg(&lt;位置&gt;, &lt;参照位置&gt;) // 指定相对位置</span><br><span class="line">streampos istream::tellg(); // 获取指针位置</span><br><span class="line"></span><br><span class="line">ostream&amp; ostream::seekg(&lt;位置&gt;) // 指定绝对位置</span><br><span class="line">ostream&amp; ostream::seekg(&lt;位置&gt;, &lt;参照位置&gt;) // 指定相对位置</span><br><span class="line">streampos ostream::tellg(); // 获取指针位置</span><br><span class="line"></span><br><span class="line">参照位置ios::beg, ios::cur, ios::end</span><br></pre></td></tr></table></figure></p>
<h3 id="面向字符串变量的输入输出">9.4 面向字符串变量的输入/输出</h3>
<p>有时，程序中有些数据并不直接输出到标准输出设备或文件，而是需要保存在程序中的某个字符变量中；程序中有些数据有时也不直接从标准输入设备或文件中获得，而是需要从程序中的某个字符变量中获得。这时，可以采用C++标准库的基于字符串变量的输入输出功能。
基于字符串变量的输入/输出功能的主要是sscanf和sprintf <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int sprintf(char *buffer, const char *format);</span><br><span class="line">int sscanf(char *buffer, const char *format);</span><br></pre></td></tr></table></figure>
与文件输入/输出不同，这里的输入源和输出目标不是文件，而是内存中一个区域:buffer.
比如说把int型变量转换为一个字符串存入字符数组a中.</p>
<p>对于基于I/O类库的字符串变量输入/输出操作，首先需要创建类istream,ostrstream或strstream的一个对象。
&gt; 在新的标准中被istringstream,
ostringstream和stringstream（头文件sstream）代替</p>
<p>// 输出 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;strstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">ostrstream str_buf; // 默认构造采用可扩充的内部缓冲</span><br><span class="line">或</span><br><span class="line">char buf[1000];</span><br><span class="line">ostrstream str_buf(buf,100);</span><br><span class="line"></span><br><span class="line">int x,y;</span><br><span class="line">str_buf&lt;&lt;x&lt;&lt;y&lt;&lt;endl;  // 通过该途径使得x和y获得了值</span><br><span class="line">char *p = str_buf.str(); // 可获取str_buf中字符串缓存的首地址</span><br></pre></td></tr></table></figure></p>
<p>// 输入 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;strstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char buf[100];</span><br><span class="line">... // 通过某种途径在buf中存放了一些字符串</span><br><span class="line">istrstream str_buf(buf);</span><br><span class="line">或</span><br><span class="line">istrstream str_buf(buf,100);</span><br><span class="line">// 如果str_buf对象的构造没有给出长度，则认为它的缓存中的内容以&#x27;\0&#x27;结束</span><br></pre></td></tr></table></figure></p>
<p>另外，也可使用抽取操作符或者其他操作符。 &gt;
用处：就是用一个东西来进行收集的感觉。然后可以用，对是这样的感觉。</p>
<h3 id="其它点">9.5 其它点</h3>
<blockquote>
<p>怎么查看C++的版本？</p>
</blockquote>
<blockquote>
<p>Linux输出平台参数一般是怎么设置的？看起来有什么快捷的地方？有没有一本好书？</p>
</blockquote>
<blockquote>
<p>一般对于继承C中的输入，输出元素，返回结果如果为非负数表示正常，具体有什么含义？返回EOF表示出问题。其他有什么函数类似？</p>
</blockquote>
<blockquote>
<p>观察到一个点，如果正常结束的话是Process finished with exit code 0;
非正常结束返回的是一个有问题的数</p>
</blockquote>
<blockquote>
<p>wostream 是干什么用的？</p>
</blockquote>
<blockquote>
<p>ostream &lt;CharT, class_traits&gt;有什么用？ 为什么不能进行ostream
a; 使用 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename charT, type traints=char_traits&lt;charT&gt;</span><br><span class="line">class basic_string;</span><br><span class="line">class basci_istram</span><br><span class="line"></span><br><span class="line">// traits 特征，性状。</span><br><span class="line">basic_string&lt;char&gt; string;</span><br><span class="line">basic_string&lt;TCHAR&gt; string;</span><br><span class="line">// 这里TCHAR可以自己指定</span><br></pre></td></tr></table></figure> -
https://stackoverflow.com/questions/5319770/what-is-the-point-of-stl-character-traits</p>
</blockquote>
<ul>
<li>http://www.cplusplus.com/reference/string/char_traits/</li>
</ul>
<p>解释 官方给的定义是： Character traits: Character traits classes
specify character properties and provide specific semantics for certain
operations on characters and sequences of characters.
换而言之，这里的意思就是对字符串这个操作特别放宽了要求，允许你过滤或者定义特殊化的字符串。
其实，平时我们都是需要什么就进行什么过滤，而这里的感觉就是给你了机会，让你将其定义为类型，然后操作起来更简便。
这里是最初开始设计的内容，后面都是在这基础上的延伸。</p>
<blockquote>
<p>模式匹配问题，记得刷leetcode,感觉上就有这样类似的问题。即如何进行模式匹配，实际上就是涉及到DFA和NFA，有限自动机和无限自动机。然后可以发现有限自动机方式，是按照回溯的方法解析的，所以会超级耗费内存。这样一想也解释通了。</p>
</blockquote>
<blockquote>
<p>路径名问题，在Windows中为, /.有两种写法\,或者/(linux).
其实主要原因在于编译器如果进行解释吧！</p>
</blockquote>
<h2 id="异常处理">异常处理</h2>
<p>异常概述 C++的异常处理机制 程序调试</p>
<ul>
<li>程序的错误通常包括：
<ul>
<li>语法错误：程序的书写不符合语言的语法规则。这类错误可由编译程序发现。例如：
<ul>
<li>使用了未定义或未声明的标识符</li>
<li>左右括号不匹配</li>
</ul></li>
<li>逻辑错误：程序设计部当造成程序没有完成预期的功能。这类错误可通过对程序进行静态分析和动态测试发现。
<ul>
<li>把两个数相加写成了相乘</li>
<li>排序功能未能正确排序 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool strlonger(char *str1,char *str2)&#123;</span><br><span class="line">    return strlen(str1)-strlen(str2)&gt;0;</span><br><span class="line">&#125;   </span><br><span class="line">strlonger(&quot;abc&quot;,&quot;1234&quot;) //?</span><br><span class="line">因为strlen()返回的是unsigned int, -1&gt;0这个被认为是真。 两个unsigned int运算结果不会进行自动转换。</span><br><span class="line">修改 (int)(strlen(str1)-strlen(str2))&gt;0</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>运行异常：程序设计对程序运行环境考虑不周而造成的程序运行错误。
<ul>
<li>对于x/y操作，y输入了零</li>
<li>由内存空间不足导致的访问空指针：int <em>p=new int; </em>p=10;</li>
<li>输入数据的数量超过存放它们的数组的大小导致数组下标越界</li>
<li>多任务环境可能导致的文件操作错误</li>
<li>给一个采用二分法查找的函数提供了一个未排序的数组</li>
<li>数据超出了其类型所允许的范围（溢出）</li>
</ul></li>
</ul></li>
</ul>
<p>语法错误，编辑器会编译不通过. 逻辑错误：环境正常，结果不正确。
运行异常：环境正常，结果正确。环境不正常，结果不正确</p>
<p>在程序运行环境正常的情况下，导致运行异常的错误是不会出现的。
程序异常错误往往是由于程序设计者对程序运行环境的一些特殊情况考虑不足所造成的。</p>
<p>导致程序运行异常的情况是可以预料的，但它是无法避免的。</p>
<p>为了保证程序的鲁棒性，必须在程序中对可能的异常进行预见性处理。 &gt;
比如在输入的输入对输入的各种情况进行排查，原本的一个例子就是输入文件，然后文件路径不存在。</p>
<h3 id="处理异常的策略">处理异常的策略</h3>
<blockquote>
<p>思考：有时间异常不是错误，所以没有必要当场处理；而且，有可能当场有重要的事情，那么这样做的话其实是非常草率的一件事情。还有用exit或abort,
这种每次都一下子退出了，完全不知道出现了什么问题，对程序员来说是一种特别懵逼的状态。</p>
</blockquote>
<p>就地处理, 在发现错误的地方处理异常。
异地处理，在其他地方（非异常发现地）处理异常。</p>
<p>异常的就地处理</p>
<p>常见做法是调用C++标准库中的函数exit或abort -
abort立即终止程序的执行，不做任何的善后处理工作 -
exit在终止程序的运行前，会做关闭被程序打开的文件、调用全局对象和static存储类的局部对象的析构函数等工作。
注意：不要在对象类的析构函数中调用exit，否则该析构函数不能调用。</p>
<p>不管是abort还是exit，都"not user-friendly"</p>
<p>异常的异地处理。</p>
<p>发现异常时，在发现地（如在被调用的函数中）有时不知道如何处理这个异常，或者不能很好地处理这个异常，要由程序的其它地方（如函数的调用者）来处理。
例如，前面的函数f中打开文件失败，这时可以由调用者重新提供一个文件来解决。</p>
<h3 id="如何实现异常的异地处理">如何实现异常的异地处理？</h3>
<ol type="1">
<li>通过函数的返回值，或指针、引用类型的参数，或全局变量把异常情况通知函数的调用者，由调用者处理。在计算机网络中很多情况都是这样处理的。
&gt; 该途径的不足： &gt;
通过函数的返回值返回异常情况会导致正常返回值和异常返回值交叉在一起。
&gt;
通过指针，引用类型的参数返回异常情况，需要引入额外的参数，给设计带来负担
&gt;
通过全局变量返回异常情况会导致使用者忽视这个全局变量的问题，不知道它的存在。
&gt; 程序的可读性差！程序的正常处理与异常处理混杂在一起</li>
<li>通过语言提供的结构化异常处理机制进行处理 C++异常处理机制
把有可能遭遇异常的一系列操作（语句或函数调用）构成一个try语句块
如果try语句块中的某个操作在执行中发现了异常，则通过执行一个throw语句抛出一个异常对象，之后的操作不再进行。
抛置的异常对象将由能够处理这个异常的地方通过catch语句块来捕获并处理之。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void f(char *filename)&#123;</span><br><span class="line">    ifstream file(filename);</span><br><span class="line">    if (file.fail())  throw filename(); // 产生异常</span><br><span class="line">    int x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    ...</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> int main()&#123;</span><br><span class="line">     char str[100];</span><br><span class="line">     ...</span><br><span class="line">     try&#123;</span><br><span class="line">         f(str); // 启动异常处理机制</span><br><span class="line">         // 如果在函数f中抛掷了char*类型的异常，则程序转到try后面的catch(char*str)处理</span><br><span class="line">     &#125; catch(char *fn)&#123; // 捕获异常</span><br><span class="line">         ...// 处理异常</span><br><span class="line">     &#125;</span><br><span class="line">     ...// 正常情况</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure> &gt;
一种直观的感觉，等于说try语句这里把所有的异常进行了传递，然后所有子的对象都会返回回来。如果从运行的角度来思考也很正常。然后，还有一个点，类也可以实现，即基类的指针一直指回基类？对吗？</li>
</ol>
<h3 id="try语句">try语句</h3>
<p>try语句块的作用是启动异常处理机制。其格式为： try{ 语句序列 }</p>
<p>上述的语句序列中可以有函数调用。</p>
<h3 id="throw语句">throw语句</h3>
<p>throw语句用于在发现异常情况时产生异常对象。 throw <表达式>
表达式为任意类型的C++表达式。 例如： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void f(char *filename)&#123;</span><br><span class="line">    ifstream file(filename);</span><br><span class="line">    if (file.fail())  throw filename(); // 产生异常</span><br><span class="line">    // 注意这里异常的对象为一个字符串指针，这里是与catch中的类型相互对应的。</span><br><span class="line">    int x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    ...</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
执行throw后，接在其后的语句将不再继续执行，而是转向异常处理（由某个catch语句给出）
&gt; 这里也好理解，当出错的时候肯定是这样处理了啊 一个问题？
这样做属于异常的异地处理了。怎么说来看的话是封装了一层。即实际上也是用的全局变量，但是不是在返回一层时调用，可能是返回多层时进行调用的。细想一下，震惊了哈哈哈。
挺好，用本身自带的变量不好，重新开辟一个浪费，如果是全局变量则被忽视，所以倒不如由底层处理好了再说，真棒！</p>
<h3 id="catch语句">catch语句</h3>
<p>catch语句块用于捕获throw产生的异常对象并处理相应的异常。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">catch(&lt;类型&gt;[&lt;变量&gt;])</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
类型用于指出捕获何种异常对象，它与异常对象的类型匹配规则如若函数重载。
变量用于存储异常对象，它可以缺省，缺省时表明catch语句块只关心异常对象的类型，而不考虑具体的异常对象。
&gt;
这里想到了实际上做的时候确实只关心了异常对象的类型，而且是将类型分为了唯一的积累，这样处理起来就方便了很多。</p>
<p>catch语句块要紧接在某个try语句的后面。</p>
<p>一个try语句块可以跟多个catch语句块，用于捕获不同类型的异常对象并进行处理。
&gt;
这里做的是类型其实也还可以，但是很是不行，因为处理的准则应该是对应于哪种错误，关于类型直接反馈不到处理上。</p>
<p>关于try、throw和catch几点注意 -
在try语句块的语句序列执行中如果没有抛出异常对象，则其后的catch语句不执行，而是继续执行try语句块之后的非catch语句。
- 在try语句块的语句序列执行中如果抛掷了异常对象 -
该try语句块之后有能够捕获该异常对象的catch语句，则执行这个catch语句中的语句序列，然后继续执行这个catch语句之后的非catch语句
-
该try语句块之后没有能够捕获该异常对象的catch语句，则由函数调用链的上一层函数中的try语句的相应catch来捕获。
&gt; 这就是用到的向上层抛出异常。</p>
<ul>
<li><p>如果抛除异常对象的throw语句不是由程序的某个try语句块中的语句序列调用的，则抛掷的异常不会被程序中的catch捕获
&gt;
也就是不在try语句中，所以就要注意了，必须代码在检测范围中才能被检测啊，这是很浅显的道理了啊！</p></li>
<li><p>异常处理的嵌套 try语句是可以嵌套的</p></li>
<li><p>当在内层的try语句的执行中产生了异常，则首先在内层try语句块之后的catch语句中找，否则想上处理</p></li>
<li><p>如果抛掷的异常对象没有，则调用系统的terminate函数进行标准化异常处理。默认情况下，terminate函数将会去调用abort函数。</p></li>
</ul>
<p>还有一个很重大的问题，有时候终止程序需要很大的代价，那么是否可以做到程序不终止，一直到获得正确的数据为止呢？
&gt; ?????上层一直while循环</p>
<h2 id="程序调试">程序调试</h2>
<ul>
<li>一个处于开发阶段的程序可能会含有很多错误（逻辑或异常）。</li>
<li>发现和找出这些错误的一种手段是在程序中的某些地方家伙少年宫一些输出语句，在程序运行时把一些调试信息（如变量的值）输出到显示器。</li>
</ul>
<blockquote>
<p>啊啊，我现在都一直用的是这种笨办法</p>
</blockquote>
<p>这种方式存在以下问题： -
调试者必须对输出的值做一定的分析才能知道程序是否有错。 -
在开发结束后，去掉调试信息有时是一件很繁琐的工作 &gt; 难道是用 Debug,
或者调试工具？哇撒</p>
<p>？断言
实际上，在调试程序时输出程序中的某些变量或表达式的值，其目的是为了确认程序输出的这些值与预期的值是否相符。
上述的目的可以让程序设计者在程序的一些关键或容易出错的点上插入一些相关的断言来表达
- 断言是一个逻辑表达式，它描述了程序执行到断言处应该满足的条件 -
如果条件满足则程序继续执行下去，否则程序执行异常终止。
在程序测试阶段，断言可以帮助测试这发现程序的逻辑错误，也可以用来发现一些异常错误。</p>
<blockquote>
<p>语法错误首先X,然后的话异常只能按自己是否能够预知下得到。然后的断言最大的好处真的在可以发现程序的逻辑错误啊，真牛逼！其实这等同于输出的，就是每次debug这样真的好麻烦好吗？而且没有意思，哇咔咔，这样真有趣！</p>
</blockquote>
<blockquote>
<p>哇，想起了java的测试工具类，python的测试工具包，终于浮出水面了吗？</p>
</blockquote>
<p>宏assert</p>
<p>C++标准库提供的一个宏assert(cassert, assert.h),可以实现断言。
宏assert要求一个关系，逻辑表达式作为其参数，当assert执行时， -
如果表达式的值为false，则会显示出相应的表达式、它所在的源文件名以及所在的行号等诊断信息，然后调用库函数abort终止
- 当表达式的值为true时，程序继续执行</p>
<p>例如，下面的宏assert调用表示程序执行到该宏调用处变量x的值应等于1：
assert(x==1)
当程序执行到该调用处，如果x的值不等于1，则它会显示下面的信息并终止：
Assertion failed:x=1,fileXXX,line YYY 可以返现异常错误，如
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int divide(int x,int y)&#123;</span><br><span class="line">    assert(y==0);</span><br><span class="line">    return x/y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是真的是超级好用的一个东西。
宏assert的实现是通过条件编译预处理命令来实现的： cassert, <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef NDEBUG</span><br><span class="line">#define assert(exp) ((void)0)</span><br><span class="line">#else</span><br><span class="line">#define assert(exp) ((exp)?(void)0:&lt;输出诊断信息并调用库函数abort&gt;)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
&gt;
解释，也就是说宏assert只有在宏名NDEBUG没有定义时才有效，这时，程序一般处于开发、测试阶段。程序开发结束提交时，应该让宏名NDEBUG有定义。然后重新编译程序，这样，assert就不再有效了。</p>
<blockquote>
<p>在思考，#DEBUG有啥用？</p>
</blockquote>
<h3 id="一点有意思的记录">一点有意思的记录</h3>
<p>char <em>p="adad"; </em>p指向的是字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strlen(p); // 传入指针就行，能想清楚。</span><br><span class="line">// 这本身就是其功能规定的，所以这里也不多说什么。觉得就这样吧，是对的。</span><br><span class="line">cout&lt;&lt;p;  //正常输出</span><br><span class="line">printf(&quot;%s&quot;,p); // 输出</span><br></pre></td></tr></table></figure>
<p>//
等下，我好想这里搞错了什么，或者说把一些事情。也就是说这里指针是没错的。因为这里是统一处理输入输出的函数。</p>
<p>// 另一个方面讲</p>
<p>太棒了，刚说自己想多了，结果才发现这里有说明的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/nju-course-cplus-lecture4-summary-3c575f3819fe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/nju-course-cplus-lecture4-summary-3c575f3819fe/" class="post-title-link" itemprop="url">nju-course-cplus-lecture4-summary</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:52:19" itemprop="dateCreated datePublished" datetime="2019-09-19T09:52:19+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>泛型程序设计</p>
<blockquote>
<p>类型的多态</p>
</blockquote>
<p>首次尝试，c使用泛型指针。c++template关键字，剩余的事情交给编译器。
代码写得简单，就可以当做常见的int来做，而且不容易出错。 封装了一层。</p>
<p>what where who when how 1. 哪里使用？ 普通类型，直接，在类中。
特殊类型——类，需要把对应的操作，构造函数，复制构造函数处理安全。</p>
<ol start="2" type="1">
<li>怎么用？ template&lt;class T,int size&gt; 可加非这个量。
不具体化，不认的。</li>
</ol>
<p>类型冲突的请显式说出来</p>
<p>注意了：实现必须写在.h中，这是代码复用；不用担心重复解释，编译器会解决；然后，全局函数其他都要把<class T>标出来，特别是友元。</p>
<ol start="3" type="1">
<li>于是，C++, STL
远离类型，就是实际所分析和学的数据结构和算法，所以妙啊！
不过遇到具体类型套而已！</li>
</ol>
<ul>
<li><p>容器，常用数据结构。 &gt; 这里是序列化数据;
复杂的数据结构可以由这些给组合而成的，哈哈哈！</p></li>
<li><p>算法 &gt; 一些最常用的操作集合</p></li>
<li><p>迭代器 &gt;
也就是算法中对数据结构的抽象吧，主要是抽象为数组的处理一样，可以轻易找到头尾，下一个元素，以及向前，向后。</p></li>
</ul>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/liyuan_669/article/details/22100165">迭代器是一种检查容器内元素并遍历元素的数据类型</a></p>
<p>字面不要过度推理，从权限上看</p>
<p>InputIterator: 单步迭代，不允许修改
相当于<code>vector&lt;int&gt;::const_iterator iter, 可以iter++,
不可以*iter=1;</code>注意区分 <code>const vector&lt;int&gt;::iterator
iter=v.beign, 可以*iter=1,不可以iter++</code></p>
<p>OutputIterator: 单步迭代，可以修改。</p>
<blockquote>
<p>突然这里对前面返回两种不同的东西有了实质的感觉，一个是正常，另一个是既不可以被修改，也不可以增加</p>
</blockquote>
<p>0: queue,stack,pq InputI: OutputI: ForwardI: BidrectionalI:
list,map,set Random-accessI: vector,deque,basic_string</p>
<p>类型 - 添加 push, insert - 大小 size, empty , resize,count - 访问
back,front, [],at,top,find - 删除 erase,clear,pop_back - 赋值与swap:
=,swap, assign()//重新设置</p>
<blockquote>
<p>然后按照需要思考会用哪些？</p>
</blockquote>
<blockquote>
<p>循环遍历 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  for (it=phone_book.begin(); it != phone_book.end(); it++) </span><br><span class="line">// 注意这里 end()返回的是最后的下一个元素，按照链表来看就是null. 具体是什么值我也不知道</span><br></pre></td></tr></table></figure> 首尾元素是head, tail</p>
</blockquote>
<ol start="4" type="1">
<li>todo 再想不同迭代器</li>
</ol>
<p>一种类型的定义：<a
target="_blank" rel="noopener" href="https://blog.csdn.net/zhanh1218/article/details/33340959">如果需要定义真正的tuple，那就需要用const
vector<int> nums(10,9); 然后用const_iterator来访问</a></p>
<p>C++11新增加的内容 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto i1 = Container.begin();  // i1 is Container&lt;T&gt;::iterator </span><br><span class="line">auto i2 = Container.cbegin(); // i2 is Container&lt;T&gt;::const_iterator</span><br></pre></td></tr></table></figure></p>
<p>所以cbegin()的访问控制就是public</p>
<blockquote>
<p>不同迭代器代码上怎么看？怎么区分。对于容器来说是都返回其基类？由具体用的时候，再判断和出错.</p>
</blockquote>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/sim_szm/article/details/8980879">褚略理解</a>
- 输入。 find, accumulate; 标准库istream_iterator - 输出。 copy,
ostream_iterator - 前向. replace - 双向。 reverse - 随机访问 sort, &lt;,
&gt;, !=, +,-,回退多个元素 &gt; 具体的算法有具体的应用</p>
<blockquote>
<p>发现很多接口的改进点：增加了越界的判断。比如[]和at，细想真的牛逼！</p>
</blockquote>
<ol start="5" type="1">
<li>算法</li>
</ol>
<p>分类 - 调序算法：实现按某个要求改变容器中元素次序的操作 &gt;
比如sort,</p>
<ul>
<li><p>编辑算法：实现对容器元素的复制、替换、删除、赋值等操作 &gt;
比如replace, transform</p></li>
<li><p>查找算法：实现在容器内查找元素或子元素序列等操作 &gt;
find,count_if</p></li>
<li><p>算术算法：实现在容器内进行求和、内积和、差等操作 &gt;
accumulate</p></li>
<li><p>集合算法：实现集合的基本运算，要求已经排好序？</p></li>
<li><p>堆算法：实现基于堆结构的容器元素，第一个元素最大</p></li>
<li><p>元素遍历算法 for_each</p></li>
</ul>
<p>算法指定在迭代器上，妙！迭代器自身相容，妙！
规定，作用范围一样，src_first,src_last, dst_first</p>
<p>函数参数：进行自定义，类型也为T</p>
<p>一个超级有趣的例子。</p>
<p>匹配一定条件的东西， count_if()-&gt;类-&gt;lambda表达</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/nju-course-cplus-lecture4-89515bc1c2bf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/nju-course-cplus-lecture4-89515bc1c2bf/" class="post-title-link" itemprop="url">nju-course-cplus-lecture4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:51:16" itemprop="dateCreated datePublished" datetime="2019-09-19T09:51:16+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">course</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/" itemprop="url" rel="index"><span itemprop="name">nju</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/cplus/" itemprop="url" rel="index"><span itemprop="name">cplus</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="重点">重点</h1>
<h2 id="泛型程序设计">泛型程序设计</h2>
<p>一个程序实体能对多种类型的数据进行操作或描述的特性称为类属性。具有类属性的程序实体通常有：
1. 类属函数 2. 类属类</p>
<p>类属也是一种多态，称为参数化多态。</p>
<p>比如说用通用指针。</p>
<p>如上所示，C++提供了两种实现类属函数的机制 -
采用通用指针类型的参数(C语言的做法) - 函数模板</p>
<h3 id="通用指针">通用指针</h3>
<p>整个世界就是由1构成的，可以升为万物的。 void
*，所有的父类。通用的都是byte.</p>
<p>这些东西然后不断地转换为其他的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> 函数定义：</span><br><span class="line"> void sort(void *base, unsigned int count, unsigned  int element_size, int (*cmp)(const void*, const void*))&#123;</span><br><span class="line">     // 这里函数参数和也可以诶，发现我完全想复杂了。也就是说这里的话，只要弄个函数名做参数，其实也不所谓，没有我想的那么复杂，哈哈哈！两步就可以了</span><br><span class="line">     // 取第i个元素</span><br><span class="line">     (byte *)base + i*element_size</span><br><span class="line"></span><br><span class="line">    // 比较第i个和第j个元素的大小，利用调用者提供的回调函数cmp实现</span><br><span class="line">    (*cmp)((byte *)base + i*element_size, (byte*)base + j*element_size)</span><br><span class="line"></span><br><span class="line">    // 交换第i个和第j个元素</span><br><span class="line">    byte *p1 = (byte *)base + i*element_size;</span><br><span class="line">    byte *p2 = (byte *)base + j*element_size;</span><br><span class="line">    for(int k=0;k &lt; element_size;k++)&#123;</span><br><span class="line">        byte temp=p1[k]; p1[k]=p2[k]; p2[k]=temp;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> 这里的byte为typedef unsigned char byte;</span><br><span class="line"></span><br><span class="line">void sort(void *base, //需排序的数据（数组）首地址</span><br><span class="line">             unsigned int count, //数据元素的个数</span><br><span class="line">             unsigned int element_size, //一个数据元素所需的空间大小</span><br><span class="line">             int (*cmp)(const void *, const void *) ) //比较两个元素的函数</span><br><span class="line">&#123;   //不论采用何种排序算法，一般都需要对数组进行以下操作：	</span><br><span class="line">     //取第i个元素</span><br><span class="line">        (char *)base+i*element_size</span><br><span class="line">     //比较第i个和第j个元素的大小 （利用调用者提供的回调函数cmp实现）</span><br><span class="line">        (*cmp)((char *)base+i*element_size,</span><br><span class="line">                    (char *)base+j*element_size)</span><br><span class="line">     //交换第i个和第j个元素</span><br><span class="line">        char *p1=(char *)base+i*element_size,</span><br><span class="line">	     *p2=(char *)base+j*element_size;</span><br><span class="line">        for (int k=0; k&lt;element_size; k++)</span><br><span class="line">        &#123;	char temp=p1[k]; p1[k] = p2[k]; p2[k] = temp;</span><br><span class="line">        &#125; </span><br><span class="line">&#125; //上面的char用byte替代更好！typedef unsigned char byte;</span><br></pre></td></tr></table></figure>
<p>调用者需要调用 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int A_compare(const void* p1, const void* v2)&#123;</span><br><span class="line">    if(*(*A)p1 &lt; *(A*)p2) return -1;</span><br><span class="line">    else if(*(*A)p1) &gt; *(A*)p2) return 1;</span><br><span class="line">    else return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类属排序函数的使用</span><br><span class="line">int a[100];</span><br><span class="line">sort(a,100,sizeof(int),int_compare);</span><br><span class="line">double b[200];</span><br><span class="line">sort(b,200,sizeof(double), double_compare);</span><br><span class="line">A c[300]; // 如果这里A是类，就显示出了将比较符号重载的有效性</span><br><span class="line">sort(c,300,sizeof(A),A_compare)</span><br></pre></td></tr></table></figure> 品味！</p>
<h3 id="函数模板">函数模板</h3>
<p>函数模板是指带有类型参数的函数定义，其一般格式如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T1, class T2,...&gt;</span><br><span class="line">&lt;返回值类型&gt; &lt;函数名&gt;(&lt;参数表&gt;)&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void sort(T elements[], unsigned int count)&#123;</span><br><span class="line">    // 取第i个元素</span><br><span class="line">    elements[i]</span><br><span class="line">    // 比较第i个和第j个元素的大小</span><br><span class="line">    elements[i]&lt; elemnets[j]</span><br><span class="line">    // 交换第i个和第j个元素</span><br><span class="line">    T temp = elements[i];</span><br><span class="line">    elements[i] = elements[j];</span><br><span class="line">    elements[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; 来一起感叹，太他妈牛逼了。这template省去了好多麻烦！好高层的一种抽象，太棒了，果然！牛逼死了</span><br><span class="line"></span><br><span class="line">int a[100];</span><br><span class="line">sort(a, 100);</span><br><span class="line">double b[200];</span><br><span class="line">sort(b,200);</span><br><span class="line">A c[300];</span><br><span class="line">sort(c, 300);</span><br></pre></td></tr></table></figure></p>
<p>函数模板的使用——实例化 - 函数模板定义了一系列重载的函数 -
要使用函数模板所定义的函数，称为模板函数，首先必须对函数模板进行实例化：给模板参数提供一个类型作为值，从而生成具体的函数。
- 函数模板的实例化通常是隐式的 - 由编译程序来做，模板实参推演</p>
<p>当编译程序无法根据调用时的参数类型来确定所调用的模板参数，这时，需要在程序中显式第实例化函数模板。</p>
<p>除了类型参数外，函数模板也可以带有非类型参数，使用时需要显式实例化。
template&lt;class T, int size&gt; void f(T a){ T temp[size]; }</p>
<h3 id="类模板">类模板</h3>
<p>如果一个类的成员的类型可变，则该类称为类属类。在C++中，类属类用类模板实现。
template&lt;class T1, class T2&gt; class <类名>{}</p>
<p>使用 Stack<int> st1;</p>
<p>!!!
类模板中的静态成员仅属于实例化后的类，不同类模板实例之间不共享类模板中的静态成员。
template <class T> class A{ static int x; }</p>
<p>注意！在自己定义时，需要把模板的定义和实现都放在头文件中。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// file1.h</span><br><span class="line">template &lt;class T&gt; </span><br><span class="line">class S //类模板s的定义</span><br><span class="line">&#123;  T a;</span><br><span class="line">  public:</span><br><span class="line">    void f();</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;class T&gt; </span><br><span class="line">void S&lt;T&gt;::f() //类模板s的实现  如果放在对应的file1.cpp中，会显示该实例不存在</span><br><span class="line">&#123; ......</span><br><span class="line">&#125;</span><br><span class="line">extern void func();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
使用者通过包含这个头文件，把模板的源代码全包含进来，以备实例化所需。
因此，模板是基于源代码的复用、</p>
<ul>
<li>重复实例的处理
模板的复用会导致多模块的编译结果中存在相同的实例：</li>
</ul>
<ol type="1">
<li>相同的函数模板实例</li>
<li>相同的类模板成员函数实例 相同代码的存在会造成目标代码庞大！
如何处理？</li>
</ol>
<ul>
<li>由开发环境来解决：编译第二个模块的时候不生成这个函数</li>
<li>由连接程序来解决：舍弃多余的那一个</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">关于类模板的友元</span><br><span class="line">template &lt;class T&gt; class A;</span><br><span class="line">template &lt;class T&gt; void f3(A&lt;T&gt;&amp; a) &#123; ... &#125;</span><br><span class="line">template class&lt;T&gt;</span><br><span class="line">class A</span><br><span class="line">&#123; T x,y;</span><br><span class="line">  ......</span><br><span class="line">  friend void f1(A&lt;T&gt;&amp; a); //友元f1不是模板！</span><br><span class="line">  template &lt;class T1&gt; friend void f2(A&lt;T1&gt;&amp; a); //f2与A多对多实例化</span><br><span class="line">  friend void f3&lt;T&gt;(A&lt;T&gt;&amp; a); //f3与A一对一实例化(用相同参数类型)</span><br><span class="line">&#125;;</span><br><span class="line">void f1(A&lt;int&gt;&amp; a) &#123; ... &#125;</span><br><span class="line">template &lt;class T&gt; void f2(A&lt;T&gt;&amp; a) &#123;...&#125;</span><br><span class="line">......</span><br><span class="line">A&lt;int&gt; a1; //实例化A&lt;int&gt;</span><br><span class="line">A&lt;double&gt; a2; //实例化A&lt;double&gt;</span><br><span class="line">f1(a1); //OK，调用f1(A&lt;int&gt;&amp;)</span><br><span class="line">f1(a2); //链接错误! 调用f1(A&lt;double&gt;&amp;)，但它不存在！</span><br><span class="line">f2(a1); //实例f2&lt;int&gt;是A&lt;int&gt;和A&lt;double&gt;的友元</span><br><span class="line">f2(a2); //实例f2&lt;double&gt;是A&lt;int&gt;和A&lt;double&gt;的友元</span><br><span class="line">f3(a1); //实例f3&lt;int&gt;是A&lt;int&gt;的友元，但不是A&lt;double&gt;的友元！</span><br><span class="line">f3(a2); //实例f3&lt;double&gt;是A&lt;double&gt;的友元，但不是A&lt;int&gt;的友元！</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：友元是外部，在说明友元时也需要在外部进行说明。</p>
</blockquote>
<h3 id="c标准库">C++标准库</h3>
<p>在C++标准库中，除了C标准库保留下来的一些功能外，其它功能大都以模板形式给出，这些模板构成了C++的标准模板库。
STL实现了数据结构和算法的复用，体现了泛型程序设计的精髓。
STL支持了一种编程思想模式。</p>
<p>STL主要包含： -
容器类模板：用于存储序列化数据元素，比如：向量、队列、栈、集合等 -
算法（函数）模板：用于对容器中数据元素进行一些常用的操作，如：排序、查找、求和等
- 迭代器类模板：实现了抽象的指针功能，它用于指向容器中的元素。 -
迭代器是容器和算法之间的桥梁：传给算法的不是容器，而是指向容器中元素的迭代器，算法通过迭代器实现对容器中数据元素的访问和遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    int x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    while(x&gt;0)&#123;</span><br><span class="line">        v.push_back(x);</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt;::iterator it1=v.begin();</span><br><span class="line">    vector&lt;int&gt;::iterator it2=v.end();</span><br><span class="line">    cout&lt;&lt;&quot;Max= &quot;&lt;&lt;*,ax_element(it1, it2)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&quot;Sum=&quot;&lt;&lt;accumulate(it1, it2, 0)&lt;&lt;endl;</span><br><span class="line">    sort(it1, it2);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;Sorted result is:\n&quot;;</span><br><span class="line">    for_each(it1, it2,[](int x)&#123;cout&lt;&lt;x&lt;&lt;&#x27;&#x27;; return;&#125;)</span><br><span class="line">    cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="容器">容器</h4>
<p>容器是由长度可变的同类型元素所构成的序列。
STL中包含了很多种容器，虽然这些容器提供了很多相同的操作，但采用了不同的内部实现方法，所以不同的容器适合不同的应用场合。
容器由类模板来实现</p>
<ul>
<li><p>vector&lt;&gt;
需要快速定位任意位置上的元素以及主要在元素序列的尾部增加、删除元素的场合
在头文件vector中定义，用动态数组实现</p></li>
<li><p>list&lt;&gt; 用于经常在元素序列中任意位置上插入或删除元素的场合。
list, 双向链表实现</p></li>
<li><p>dequeue&lt;&gt;
用于主要在元素序列的两端增加、删除元素以及需要快速定位任意位置上的元素的场合
dequeue, 用分段的连续空间结构实现</p></li>
<li><p>stack&lt;&gt; 用于仅在元素序列的尾部增加、删除元素的场合
基于deque实现</p></li>
<li><p>queue&lt;&gt; 用于仅在元素序列的头部增加、删除元素的场合
基于dequeue实现</p></li>
<li><p>priority_queue&lt;&gt;
与queue的操作类似，不同之处在于：每次增加，删除元素之后，它将元素位置进行调整，使得头部元素总是最大的。每次删除操作总是把最大的元素去掉。
在queue中定义，一般基于vector和heap实现</p></li>
<li><p>map&lt;关键字类型，值类型&gt; multimap</p></li>
<li><p>容器中每个元素是一个pair结构类型，该结构有两个成员：first和second，关键字对应first,
值对应second,元素是根据其关键字排序的。用于需要根据关键字来访问元素的场合</p></li>
<li><p>对于map，不同元素的关键字不能相同；对于multimap,不同元素的关键字可以相同</p></li>
<li><p>map中定义</p></li>
<li><p>set<元素类型> multiset</p></li>
<li><p>相对于map和multimap, 合一了</p></li>
<li><p>set中定义</p></li>
<li><p>basic_string&lt;&gt;</p></li>
<li><p>与vector类似，不同之处在于其元素作为字符类型，并提供了一系列与字符串相关的操作</p></li>
<li><p>string和wstring分别是它的两个实例：
basic_string<char>和basic_string<wchar_t></p></li>
<li><p>在string中定义</p></li>
</ul>
<h4 id="容器的操作">容器的操作</h4>
<ul>
<li>获取指定位置的元素</li>
<li>增加元素</li>
<li>删除元素</li>
<li>查找元素</li>
<li>获取容器首、尾元素的迭代器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">T &amp;front();</span><br><span class="line">T &amp;back();  // vector, list,dequeue,queue</span><br><span class="line"></span><br><span class="line">void push_front(const T&amp;x) void pop_front;  //list,deque</span><br><span class="line">void push_back(const T&amp;x) void pop_back; //vector,list,dequeue</span><br><span class="line"></span><br><span class="line">void push(const T&amp;x) // 尾部stack, queue, priority_queue</span><br><span class="line">void pop() // 尾部stack, 头部queue, priority_queue</span><br><span class="line"></span><br><span class="line">T &amp;top();  const T&amp;top() const;  尾部stack , 头部priority_queue</span><br><span class="line"></span><br><span class="line">iterator begin();</span><br><span class="line">const_iterator begin() const;  除queue,priority queue, stack</span><br><span class="line">// 为什么有两种？有啥不一样的用的地方吗？</span><br><span class="line"></span><br><span class="line">iterator end();</span><br><span class="line">const_iterator end() const; 同上</span><br><span class="line"></span><br><span class="line">iterator insert(iterator pos, const T&amp; x);</span><br><span class="line">void insert(iterator pos, InputIt first, InputIt last);</span><br><span class="line">// pos 插入一个呼呼多个元素， vector, list, deque</span><br><span class="line"></span><br><span class="line">iterator erase(iterator pos)</span><br><span class="line">iterator erase(iterator first, iterator last);</span><br><span class="line">// vector, list, deque, map/multimap, set, basic_string</span><br><span class="line"></span><br><span class="line">T &amp;operator[](size_type pos)</span><br><span class="line">// pos上的引用， vector, deque, basic_string</span><br><span class="line"></span><br><span class="line">ValueType &amp; operator[](const KeyType&amp; key); // map</span><br><span class="line"></span><br><span class="line">T&amp; at(size_type pos);</span><br><span class="line">相比于[], 进行了越界检查； vector,deque,basic_string</span><br><span class="line"></span><br><span class="line">iterator find(const T&amp; key);</span><br><span class="line">// 根据关键字查找，找到返回；否则返回最后一个元素的下一个位置</span><br></pre></td></tr></table></figure>
<blockquote>
<p>值得注意的是，如果容器的元素类型是一个类，则针对该类需要： 1.
自定义拷贝构造函数和赋值操作符重载函数。 2. 重载比较操作符&lt;</p>
</blockquote>
<h4 id="迭代器">迭代器</h4>
<p>迭代器是实现了抽象的指针（智能指针）。它们指向容器中的元素。 &gt;
哇，抽象指针，牛逼</p>
<p>在STL中，迭代器是作为类模板来实现的，它们可以分为以下几种： -
输出迭代器output iterator - 用来修改它所指向的容器元素 - 间接访问操作
*输出迭代器 - ++操作</p>
<ul>
<li><p>输入迭代器input iterator</p>
<ul>
<li>用于读取它指向的容器元素</li>
<li>间接访问操作 *p</li>
<li>元素成员间接访问-&gt;</li>
<li>++, ==, !=操作</li>
</ul></li>
<li><p>前向迭代器 &gt;
哇，这个就应该是方向有关吧。只能一个方向，不过好奇的是这个方向有规定只能从头到尾吗？感觉上应该两种都被允许
用于读取、修改它所指向的容器元素 元素间间接访问操作和元素成员间接访问.
同义获取关联的对象 &gt;
如果是int，则访问的是其值，就对应于第一种情况；如果是类，就对应于第二种情况。
++,==,!=操作</p></li>
<li><p>双向迭代器 用于读取，修改它所指向的容器元素
元素间接访问操作和元素成员间接访问操作 ++,--,==,!=</p></li>
<li><p>随机访问迭代器 用于读取、修改它所要指向的容器元素
元素间接访问操作、元素成员间接访问和随机访问元素操作
++,--,&gt;=,&lt;,&gt; &gt;
随机访问吗？应该是对于固定存储的吧？不然实现算法复杂度不一样唉，真好奇实现方法。
&gt; 对！下面得到了回答</p></li>
</ul>
<p>从上到下，从派生类到基类</p>
<p>哦，来啦</p>
<p><strong>各容器的迭代器类型</strong> - vector,deque, basic_string,
begin/end返回的是随机访问迭代器 - list,map,set返回的是双向迭代器 &gt;
这两个因为内部的物理实现结构不一样 -
对于queue,stack,priority_queue,不支持迭代器 &gt;
为啥，不支持前向后向吗？queue本身支持，但是因为queue,stack有其特定的持有顺序所以不支持吗？特殊功能，而priority_queue更是由于实现复杂。每一次动荡代价不一样。</p>
<blockquote>
<p>迭代器的作用就是每个变量的指示，最多的应用自己所见到的就是遍历。所以怎么说感觉上应该能得到下一个元素的地址的那种</p>
</blockquote>
<h4 id="算法">算法</h4>
<p>分类 调序算法 编辑算法 查找算法 算术算法 集合算法 堆算法
元素遍历算法</p>
<p>STL算法体现了一种高度抽象： - 每一个算法都完成一个特定的功能 -
大部分算法都是遍历指定的容器元素，对满足条件的元素执行默认的或自定义的操作。
-
使用者只需要提供：容器（迭代器）、操作条件以及自定义操作，而控制逻辑则有算法内部实现。循环不用操心</p>
<p>算法处理的是容器的迭代器，这样的好处很明显，能够提高算法对容器的适应性。虽然容器各不相同，一个算法往往可以接受相容的多种迭代器</p>
<p>一个算法能接收的迭代器的类型时通过算法模板参数的名字来体现的。一个算法能接收与参数类型相容的所有种类的迭代器。
&gt;
这里应该不是都是最大的权限即随机访问迭代器吧？这样虽然特别妙？不对指针不应该是指向基类吗？那么怎么的？感觉上应该是限定的</p>
<p>然后就规定一下显式的操作说明吧：
参数容器的作用范围应该一样。一般地，参数(src_first, src_last,
dst_first)</p>
<p>自定义操作
有些算法要求使用者提供一个函数或函数对象作为自定义的操作条件，因为往往返回结果为false或true.
所以可以看作谓词。 Pred: 一元谓词，需要一个元素作为参数
BinPred:二元谓词，需要两个元素作为参数 eg: count_if(InIt first,InIt
last, Pred cond); &gt; 注意这里的默认参数，感觉上应该与vector<int>x,
这里的int, 即class相关。 即一元谓词，二元谓词的参数。对的！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;numeric&gt;</span><br><span class="line">accumulate() // 累积算法,返回值</span><br><span class="line">transform() // 变换，映射算法</span><br></pre></td></tr></table></figure>
<p>发现越到后面越有点像数据库的内容了。</p>
<ul>
<li>作业 STL算法应用——在学生容器中做统计 学生：name, sex, birth_place,
major 功能：init, sort, display, match_major. &gt;
match_major内容特别多，可以考虑用函数对象来做</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">利用函数对象来解决上面的问题</span><br><span class="line">class MatchMajor</span><br><span class="line">&#123;	   Major major;</span><br><span class="line">	public:</span><br><span class="line">	   MatchMajor (Major m)</span><br><span class="line">	   &#123;	major = m;</span><br><span class="line">	   &#125;</span><br><span class="line">	   bool operator ()(Student&amp; st)</span><br><span class="line">	   &#123; return st.get_major() == major;</span><br><span class="line">	   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">count_if(students.begin(),students.end(),</span><br><span class="line">			              MatchMajor(COMPUTER))；</span><br><span class="line">count_if(students.begin(),students.end(),</span><br><span class="line">			              MatchMajor(PHYSICS))；</span><br><span class="line">count_if(students.begin(),students.end(),</span><br><span class="line">			              MatchMajor(XXX))；</span><br><span class="line"></span><br><span class="line">// 扩展</span><br><span class="line"></span><br><span class="line">    bool operator ()(Student&amp; st)</span><br><span class="line">    &#123; return st.get_major() == major &amp;&amp; st.get_sex() == sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">count_if(students.begin(),students.end(),</span><br><span class="line">             MatchMajorAndSex(COMPUTER,FEMALE)) //计算机女生</span><br><span class="line"></span><br><span class="line">// lambda表达式</span><br><span class="line">count_if(students.begin(),students.end(),</span><br><span class="line">        [](Student &amp;st) &#123; return (st.get_major() == COMPUTER)</span><br><span class="line">			     &amp;&amp; (st.get_sex() == FEMALE); &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//统计出生地为&quot;南京籍计算机专业&quot;的学生人数</span><br><span class="line">cout &lt;&lt; &quot;出生地为\&quot;南京\&quot;的学生人数是：&quot; </span><br><span class="line">      &lt;&lt; count_if(students.begin(),students.end(),</span><br><span class="line">  [](Student &amp;st) &#123; return (st.get_major() == COMPUTER) </span><br><span class="line">          &amp;&amp; (st.get_birth_place().find(&quot;南京&quot;)!= string::npos);&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的思想很妙，但对象作为函数传递时，默认调用的就是A()，无参数的，所以此时就显示出了重载()运算符的好处</p>
<blockquote>
<p>当实体完全是为了存储数据使用的时候，此时就演化为了数据库这门课程</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/nju-course-cplus-lecture3-summary-6932a488cfa1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/nju-course-cplus-lecture3-summary-6932a488cfa1/" class="post-title-link" itemprop="url">nju-course-cplus-lecture3-summary</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:50:15" itemprop="dateCreated datePublished" datetime="2019-09-19T09:50:15+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">course</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/" itemprop="url" rel="index"><span itemprop="name">nju</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/cplus/" itemprop="url" rel="index"><span itemprop="name">cplus</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="操作符重载">操作符重载</h2>
<p>首先，不能考虑传统方法，即add，为什么？因为从某种意义上来讲极其不实用。</p>
<p>所以考虑重载操作符, 下列不能重载 . 标志作用域的 sizeof()
计算内存空间的 ?: 双判断的 :: 类的标志符</p>
<h3 id="一般地">一般地</h3>
<blockquote>
<p>全局友元函数和成员函数两种方式。
对比来说，也就是成员函数，默认前面有类.,
这其实是作为函数的默认参数this的，即const Complex&amp;</p>
</blockquote>
<p>那么就有一下几种操作符重载的例子，这里就只给出成员函数类型的
返回值、参数 - 双目 Complex opreator # (const Complex &amp;c) - 单目
Complex opreator *(); ++i; Complex &amp;opreator ++(); &gt;
前置++,返回运算后的结果。 i++; Complex opreator
++(int);//注意这里直接是int，没有变量名，只是为了区分。 &gt;
后置++，返回当前，实际+1；</p>
<hr />
<p>特别说明， 返回值的确定，当需要返回的是一个值得改变的值是用这个。
参数的确定 ****</p>
<h1 id="特殊地">### 特殊地</h1>
<blockquote>
<p>区分两种不同的含义，初始化时调用拷贝构造函数；赋值时重载函数、
都要注意默认的指针直接复制的问题</p>
</blockquote>
<p>[] &gt;很简单，类似于单目运算</p>
<p>new &gt; 分配空间+调用构造函数 &gt;
只能用静态成员来书写，static可以不用写 &gt; void <em>operator new(size_t
size) { void </em>p=malloc(size); // 调用系统堆空间分配操作
memset(p,0,size); //把系统申请到的堆空间初始化为全0 return p; }
返回类型必须为void *
参数size表示对象所需空间的大小，其类型为size_t（unsigned int） &gt;
可以选择带其他参数，此时就可以在非堆区分配空间 &gt; p = new
(buf局部变量) A(size);</p>
<p>delete &gt;</p>
<blockquote>
<p>从某种意义上说，new和delete可以提高效率。因为delete归还不是归还到堆区，而是归还原本new申请的空间.
进行空间管理</p>
</blockquote>
<p>() &gt; int opreator() (int x){return x+value;} A a(3);
cout&lt;&lt;a(10); &gt; 此时()将类对象作为了函数。有冒险用啊？ &gt;
比如新建一个随机数对象，初始化种子后random(1)，后面每需要一个随机数random()直接产生，很快！
&gt; ?,
这里跟函数对象有什么关系？这里是把类对象通过重载()作为函数使用</p>
<p>而函数对象，就是lambda表达式搞的是一大堆符号，然后后面跟一些参数。而也可以直接把它作为参数传递。</p>
<p>// 功能：求上下限为a,b的积分，步长假设为0.01 // 函数定义 double
integrate(double (*f)(double),double a,double b){ double sum=0;
for(double i=a; i&lt;=b; i+=0.01){ sum+=f(i); } return sum; }</p>
<p>// 使用：这里传入的函数对象是lambda表达式 integrate(<a
href="double%20x"></a>-&gt;double { return x*x; },0,1); &gt;
想想这真的可以做很多东西。</p>
<p>-&gt; 双目，第一个为指向类或结构的指针，第二个为第一个的成员 &gt;
例子：获取在程序执行的某个时刻获得某个对象被访问的次数 &gt;
注意，凡是成员对象，还有成员函数被访问都算，即暴露给外界可访问的东西。
对于成员函数很容易想到可以每个里面加上cout++;但是对于数据成员不好操作。
此时即智能指针 &gt;
想法即是在A类外部在套了个B类，B将A作为了成员，当接到访问时，
B-&gt;()-&gt;f(), 第二个才访问到A的内容， B-&gt;()。
为了完全模拟还要重载其他操作符，如*,[],... 太麻烦了！！
对于歧义问题即+这种操作符，一般地会进行隐式转化，但当有一方为类就很难，显式解决。</p>
<ul>
<li>lambda表达式</li>
</ul>
<blockquote>
<p>C++11给你规定了一堆东西，你可以拿去玩。其实也就是lambda函数那一章，其实后面还可以再加lambda表达式。最后再传递参数。</p>
</blockquote>
<p>所以就允许你用函数作为参数，其实这就很容易了。突然想起了scala.
而且lambda表达式还允许你加入局部变量之类的东西。</p>
<ul>
<li>继承</li>
</ul>
<p>提出就是为了最大程度的软件复用。
日常有多种行为，就是很小的改动的那种。
比如事务按层次来分类，对概念进行组合，软件进行增量开发等等</p>
<p>访问控制：自己，公开，继承。</p>
<p>继承破坏了封装性。 耦合性是事务之间的关联程度。</p>
<p>继承方式，过滤器</p>
<p>多态性：
子类又是父类；从某种意义上说，很强大。父类指针就可以随便用。</p>
<p>但又带来了问题了，可以随便用。但是肯定会指向自己，所以引进虚函数。允许指向未来更好的实现。
&gt; 高层代码完全不用修改。相比用union实现的。
于是有了纯虚函数，这就形成了真正意义上的抽象。</p>
<p>然后，还有聚集的方式。</p>
<p>总结：C++很好地用类进行数据的封装，保证了元素的私密性。
然后为了给外界提供一定的界限。 将数据的访问方式进行了分类。
对于获取信息的，外界全局函数就可以采用。const关键字很妙！
还有设置信息。</p>
<p>类作为类型。将不变的抽象给static元素。</p>
<p>然后，多态性。函数名，参数名。 再加上运算符号。</p>
<p>一对一并不完全符合世界的表述所以增加了多继承的方式。</p>
<p>然后再对类型的统一，最终就变为了泛型设计。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/nju-course-cplus-lecture3-7e25a3e3d0bf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/nju-course-cplus-lecture3-7e25a3e3d0bf/" class="post-title-link" itemprop="url">nju-course-cplus-lecture3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:49:11" itemprop="dateCreated datePublished" datetime="2019-09-19T09:49:11+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">course</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/" itemprop="url" rel="index"><span itemprop="name">nju</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/cplus/" itemprop="url" rel="index"><span itemprop="name">cplus</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="本节课重点">本节课重点</h1>
<h2 id="操作符重载">操作符重载</h2>
<p>比如对于复数来说，怎么实现加法？ - 成员函数add - 全局函数</p>
<p>不符合数学上的习惯</p>
<p>不可以重载的符号：“. ”， “.* ”，“?: ”，“:: ”，“sizeof ”</p>
<p>原则：不改变操作数个数，不改变原操作符的优先级和结合性。</p>
<p>双目操作符重载： <返回值类型> operator # (<类型>);
//#代表可重载的操作符 friend Complex operator + (const Complex&amp; c1,
const Complex&amp; c2);</p>
<p>单目操作符重载： <返回值类型> operator # (); friend bool operator
!(const Complex &amp;c);</p>
<p>Counter&amp; operator ++() //前置的++重载函数 { value++; return
*this; }</p>
<pre><code>const Counter operator ++(int)  //后置的++重载函数
    &#123;   Counter temp=*this; //保存原来的对象
        value++; //写成：++(*this);更好！调用前置的++重载函数
        return temp; //返回原来的对象
    &#125;</code></pre>
<ul>
<li>=重载 隐私的赋值操作符重载函数：组个成员进行赋值操作</li>
<li>对于普通成员进行常规的赋值操作。</li>
<li>对于成员对象，则调用该成员对象类的赋值操作符重载函数进行赋值操作</li>
<li>对于基类成员，则调用基类的赋值操作符函数进行赋值操作。</li>
</ul>
<p>特别注意地是，等号的情况是特别容易出错的情况。因为这里对指针的操作就是
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">	int a;</span><br><span class="line">	int b;</span><br><span class="line">	int *p;</span><br><span class="line">public:</span><br><span class="line">	A()&#123;&#125;; 构造函数</span><br><span class="line">	A(const A&amp;a); //拷贝构造函数</span><br><span class="line">	~A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A m,n;</span><br><span class="line">m=n;  // 实际上的操作就是 m.a=n.a, m.b=n.b, m.p=n.p. 最后一个就有问题了 </span><br></pre></td></tr></table></figure> &gt;
记住的就是拷贝构造函数和构造函数就是一样的，这里，不过参数不一样。拷贝构造函数参数是本身。
&gt; 赋值运算和</p>
<p>A&amp; operator = (const A&amp; a) { if (&amp;a == this) return
<em>this; //防止自身赋值。 delete []p; p = new char[strlen(a.p)+1];
//注意这里指针的赋值，首先删除原有的，然后，根据长度重新找，再赋值
strcpy(p,a.p); x = a.x; y = a.y; return </em>this; }</p>
<ul>
<li>[]重载 int &amp;operator<a href="int%20i"></a> //访问向量第i个元素。
{ return p_data[i]; }</li>
</ul>
<p>略去new, delete, ()， -&gt;的重载</p>
<ul>
<li>作业： 独立完成字符串的一系列动作。</li>
</ul>
<h2 id="lambda表达式">lambda表达式</h2>
<p>求定积分的函数：试图把函数作为参数。 C++11 double integrate(double
(*f)(double),double a,double b);</p>
<p>integrate(<a href="double%20x"></a>-&gt;double { return x*x;
},0,1);</p>
<ul>
<li>常用格式 [<环境变量使用说明>]<形式参数><返回值类型指定><函数体></li>
</ul>
<p><环境变量使用说明>：指出函数体中对外层作用域中的自动变量的使用限制：
空：不能使用外层作用域中的自动变量。
&amp;：按引用方式使用外层作用域中的自动变量（可以改变这些变量的值）。
=：按值方式使用使用外层作用域中的自动变量（不能改变这些变量的值）。
&amp;和=可以用来统一指定对外层作用域中自动变量的使用方式，也可以用来单独指定可使用的外层自动变量（变量名前可以加&amp;，默认为=）。</p>
<blockquote>
<p>理解：将lambda表达式看作是函数对象来实现 怎么用啊？需要找个例子 -
作用于实参 cout &lt;&lt; <a href="int%20x"></a>-&gt;int { return x<em>x;
}(3); - 传给其它函数 f(<a href="int%20x"></a>-&gt;int { return x</em>x;
}); // 这里依然不是很明朗，需要式子</p>
</blockquote>
<h2 id="继承-派生类">继承-派生类</h2>
<p>对事物按层次来分类，对概念进行组合，支持软件的增量开发。</p>
<p>继承的目的进行软件复用。 如何扩展？ 1、修改源代码。
2、继承。对一个面向对象的程序，在定义一个新的类时，把已有程序的一个或多个类的功能全部包含进来，然后再给出新功能的定义，或者重新定义。目标代码复用
派生类拥有除构造函数和赋值操作符重载函数外的所有成员
友元不能通过集成传递给派生类。 私有成员不能传递。
public-外界，即对象，实例， protected-面向继承 &gt; 继承和封装的矛盾</p>
<blockquote>
<p>protected的使用，用于今后不太可能发生变动的、有可能被派生类使用的、不适合对实例用户公开的成员声明</p>
</blockquote>
<blockquote>
<p>有个问题，既然private不能直接访问，那么复制过来又有什么用？按说明是需要复制过来
而且还占空间</p>
</blockquote>
<blockquote>
<p>如何是同名函数，则访问基类同名成员时要用基类名受限A::f()。但也可使用using
A::f;声明后直接使用</p>
</blockquote>
<blockquote>
<p>派生类的作用域大于基类的作用域</p>
</blockquote>
<blockquote>
<p>protected, 内部和子类，以及子类。而且是兼容的状态</p>
</blockquote>
<blockquote>
<p>父对象、子对象，对于包含的状态，可以允许</p>
</blockquote>
<blockquote>
<p>派生类对象，先初始化子对象 拷贝构造函数和赋值都是采用默认的形式</p>
</blockquote>
<p>实例：一个公司中的职员和部门经理类的设计</p>
<ul>
<li>分析 职员 工号、名字 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="多态性">多态性</h2>
<p>具有public继承关系的两个类，在C++中存在下面的多态： -
派生类对象的类型既可以是派生类，也可以是基类 -
基类的指针可以指向派生类或基类 &gt; 其实就是一个意思。 -
一个可以发送到基类对象的消息，也可以发送到派生类对象，怎么做到？缺例子？</p>
<p>由上面的知识可以带来消息的绑定问题。 &gt;
向基类的指针或引用所指向或引用的对象发送消息。</p>
<blockquote>
<p>问题：只要显式在参数中写定了基类还是父类，发现实际。</p>
</blockquote>
<ul>
<li>虚函数 virtual void f(){ }</li>
</ul>
<ol type="1">
<li>实现消息的动态绑定</li>
<li>指出基类中可以被派生类重定义的成员函数</li>
</ol>
<p>构造函数不能是虚函数，析构函数可以是虚函数。只要在基类中说明了虚函数，在派生类、派生类的派生类，同型购的成员函数都是虚函数
&gt;
意思是基类中将某个函数设置为虚函数，那么不管它继承到哪个位置，它将会一直是虚函数。</p>
<p>只有通过基类的指针或引用访问基类的虚函数时才进行动态绑定。</p>
<blockquote>
<p>当基类设置为纯虚函数后，之后的凡是基类指针，因为自身的函数设置为了虚函数。所以，它直接就指向了派生类的对象。</p>
</blockquote>
<p>何时需要定义虚函数？ &gt; 基类设计的不好，希望使用派生类。 &gt;
在基类中根本无法给出实现，子类往往会对应于不同的情况 （纯虚函数）</p>
<ul>
<li>纯虚函数 virtual int f()=0;
包含纯虚函数的类叫做抽象类，不能用于创建对象。
从某种意义上感觉像是接口的感觉。</li>
</ul>
<p>一般地，会把所有的函数都设置为纯虚函数，即 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Figure &#123;</span><br><span class="line">	public: </span><br><span class="line">		virtual void draw() const=0;  // 这里const是做何用的， 是注重返回值是定值吗？</span><br><span class="line">		&gt; 等下好像前面加了const, 是就限制了不能改变元素。所以，外部的全局函数就可以直接使用</span><br><span class="line">		virtual void input_data()=0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般的应用 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- 图形的输入</span><br><span class="line">for (count=0; count&lt;MAX_NUM_OF_FIGURES;	count++)</span><br><span class="line">&#123;	int shape;</span><br><span class="line">	do</span><br><span class="line">	&#123;	cout &lt;&lt; &quot;请输入图形的种类(0：线段，1：矩形，2：圆，-1：结束)：&quot;;</span><br><span class="line">		cin &gt;&gt; shape;</span><br><span class="line">	&#125; while (shape &lt; -1 || shape &gt; 2);</span><br><span class="line">	if (shape == -1) break;</span><br><span class="line">	switch (shape)</span><br><span class="line">	&#123;	case 0: //线</span><br><span class="line">			figures[count] = new Line;	break;</span><br><span class="line">		case 1: //矩形</span><br><span class="line">			figures[count] = new Rectangle; break;</span><br><span class="line">		case 2: //圆</span><br><span class="line">			figures[count] = new Circle; break;</span><br><span class="line"> 	&#125;</span><br><span class="line">	figures[count]-&gt;input_data(); //动态绑定到相应类的input_data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- 图形的输出</span><br><span class="line">for (int i=0; i&lt;count; i++)	</span><br><span class="line">	figures[i]-&gt;draw();  </span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>此时可以看出，代码完全不需要改动。只需要将类的实现进行改变而已，很好地提高了效率。</p>
<p>考虑一种低效的实现方式，即使用union来做，可以发现，当增加新的图形种类是，需要修改下述代码，增加分支
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">图形数据的输入：</span><br><span class="line">	int count;</span><br><span class="line">	for (count=0; count&lt;MAX_NUM_OF_FIGURES; count++)</span><br><span class="line">	&#123;	int shape;</span><br><span class="line">		do</span><br><span class="line">		&#123;	cout &lt;&lt; &quot;请输入图形的种类(0:线段,1:矩形,2:圆,-1:结束):&quot;;</span><br><span class="line">			cin &gt;&gt; shape;</span><br><span class="line">		&#125; while (shape &lt; -1 || shape &gt; 2);</span><br><span class="line">		if (shape == -1) break;</span><br><span class="line">		figures[count] = new TaggedFigure; //空间利用效率不高！</span><br><span class="line">		switch (shape)</span><br><span class="line">		&#123; 	case 0: //线</span><br><span class="line">				figures[count]-&gt;shape = 0;</span><br><span class="line">				input_data(figures[count]-&gt;figure.line);</span><br><span class="line">  	 			break;</span><br><span class="line">			case 1: //矩形</span><br><span class="line">				figures[count]-&gt;shape = 1;</span><br><span class="line">				input_data(figures[count]-&gt;figure.rect);</span><br><span class="line"> 				break;</span><br><span class="line"> 		  case 2: //圆形</span><br><span class="line">				figures[count]-&gt;shape = 2;</span><br><span class="line">				input_data(figures[count]-&gt;figure.circle);</span><br><span class="line">  	 		break;</span><br><span class="line">	 	&#125; //end of switch</span><br><span class="line">	&#125; //end of for</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">图形的输出：</span><br><span class="line">	for (int i=0; i&lt;count; i++)</span><br><span class="line">	&#123;	switch (figures[i]-&gt;shape)</span><br><span class="line">			&#123; case 0:</span><br><span class="line">						draw(figures[i]-&gt;figure.line);</span><br><span class="line">						break;</span><br><span class="line">				case 1:</span><br><span class="line"> 						draw(figures[i]-&gt;figure.rect);</span><br><span class="line">						break;</span><br><span class="line">				case 2:</span><br><span class="line"> 						draw(figures[i]-&gt;figure.circle);</span><br><span class="line"> 						break;</span><br><span class="line"> 			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>作业：用抽象类为栈的两个不同实现提供一个公共接口</p></li>
<li><p>使用抽象类给类提供一个抽象接口 &gt;
感觉上真的，抽象类实现真正意义上的抽象。</p></li>
</ul>
<p>class I_A{ public: virtual void f(int)=0; };</p>
<p>void func(I_A *p) { p-&gt;f(2); //
这里不知道p所指向的对象有哪些数据成员，因此无法访问它的数据成员。而且保证了类的封闭性。
}</p>
<blockquote>
<p>从某种意义上感觉对事件机制有了进一步的理解。
所有都由一个父类继承而来。而虚函数所定义的就是信号，就可以看作基类指针，完全不知道到底派生类的谁会接收它。</p>
</blockquote>
<p>代码复用的另一种方式——聚集
继承实际就是把一个类的代码复制到另一个类中来实现，具有继承关系的两个类之间通常属于一般与特殊的关系。
继承不是代码复用的唯一方式，有些代码复用不宜用继承来实现。如：“飞机”类复用“发动机”类。</p>
<p>具有聚集关系的两个类之间通常属于整体与部分的关系。</p>
<blockquote>
<p>访问控制仿佛如同一种过滤器一样；只能过滤到和当前一样的结果。
private只对自己使用。 protected针对继承元素。</p>
</blockquote>
<blockquote>
<p>之前就一直在想一个问题，可能让你一直继承下去吗？我这个世界可不想你做这些东西？
实际社会上还会存在哪些要求呢？</p>
</blockquote>
<blockquote>
<p>实际上来说的话，那么当一个类使用了private继承就是想不要再被其他继承下去。继承下去有毛线用，你又访问不到，所以说啊，你还不如好好使用的，有什么意思，对吧！
顶多是你可以.后再加上A::的作用域进行访问。如f()是A的private成员，对于B继承A，访问f()即为<code>b.A::f()</code></p>
</blockquote>
<p>继承与封装存在矛盾，聚集则否。
继承提供两种接口，而对于聚集，一个类对外只需提供一个接口</p>
<h3 id="多继承">多继承</h3>
<p>如何实现？ -
采用单继承，概念混乱，导致A和B之间增加了层次关系。易造成不一致。 -
聚集，不能实现子类型</p>
<p>顺序 class C: public A, public B{} 即按照继承的声明方式。</p>
<p>对于基类的指针会自动进行地址调整，也就是自动指向对应的存储空间。
函数名混淆，采用基类名限制。</p>
<p>重复继承问题，原本设置不对，应该把重复继承的部分设置为基类。</p>
<p>一种新的方式： class A{ int x; public: A(int i){x=i;} }</p>
<p>class B:virtual public A{ // 注意没？这里出现了虚拟继承的概念 int y;
}</p>
<p>间接包含虚基类的类：</p>
<p>虚基类的构造函数由该类的构造函数直接调用。（即虚基类的构造函数由最新派生出的类的构造函数调用）
虚基类的构造函数优先非基类的构造函数执行。</p>
<p>虚基类的实现其实比较复杂，并不是没有它了。而是将x移到最后，在原本x的位置存储了一个x的偏移量指针。</p>
<p>非纯虚基类，就是有自己的实现。但是允许你去用派生类的。因为自己做不好的原因。
### todo</p>
<ul>
<li>从上面的过程话说设计模式</li>
</ul>
<blockquote>
<p>那么这个世界的组织形式是什么？
分离，谁是谁的什么，还有或者谁组成了谁</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/nju-course-cplus-lecture2-summary-357b5a9efb7d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/nju-course-cplus-lecture2-summary-357b5a9efb7d/" class="post-title-link" itemprop="url">nju-course-cplus-lecture2-summary</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:47:59" itemprop="dateCreated datePublished" datetime="2019-09-19T09:47:59+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">course</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/" itemprop="url" rel="index"><span itemprop="name">nju</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/cplus/" itemprop="url" rel="index"><span itemprop="name">cplus</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>重点</p>
<ol type="1">
<li>抽象和封装 &gt;
抽象是外，封装是里；为什么好？栈举例，直接来，没有函数封装；结构体+函数封装，数据隐私问题，成员仍可被破坏。</li>
</ol>
<p>一个重要的问题：加访问控制 public, private(默认),protected</p>
<p>面向对象：类型和对象。程序若干个对象。对象之间关系，一是继承，传承特征；对象之间靠接口，公有函数的参数或友元来维持关系。</p>
<p>设计几大理念： 1. 抽象，控制住底层的复杂度 2.
封装，同上，侧重隐藏信息 3. 模块化，抽象封装是单个，模块化则是对整个而言
4. 软件复用：可复用的东西变得更多 5. 可维护性：代码框架灵活 6.
软件模型的自然度：能对应于问题空间</p>
<p>面向过程：过程即功能，特定功能集合，没有对象的概念。所有的东西会乱成一团。复用性差，太特殊</p>
<ol start="2" type="1">
<li>面向过程</li>
</ol>
<p>类型 对象（动态）</p>
<p>系统向一个对象通信(即只调用一个对象的接口).然后不定地解决问题。 &gt;
不过是类的问题。</p>
<ol start="3" type="1">
<li>特性：多态</li>
</ol>
<p>函数名，类型。</p>
<p>父类对象继承子类: 子类可以有两个选择 父类指针可以有两个指向
消息可以有多种发送选择</p>
<p>访问控制的建议 内部的东西private,
比如类的数据成员，类内部使用的成员函数。</p>
<p>调用未定义的类，指针+引用</p>
<p>对象，动态和静态、全局和局部。</p>
<ol start="4" type="1">
<li>使用对象</li>
</ol>
<ul>
<li><p>赋值</p></li>
<li><p>参数 const A &amp;</p></li>
<li><p>返回值</p></li>
<li><p>this</p></li>
<li><p>对象初始化，常量和引用一般不让初始化</p></li>
<li><p>构造函数和析构函数对应。</p></li>
<li><p>成员对象，拷贝构造函数</p></li>
<li><p>静态成员对象</p></li>
<li><p>f(const Data&amp; d){}, 然后 类的对象就分为两种：获取对象状态
const,外界元素均可访问，也要通过类的对象来操作，不够对应2那种参数可以进行使用；改变对象状态，需要类的对象来进行操作。
&gt; 换言之，是为常量对象而准备的</p></li>
<li><p>友元，不具有对称性和传递性，可以是类，全局函数或者类的成员函数（都行）。
&gt; 具体时间差没测试。效率上会消失多少？</p></li>
<li><p>类作为单独的模块，降低耦合。成员函数只向有限个元素发送。</p></li>
<li><p>作业：用类来实现矩阵和向量类型 矩阵：数据、行数、列数。
外界的获取接口：</p></li>
<li><p>获得行数和列数，int&amp; element(int x, int y),
这样是否可以通过地址来修改元素的值呢？ <code>m.element(1,2) =
m.element(1,2) + 1</code>, 不过说到底也是对的啊，进行的是值替代,
而这也是符合引用的定义的啊。</p></li>
<li><p>操作函数，对元素进行操作</p></li>
<li><p>构造函数: 对元素和空间进行检查。</p></li>
</ul>
<blockquote>
<p>注意：凡是函数，一定要记得对函数的输入数据进行检查和核对。</p>
</blockquote>
<p>向量：数据、维数。</p>
<ul>
<li>附录：补充 &gt; cout与cerr:
几次都遇到这种情况，不过我想今天应该明了。cout是控制台输出，当遇到endl，就不再缓冲，直接把数据输出。
cerr在命令行下， linux下命令行截取的是cerr,
1&gt;&gt;log输出的是控制台，2&gt;&gt;输出的是错误信息</li>
</ul>
<blockquote>
<p>缓冲，刷新的概念，集中输出，防止刷屏。可以看到缓冲好的数据，生活中有很多这样的例子。比如，电视机显式，等一段画面到来时再显示图像。
注意指针和实体数组，对于指针单位长度和数组元素一样。然后，new开辟的空间只能用指针来做。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/nju-course-cplus-lecture2-aef72747c4c1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/nju-course-cplus-lecture2-aef72747c4c1/" class="post-title-link" itemprop="url">nju-course-cplus-lecture2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:46:53" itemprop="dateCreated datePublished" datetime="2019-09-19T09:46:53+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">course</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/" itemprop="url" rel="index"><span itemprop="name">nju</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/cplus/" itemprop="url" rel="index"><span itemprop="name">cplus</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="本节课重点">本节课重点</h1>
<h2 id="抽象和封装">1. 抽象和封装</h2>
<ul>
<li>抽象:
数据的使用者只需要知道数据能实施的操作以及这些操作之间的关系，不必知道数据的具体表示形式。</li>
<li>封装：将数据及其操作作为一个整体来进行实现。数据的具体表示对使用者是不可见的，对数据的访问只能通过封装体所提供的对外接口来完成。</li>
<li>案例
比如，栈的使用，首先不能直接在程序中定义，一不小心手误就会出错；其次，采用面向过程的想法：
struct Stack{}; void push(Stack &amp;s); 当我在其他地方定义一个void
f(Stack &amp;s),
会破坏Stack的数据；数据表示仍是公开的，可以对数据进行操作。</li>
</ul>
<p>所以引入面向对象。 public对外的接口， private隐藏的内容，外不可见
protect面向继承</p>
<p>把程序构造成由若干个对象组成，每个对象是由一些数据以及对这些数据所能实施的操作构成的封装体。
一个雷所描述的对象的特征可以继承。 &gt;
这里特征指private中的成员。对象所定义的操作即是其接口</p>
<h2 id="面向对象程序的执行过程">2. 面向对象程序的执行过程</h2>
<p>对象构成了面向对象程序的基本计算单位
对象间的消息传递是引起面向对象程序进行计算的唯一形式。 &gt;
从程序外部向程序中的某个对象发送第一条消息标志着程序的开始。该对象在处理这条消息的过程中又向其他对象发送消息，引起进一步的计算。当第一条消息处理结束后则程序的一次计算结束。消息处理可以分为同步和异步，这里显然只涉及到同步。</p>
<h2 id="对比">3. 对比</h2>
<p>提高软件开发效率和保证软件质量的几个基本程序设计手段 -
抽象（复杂度控制） - 封装（信息隐藏） - 模块化（组织大型程序） -
软件复用（延长开发周期） - 可维护性（延长软件寿命） -
软件模型的自然渡（缩小解题空间与问题空间的语义间隙） &gt;
最后一个方面可以思考到，实际上求解问题都可以划分各个状态。即通过状态空间来解题，所以可以看出来基于对象/类的解题方式与问题空间有很好的对应。</p>
<blockquote>
<p>面向过程是什么？强调的是过程即功能，数据和操作分离，数据没有保护，功能特定限定不可扩展。最后，与问题空间没啥关系。
最大的高手是能说出一堆东西还能找到准确的分类。</p>
</blockquote>
<h2 id="面向对象的基本内容">4. 面向对象的基本内容</h2>
<p>对象-值，类-类型。 多态：某一论域中的一个元素存在多种解释： -
一名多用：函数名、操作符重载 - 类属性： -
一函数可以对多种类型数据进行操作？ - 一个类型可以描述多种类型的数据</p>
<p>绑定：确定对多态元素的某个使用是多态元素的哪种形式？ - 静态绑定 -
动态绑定</p>
<p>面向对象程序特有的多态（继承） 1. 对象类型的多态:
子类对象可以属于子类，也可以属于父类 2.
对象标识的多态：父类的引用或指针可以引用或指向父亲对象，也可子类对象 3.
消息的多态：发给的消息可以发给子类，即，一个消息可以有多种解释（父类与子类有不同解释）</p>
<p>多态带来的好处： - 易于实现程序高层代码的复用 ？ -
使得程序扩充变得容易（只要增加底层的具体实现） -
增强语言的可扩充性（操作符重载）</p>
<h4 id="类">类</h4>
<p>对象构成了面向对象的基本计算单位，而对象的特征则是由相应的类来描述。因此，程序中首先要定义类。
注意：在C++中，也允许在结构和联合中定义函数，但成员的访问控制与类不同。
&gt; 结构和联合的成员默认为public,是否可以改我不知道？</p>
<p>访问控制就是public,private,protected.</p>
<p>public:公开 private:本类和友元的代码中访问，默认方式
protected:只能在本类、派生类和友元的代码中访问 &gt;
友元函数什么意思？</p>
<p><strong>访问控制设置的建议</strong> 1.
类的数据成员和在类的内部使用的成员函数应该指定为private,只有提供给外界使用的成员函数才指定为public.
具有public访问控制的成员构成了类与外界的一种接口，在一个类的外部只能访问该类接口中的成员</p>
<p><strong>数据类型定义时的注意</strong> 1.
在说明一个数据成员的类型时，如果未见到相应类型的定义，或相应的类型未定义完，则该数据成员的类型只能是这些类型的指针或引用类型。
&gt;
因为实际类型是无法解释代码的。而指针类型是现在符号表中定义，然后再寻找答案的。</p>
<ol start="2" type="1">
<li>成员函数的实现可在内外定义，在内外定义要用类名受限，区别于全局函数。</li>
<li>类成员函数名是可以重载的，它遵循一般函数名的重载规则。</li>
</ol>
<h4 id="对象">对象</h4>
<p>对象是动态运行中构造，类型是静态的形式。</p>
<p>对象可以分为全局对象、局部对象和成员对象？</p>
<hr />
<p>对象创建的两种方式 - 直接，实体变量，使用实体，在静态区或栈中 &gt;
静态区好像不可能？ 前面不说了吗？是这个意思吗？ - 间接，动态，使用指针
在堆中 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A *p;</span><br><span class="line">p=new A;  //创建</span><br><span class="line">*p,  p-&gt;  </span><br><span class="line">delete p;</span><br><span class="line"></span><br><span class="line">A *q;</span><br><span class="line">q=new A[100];</span><br><span class="line">q[i]   // *(q+i)</span><br><span class="line">delete []q;</span><br></pre></td></tr></table></figure> ****</p>
<ul>
<li><p>使用参数进行赋值
同类型一样，同类对象可以进行赋值，取对象地址之类的事情 <code>Data
b;</code></p></li>
<li><p>使用对象作为参数
使用对象做实参，不想函数在调用是创建一个大的元素又不想被修改 const Data
&amp;d &gt; 感觉上参数实际上就是一个地址</p></li>
<li><p>使用对象作为返回值 &gt;
务必注意一个事，如果想返回的是一个新对象返回值用Data；否则容易把参数中，原本函数中的值给改变。最重要的是自己到底是想还是不想被改变</p></li>
<li><p>每个对象，this指针 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 面向对象编程</span><br><span class="line">class A&#123;</span><br><span class="line">    public:</span><br><span class="line">        void g(int i)&#123;</span><br><span class="line">            x=i;</span><br><span class="line">            // 相当于this.x=i;</span><br><span class="line">        &#125;</span><br><span class="line">    private:</span><br><span class="line">        int x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 面向过程编程</span><br><span class="line">struct A&#123;</span><br><span class="line">    int x;</span><br><span class="line">&#125;</span><br><span class="line">void g(A *const this,int i)&#123;</span><br><span class="line">    this-&gt;x=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.g(1); 等价于 g(&amp;a,1);</span><br></pre></td></tr></table></figure> &gt;
突然想到了，Python中编程，当初想要将 pub(x,y)变为x(y)的过程？
具体怎么做还得看一下相关书上的东西。</p></li>
</ul>
<hr />
<ul>
<li>对象初始化 特有的东西，init(), 自动被调用，很好！ 可重载 动态数组
默认 A(); 常量和引用不能被初始化,为什么？ &gt;
一旦被赋值了，那对象还要它干什么</li>
</ul>
<p>初试话顺序按类定义顺序，很显然</p>
<p>在构造函数中开辟的空间需要自己在析构函数中解决，特别是动态申请的空间。</p>
<ul>
<li>成员对象 数据成员可以是另一个类 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;   int x;</span><br><span class="line">   public:</span><br><span class="line">	 A() &#123; x = 0; &#125;</span><br><span class="line">	 A(int i) &#123; x = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B</span><br><span class="line">&#123;   A a;</span><br><span class="line">     int y;</span><br><span class="line">   public:</span><br><span class="line">	  B() &#123; y = 0;&#125; //调用A的默认构造函数对a初始化。</span><br><span class="line">     B(int i) &#123; y = i; &#125; //调用A的默认构造函数对a初始化。  </span><br><span class="line">     B(int i, int j): a(j) &#123; y = i; &#125; //调用A(int)对a 初始化。  </span><br><span class="line">&#125;;</span><br><span class="line">B b0; //b0.y初始化为0，b0.a.x初始化为0</span><br><span class="line">B b1(1); //b1.y初始化为1，b1.a.x初始化为0</span><br><span class="line">B b2(1,2); //b2.y初始化为1，b2.a.x初始化为2</span><br></pre></td></tr></table></figure></li>
</ul>
<p>析构的顺序跟执行顺序相反。 &gt; 容易想到，析构函数
先调用本身类，再调用成员对象 &gt; 应用场景：复杂的窗口调用关系时</p>
<ul>
<li>拷贝构造函数 <code>A(const A&amp;a)&#123;&#125;</code> ！ &gt;
正如其名，在需要拷贝，即值传递的时候用到 &gt;
比如说，构造函数就自定义的，那么拷贝构造函数？ &gt;
?默认构造函数是什么？-&gt; 隐式拷贝构造函数</li>
</ul>
<p>对于隐式拷贝构造函数： 1. 非对象成员逐个赋值 2.
对象成员优先选择构造函数，否则隐式 &gt;
这里注意，当成员构造函数中申请了一片空间，可能会同时指向一片空间</p>
<blockquote>
<p>p=new int[5];
这样会指向一个空间吗？首先，要看它的第一步动作，如果是</p>
</blockquote>
<p>对于自定义拷贝构造函数，注意成员对象默认构造函数，否则显式指定</p>
<blockquote>
<p>这里比较麻烦， 1. 定义对象 <code>A a，b; b=a;</code> 2.
对象作为值参数和返回值</p>
</blockquote>
<ul>
<li>const</li>
</ul>
<p>void f(const Date&amp; d){ d.get_day();
//不可以，无法知道实际上是否进行了数据成员改变，所以统一禁止 }</p>
<p>因此，将类的成员函数分为两类： - 获取对象状态 int get_day() const {};
//不能改变数据成员的值， 这下f中d.get_day()ok了 - 改变对象状态</p>
<hr />
<ul>
<li>同类对象共享数据（全局变量不行，不安全！） &gt; 问题如何引出？
static还有什么用？</li>
</ul>
<blockquote>
<p>采用静态对象，类直接可以获取。static int x; void f() {x++; } //
工厂模式，进行计数， 类可直接访问，只有一个备份
应用：实现对某类对象的计数</p>
</blockquote>
<ul>
<li>静态成员函数 静态成员函数只能访问类的静态成员。
静态成员函数没有隐藏的this &gt;
静态都可以通过对象和类两种方式来访问</li>
</ul>
<blockquote>
<p>在一些“纯”面向对象程序设计语言中，把类看作对象，用元类(meta
class)来描述. 静态成员属于“类对象”</p>
</blockquote>
<ul>
<li>友元 &gt; 暴露的一个超级大的接口，为了应对其他方面的不足。 &gt;
目的是为了提高在类的外部对类的数据成员的访问效率。</li>
</ul>
<p>友元可以是全局函数、其它的类或其它类的某些成员函数。 class A { ? //
感觉是public friend void func(); friend class B; friend void C::f();
private: int x; }</p>
<p>友元关系具有不对称性。 友元也不具有传递性
友元是数据保护和数据访问效率之间的一种折中方案</p>
<p>todo 用类来实现矩阵和向量类型 multipy的实现</p>
<p>类作为模块 - 类是一个自然的模块划分单位 - .h文件中存放的是类的定义 -
.cpp文件中是类成员函数的实现</p>
<p>一个模块一般有两个文件</p>
<blockquote>
<p>耦合性：模块与模块之间的依赖关系</p>
</blockquote>
<p>过程： 结构式</p>
<p>面向对象：降低耦合</p>
<blockquote>
<p>Demeter法则，一个类的成员函数除了访问自身类结构的直接子结构外，不能以任何方式依赖于任何其他类的结构。
每个成员函数只应向某个有限集合中的对象发送消息。
仅与你的直接朋友联系。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/nju-course-cplus-lecture1-summary-b9ef6f076085/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/nju-course-cplus-lecture1-summary-b9ef6f076085/" class="post-title-link" itemprop="url">nju-course-cplus-lecture1-summary</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:45:52" itemprop="dateCreated datePublished" datetime="2019-09-19T09:45:52+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">course</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/" itemprop="url" rel="index"><span itemprop="name">nju</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/cplus/" itemprop="url" rel="index"><span itemprop="name">cplus</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>静态数据区：全局变量、static存储类的局部变量以及常量的内存分配；
extern int x; 引用其他文件的全局变量，注意初始值。 使用说明：
尽量使用本地变量static; 全局变量赋初始值；外部全局变量使用extern.</p>
</blockquote>
<h1 id="上节课重点回顾">上节课重点回顾</h1>
<ol type="1">
<li>程序=算法+数据结构</li>
<li>代码区和栈区(普通局部变量)、堆区(malloc使用的变量)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//file1.cpp</span><br><span class="line">int a=1;</span><br><span class="line"></span><br><span class="line">//file2.cpp</span><br><span class="line">extern int a; //</span><br><span class="line">int main()&#123;</span><br><span class="line">    a=100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new同malloc, 分配的变量在堆区中</span><br></pre></td></tr></table></figure></li>
<li>再理解循环，
以及递归调用。实际执行（中序遍历）。循环,退出条件。多种情况，基本及其他。返回值，参数忌大值
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for( ; ; )</span><br><span class="line">共享全局变量</span><br><span class="line"></span><br><span class="line">int recursion(int a) &#123;</span><br><span class="line">    if(a in basic) solve;</span><br><span class="line">    else &#123;</span><br><span class="line">        recursion(a/2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>引用，名字。指针，链表 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">int f(int *b)&#123;</span><br><span class="line">    int c=3;</span><br><span class="line">    *b=c; // 在b未改变指向的地址之前做赋值。能够赋值成功</span><br><span class="line">    b=&amp;c; // 这样操作没什么用，如果返回b的值可能变了。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    int a=1;</span><br><span class="line">    inf *b=a; // 这里初始化等价于int *b; b=&amp;a;</span><br><span class="line">    f(&amp;b); // 1-&gt;3</span><br><span class="line">&#125;</span><br><span class="line">// 指针没有那么恐怖，主要是看在哪定义的，即作用范围。如函数类以及参数，那么作用范围只不过是函数内而已。</span><br><span class="line"></span><br><span class="line">int g(int &amp;x)&#123;</span><br><span class="line">    int m=1;</span><br><span class="line">    x=&amp;m // 错误</span><br><span class="line">    x=m; //这里附带着就把原值给改变了</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    int a;</span><br><span class="line">    g(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对于数组，同指针一样。指针就理解为链表，当选进去之后，出来还是首地址，但是该改变的都改变了</span><br><span class="line">void fun(int a[])&#123;</span><br><span class="line">    a[1]=1;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int a[]=&#123;1,2&#125;;</span><br><span class="line">    fun(a);</span><br><span class="line">    cout&lt;&lt;a[1]; // 1</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>序列数据的表示，数组，链表，更多 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组 int a[N];</span><br><span class="line">单位长度 a+i*sizeof(int)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>链表
<ul>
<li>重新分配</li>
<li>访问元素，顺序，值</li>
<li>增加元素</li>
<li>删除元素 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">file1.h</span><br><span class="line">struct Node&#123;</span><br><span class="line">    int content;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">不带头结点的单链表</span><br><span class="line">这里首先设计的就不合理。</span><br><span class="line"></span><br><span class="line">Node* find(Node *head,int i)&#123; </span><br><span class="line">    //？这里参数和返回值的类型</span><br><span class="line">    if(!i) return head;</span><br><span class="line">    else&#123;</span><br><span class="line">        //访问</span><br><span class="line">        Node *p=head;</span><br><span class="line">        int j=0;</span><br><span class="line">        while(p!=NULL &amp; j&lt;i)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p!=NULL) return p;</span><br><span class="line">        else return NULL; // 表示未找到</span><br><span class="line">        // return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* findByValue(Node* head,int value)&#123;</span><br><span class="line">    if(head.content==value) return head;</span><br><span class="line">    else&#123;</span><br><span class="line">        Node *p=head;</span><br><span class="line">        while(p!=NULL&amp;p-&gt;content!=value)</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool insert(Node *head, int value, int i) &#123; // 按所给的位置i插入value，不用返回值。</span><br><span class="line">    Node *q, *p; // 数组才需要new, 单个变量应该不需要。而且新定义的结构体也应该没有被定义在系统内吧</span><br><span class="line">    *p=head;</span><br><span class="line">    q-&gt;content=value;</span><br><span class="line">    if(i=0) &#123; // 注意这里是没有头结点的情况</span><br><span class="line">        q-&gt;next=p;</span><br><span class="line">        head=q;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        while(p!=NULL &amp; i-1)&#123; // 从0开始, 注意是找前一个</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p==NULL) &#123;</span><br><span class="line">            delete q;</span><br><span class="line">            q=nullptr;</span><br><span class="line">            // q使用结束后，将其赋值为空。防止多次delete,还有后续使用</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            q-&gt;next=p-&gt;next;</span><br><span class="line">            p-&gt;next=q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delete p,q;</span><br><span class="line">    p=nullptr;</span><br><span class="line">    q=pullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void deleteP(Node *head, int value, int i) &#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    if(i==0)&#123;</span><br><span class="line">        p=head-&gt;next;</span><br><span class="line">        head=p;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        while(p!=NULL &amp; i-1)&#123; // 从0开始, 注意是找前一个</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        Node *q=p-&gt;next; // 如果是最后一个也没关系，不过指向空而已</span><br><span class="line">        p-&gt;next=q-&gt;next;</span><br><span class="line">        delete p,q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Node q; q.content</span><br><span class="line">// Node *q; q-&gt;content </span><br><span class="line">// 猜想是对的，箭头左边是指针；点号左边是实体</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>命令
<ul>
<li>include <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">路径搜索策略:</span><br><span class="line">1. 当前目录</span><br><span class="line">2. 参数-L指定的目录</span><br><span class="line">3. gcc的环境变量CPLUS_INCLUDE_PATH</span><br><span class="line">4. gcc的内定目录</span><br><span class="line">gcc -E -v --prefix=..</span><br><span class="line">prefix/include</span><br><span class="line">prefix/local/include</span><br><span class="line">prefix/lib/gcc/--host/-version/include</span><br><span class="line"></span><br><span class="line">#include&lt;a.h&gt;</span><br><span class="line">从第2步开始</span><br><span class="line">#include &quot;a.h&quot;</span><br><span class="line">从第1步开始</span><br></pre></td></tr></table></figure></li>
<li>define <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define MAX(a,b) ((a)&gt;(b))?(a):(b)</span><br><span class="line">#define M 100</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>ifdef, if <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">file1.h</span><br><span class="line">#define ABC</span><br><span class="line">int a;</span><br><span class="line">void fun();</span><br><span class="line"></span><br><span class="line">file1.cpp</span><br><span class="line">#include &quot;file1.h&quot;</span><br><span class="line">void fun()&#123;</span><br><span class="line">    a=1;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file2.h</span><br><span class="line">#ifdef ABC</span><br><span class="line">    int b;</span><br><span class="line">#else</span><br><span class="line">    int a;</span><br><span class="line">    fun();</span><br><span class="line">#endif</span><br><span class="line">    int c;</span><br><span class="line"></span><br><span class="line">file2.cpp</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yun-Pan Wang"
      src="/images/default-avatar.png">
  <p class="site-author-name" itemprop="name">Yun-Pan Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">115</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AugF" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AugF" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wangyp@smail.nju.edu.cn" title="E-Mail → mailto:wangyp@smail.nju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/Joswxe" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;Joswxe" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.google.com/" title="https:&#x2F;&#x2F;www.google.com" rel="noopener" target="_blank">Google</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://cn.bing.com/" title="https:&#x2F;&#x2F;cn.bing.com" rel="noopener" target="_blank">Bing</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">Baidu</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">[object Object]</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">466k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:04</span>
</div>!

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://ypwang.github.io/page/7/',]
      });
      });
  </script>



</body>
</html>
