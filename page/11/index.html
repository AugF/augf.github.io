<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ypwang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Life&#39;s Notes">
<meta property="og:url" content="https://ypwang.github.io/page/11/index.html">
<meta property="og:site_name" content="Life&#39;s Notes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yun-Pan Wang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ypwang.github.io/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Life's Notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Life's Notes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">岁月数载，愿不负韶华</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/algorithm-acwing-improve-6d207cf48427/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/algorithm-acwing-improve-6d207cf48427/" class="post-title-link" itemprop="url">algorithm acwing improve class</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-16 14:57:57" itemprop="dateCreated datePublished" datetime="2019-09-16T14:57:57+08:00">2019-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/" itemprop="url" rel="index"><span itemprop="name">acwing</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/improve/" itemprop="url" rel="index"><span itemprop="name">improve</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概览">1. 概览</h2>
<ol type="1">
<li>算法学习分为这几类：
<ul>
<li>level 1 语法课, 直接题库搜索"语法课"即可进行练习 &gt;
https://www.acwing.com/problem/search/1/?csrfmiddlewaretoken=msUJJ5LtxRvIldBlsslvchYSw8Grn8UdIM32F2WtpNs1WitNTjsvLznTVFof8cW2&amp;search_content=%E8%AF%AD%E6%B3%95%E9%A2%98</li>
<li>level 2 算法基础课</li>
<li>level 3 算法提高课 算法的应用
<ul>
<li>题目--&gt; 模型 ---&gt;
相似的题目(因为整理的人太少，所以这里暂时以题目为主) 题谱</li>
</ul></li>
</ul></li>
<li>算法题考查两部分的内容：
<ol type="1">
<li>思维</li>
<li>写代码的熟练度</li>
</ol></li>
<li>非常好的网站: 衡阳七中 &gt; 看延迟，直接看时间就可以了</li>
</ol>
<h2 id="dp">2. DP</h2>
<h3 id="数字三角形">2.1 数字三角形</h3>
<ol type="1">
<li>basic
<ul>
<li>采花生问题 &gt; 从集合角度来考虑问题,
一个集合就代替了暴搜中的一个元素
<ul>
<li>状态表示 f[i, j]
<ul>
<li>集合： 所有从(1, 1)走到(i, j)的路线</li>
<li>属性： Max/Min/数量： 集合中所有集合的每个元素的最大值； &gt;
于是f(n, m)就是目标值; 计算该值实际上就是寻找一个拓扑排序</li>
</ul></li>
<li>状态计算： 集合划分 分而治之 &gt; 依据最后一步来划分
<ul>
<li>划分依据
<ul>
<li>不重复（最值无所谓，数量必须要）</li>
<li>不漏（所有的都必须考虑） &gt; 本题图的连通性</li>
</ul></li>
</ul></li>
</ul></li>
<li>最低通行费： 最大值往往不需要初始化，最小值需要进行考虑</li>
</ul></li>
<li>improve
<ul>
<li>方格取数：难点在于如何考虑走两次
<ul>
<li>走两次： 同时走 &gt; f[i1, j1, i2, j2]表示所有从(1,1),
(1,1)分别走向(i1,j1),(i2,j2)的路径的最大值。
<ul>
<li>如何处理“同一个格子不能被重复选择” &gt;
只有在i1+j1=i2+j2时，两条路径的格子才可能重合；一开始考虑使用f[i1, j1,
i2, j2], 但是发现可以少一维的变量!!! &gt; f[k, i1, i2]表示所有从(1,1),
(1,1)分别走到(i1, k-i1), (i2, k-i2)的路径的最大值，
k表示两条路线当前走到的格子的横纵坐标之和</li>
<li>状态计算： 集合划分=下+下， 下+右， &gt; (1,1)-&gt; (i1-1, j1),
(i2-1,j2) -&gt; (i1, j1), (i2, j2)
<ul>
<li>集合划分 &gt; 将(1,1)到(k, i1, i2)的路分为两种 &gt; (1,1)--&gt;
(i1-1, j1) -&gt; (i1, j1) &gt; (1,1)--&gt; (i2-1, j2) -&gt; (i2, j2)
&gt; f(k-1, i1-1, i2-1), 根据(i1,j1),(i2,j2)是否是同一个格子，重合 w(i1,
j1); 不重合， w(i1, j1)+w(i2, j2)
<ul>
<li>1： 下， 2： 下</li>
<li>1： 下， 2： 右</li>
<li>1： 右， 2： 下</li>
<li>1： 右， 2: 右</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<h3 id="最长上升子序列问题">2.2 最长上升子序列问题</h3>
<p>LIS(longest increase subsequence) 1017 怪盗基德 1014 登山，482
合唱队形 1012 友好城市 1016 最大上升子序列 1010(+贪心) 拦截导弹
187(+dfs) 导弹防御系统 272(LCS) 最长公共上升子序列</p>
<h4 id="basic">2.2.1 basic</h4>
<p>895: 最长上升子序列问题 - 状态表示f[i] - 集合：
所有以a[i]结尾的严格单调上升子序列 - 属性： Max - 状态计算 -
划分依据：最后一个不同的点。 &gt;
如果不能在前面很快判断，那么最基本的想法就是枚举来做，空</p>
<blockquote>
<p>LLS实际上可以从n^2转化为nlogn, 实际与后面的一步的转化。 优化？</p>
</blockquote>
<p>272： 最长上升公共子序列 f[i,j] - 集合：
所有由第一个序列的前i个字母，第二个序列的前j个字母,
且以b[j]结尾的构成的公共子序列，Max &gt; 注意这里要加条件 - 状态计算：
1. 所有包含a[i]的公共上升子序列 a[i]==b[j] &gt; 按照倒数第2类划分，
序列倒数第1个数时null, b[1], b[2], .., b[j-1] &gt; 进行枚举 f[i,k] + 1
因为b[j]大于，所以实际上就是 2. 所有不包含a[i]的公共上升子序列 f[i-1,
j]</p>
<h2 id="背包问题-背包九讲">3. 背包问题： 背包九讲</h2>
<p>01背包： 体积vi, 价值wi, 求各种放法，使得背包的总价值最大 ### 3.1
basic - 01背包 - 完全背包 - 多重背包I - 多重背包问题II + 二进制 -
多重背包问题III + 单调队列（滑动窗口求最值） - 混合背包 - 分组背包 -
有依赖背包 + 树形DP - 二维费用的背包问题 - 求具体方案 - 求方案数</p>
<p>简单回顾</p>
<p>线性DP 序列DP: 包含选出来的一些数，相邻的数之间有一些关系 背包问题:
序列问题， 组合问题DP， 不考虑相邻元素之间的关系，考虑全局</p>
<p>01背包问题：每个物品选择或者不选
f[i,j]所有只从前i个物品中选，且总体积不超过j的选法的集合 划分： 1.
选择第i个物品的所有方案 f[i-1,j-v_i] + w_i 2. 不选择第i个物品的方案
f[i-1,j]</p>
<p>完全背包问题： 每个物品选0，1，2，.. 个 f[i,j]所有
只从前i个物品中选择，且总体积不超过j的选法 f[i,j] = max(f[i-1,j],
f[i,j-v]+w)
一般当空间优化成1维后，只有完全背包问题的体积是从小到大循环的 for 物品
for 体积 for 决策</p>
<p>多重背包问题： 每个物品选0，..., si个</p>
<p>规律：当空间优化到1维之后，只有完全背包问题的体积是从小到大循环的。
完全背包问题：某个物品的个数可以选任意个 &gt; f[i, j] = max(f[i - 1, j],
f[i, j-v[i]]) ! 只有这种情况是从小到大循环的。</p>
<p>多重背包问题：某个物品的个数给定 &gt;
实际上，可以看作滑动窗口，这里对应的代码 todo &gt; 实际上，解法1：
f[i,j]使用二维，直接枚举；
f[j]使用一维，使用二进制优化转化为01背包问题。</p>
<p>分组背包问题： 每组中选择一个物品 &gt; f[i,j]
这里的i的含义为从前i组进行选择</p>
<p>面试算法题，设计题</p>
<blockquote>
<p>万能头文件 #include&lt;bits/stdc++.h&gt;
需要注意的就是这样做会导入很多文件，等于说会耗时</p>
</blockquote>
<h3 id="further">3.2 further</h3>
<ul>
<li>01背包
<ul>
<li>采药</li>
<li>装箱问题</li>
<li>小精灵（阅读理解）</li>
<li>数字组合（方案数）</li>
<li>开心的金明</li>
<li>能量石（+贪心）</li>
</ul></li>
<li>完全背包
<ul>
<li>买书（方案数）</li>
<li>货币系统（方案数）
<ul>
<li>货币系统（贪心）</li>
</ul></li>
<li>二维费用
<ul>
<li>潜水员</li>
</ul></li>
</ul></li>
<li>多重背包
<ul>
<li>庆功会</li>
</ul></li>
<li>分组背包
<ul>
<li>机器分配</li>
</ul></li>
</ul>
<p>思维过程，编程能力</p>
<p>背包问题 1. 货币系统 1021 2. 货币系统 532 3. 混合背包问题 4.
有依赖的背包问题 5. 背包问题求方案数 6. 能量石 kickstart</p>
<p>三种背包问题的状态表示都是一样的</p>
<p>动态规划 集合全部都是只从前i件物品中选，且总体积不超过j的选法的，
价值的最大值</p>
<ol type="1">
<li>状态计算</li>
</ol>
<ul>
<li>01背包： f[i,j] = max(f[i-1,j], f[i-1, j-v]+w)</li>
<li>完全背包： f[i,j] = max(f[i-1,j], f[i,j-v] + w)</li>
<li>多重背包： f[i,j] = max(f[i-1,j], f[i-1, j-v[i]] + w[i],
f[i-1,j-2v[i]]+2w[i],... ,f[i-1,j-sv[i]]+s*w[i])</li>
</ul>
<p>不需要考虑前i件物品，只需要从第i件物品类型来分析。</p>
<p>k个数进行划分，如果没有依赖关系的话，有2^k种选择。如果有的话，会大大减少依赖关系。所以直接按m来划分。</p>
<p>把每个子树看作是一个物品组</p>
<h2 id="备注">备注</h2>
<p>链表可以直接用结构体和指针来做，实际上都可以用数组来进行模拟。 &gt;
为什么要用数组，效率高！ &gt; 用struct Node{int val; Node *next;}
每次都要new一个新节点，效率非常低</p>
<p>分类 1. 单链表 - 邻接表： 用来存储图和树 2. 双链表：
用来优化某些题</p>
<ol start="3" type="1">
<li>怎么预留，把动态规划的操作留到最后一步去，看来还是dfs最牛！</li>
</ol>
<h2 id="最多-vs-恰好-vs-至少">最多 vs 恰好 vs 至少</h2>
<ol type="1">
<li>体积最多是j,Max： 全部为0， V&gt;=0</li>
<li>体积恰好是j, Min: f[0]=0, f[i]=+inf V&gt;=0</li>
<li>体积至少是j, Min: f[0]=0, f[i]=+inf
f[j][k]=min(f[j][k],f[max(0,j-v1)][max(0,k-v2)]+w); &gt;
初始化为+inf或者-inf, 自己上是为了不使用它的值 &gt;
https://www.acwing.com/activity/content/code/update/133054/ &gt;
潜水员问题，记得多看几遍</li>
</ol>
<p>怎么写快速判断-1，~i，取反后即全为0</p>
<p>有依赖的背包问题 树形DP</p>
<h2 id="状态机模型">状态机模型</h2>
<p>多种状态，状态其实是一系列有序的事件。</p>
<p>状态机描述的是一个过程？ &gt; 买入到买出</p>
<p>背包是一个结果</p>
<p>另类状态表示 - 状态机 - 状态DP</p>
<p>以前状态计算的时候只有一个状态，现在相当于</p>
<p>状态机的想法是完全转换为当前步依赖于前一步，然后讲前一步划分为各个状态，进而清晰的表示</p>
<p>状态DP是当前很难用维度表示，所以将状态压缩为数字进行表示</p>
<p>注意状态机入口也是一个很重要的部分。表明允许从哪里接入和从哪里结束</p>
<p>一维一般不用考虑至少，恰好，至多之类的东西</p>
<h3 id="题目概览">题目概览</h3>
<ol type="1">
<li>大盗阿福 &gt; 一个序列，序列中的两个数不能连续选择</li>
<li>股票买卖IV &gt; 股票某天买入，某天卖出；
交易不能重合；问怎么交易最好</li>
<li>股票买卖V &gt; 卖出后有一个冷冻期</li>
<li>设计密码： kmp + 状态DP &gt; 在一维上跳动
<ul>
<li>kmp: 匹配的模板串，前缀与后缀相等所以可以移动位置
<ol type="1">
<li>约定从1开始</li>
<li>ne[i]=j: p[1,..j]=p[i-j+1,i];</li>
<li>基准： i-1与j匹配， i与j+1不匹配， 所以每轮比较的是i与j+1
<ul>
<li>失配： 失配时最少移动距离，新的已匹配下标就是ne[j];
然后再看下一个点i与j+1是否匹配，如果不匹配，继续失配递归处理</li>
<li>匹配
<ul>
<li>i==n: 输出结果</li>
</ul></li>
</ul></li>
<li>如何找ne[]: &gt; 其实就是自己串跟自己串比较；然后ne[1]=0,
递归生成；其实就是模板匹配的过程，不断地比较，处理适配，当将p[i]与p[j+1]匹配时，实际是就是p[1,..,j]
== p[i-j+1,...,i], 即直接赋值ne[i]=j;</li>
</ol></li>
</ul></li>
<li>修复DNA： AC自动机=trie+kmp和状态DP的结合 &gt; 在二维上跳动</li>
</ol>
<h2 id="状态压缩dp">状态压缩DP</h2>
<h3 id="棋盘式基于连通性">1. 棋盘式（基于连通性）</h3>
<p>对于棋盘，当前这行怎么枚举，只需要考虑上行的状态即可</p>
<ol type="1">
<li>骑士 &gt; 井字形方格约束, 记i行状态为a，i-1行状态为b
<ul>
<li>a&amp;b==0: a,b不能有相邻</li>
<li>(a|b) 不能有相邻</li>
</ul></li>
<li>玉米田 &gt; 某些地不能种</li>
<li>炮兵布阵 &gt; 相邻的多个行或者列不能种</li>
<li>愤怒的小鸟 &gt;
关键分析两个点确定抛物线，然后查看每个抛物线能覆盖哪些顶点。DP的想法实际上是从0到最终覆盖，对非0的点进行选择，来覆盖对应的选择，即状态划分过程。</li>
</ol>
<h2 id="区间dp">区间DP</h2>
<p>感觉就是一堆数，可以按某种要求进行合并。合并在一起是具有代价的。目标就是问怎样合并能够使得总代价最小</p>
<ol type="1">
<li>环形DP</li>
<li>记录方案数</li>
<li>高精度</li>
<li>二维区间DP</li>
</ol>
<ul>
<li>石子合并 &gt;
一个线段上的多个数最终合并为一个数。然后可以按区间合并，看合并的代价。
<ul>
<li>集合： f[i,j]: 所有从i到j和并的最小值。</li>
<li>状态计算： 按照最后一步进行划分，就是两个点的分界点 &gt; !!! 分界点,
min(f[l,k]+f[k+1,r]+s[l,r])</li>
</ul></li>
</ul>
<p>环形石子合并 加分二叉树：区间DP的方案数 棋盘分割：二维DP 凸多边形：
高精度 能量项链</p>
<h2 id="树形dp">树形DP</h2>
<p>DP问题的实质是用一个点表示一类情况
树形DP的本质是用当前节点表示所包含子树的所有情况</p>
<ol type="1">
<li><p>树的直径 &gt; 对于无权边而言</p>
<ul>
<li>任取一点作为起点，找到距离该点最远的一个点u, DFS</li>
<li>再找到距离u最远的一个点 DFS, BFS(DFS费空间)</li>
<li>那么u和v之间的路径就是一条直径 &gt; 证明:
这个过程还是很有意思的。利用的树一定是连通的，所以直接设置a-&gt;u的论据，和一条最短直径的相互比较即可退出矛盾</li>
<li>DP 一般做法</li>
</ul></li>
<li><p>树的中心：求最远距离的最小值。有上下两个地方的衡量，使用数组保存结果来解决问题</p></li>
<li><p>数字转换：使用筛法预处理出因素和，建模为求树上的某条最远路径</p></li>
<li><p>二叉苹果树： 有依赖的背包问题：
有依赖？选背包时选择某一件物品就必须选择另一件物品</p></li>
<li><p>战略游戏： &gt; vs 没有上司的舞会：
每条边最多选一个点，求最大权值 &gt; 战略游戏：
每条边至少选一个点，求最小权值</p></li>
<li><p>皇宫守卫</p></li>
</ol>
<h2 id="数位dp">数位DP</h2>
<p>DP问题的技巧: 基本上问的都是区间问题 1. 技巧1：f[N]: 1~N &gt; [X, Y]:
f[Y] - f[X - 1] 前缀和 2. 技巧2：尽量用树的方式考虑</p>
<p>本质上其实都还是排列组合数，但是不大好用排列组合来求
方案，分情况讨论</p>
<ol type="1">
<li><p>度的数量：
就像摘苹果一样，每一个苹果都要小心翼翼地摘，不要漏了，也不要重了</p></li>
<li><p>不降数 ## 单调队列/单调栈/其它数据结构优化的DP</p></li>
</ol>
<p>解决问题有限，求滑动窗口中的值。
首尾端点不需要固定，只需要都保持严格递增就可以</p>
<p>把队列中所有冗余的元素去掉，会发现队列有单调的性质
其实，如果是最小值，往往对应的是单调上升序列</p>
<ol type="1">
<li>朴素DP原理：正确性</li>
<li>DP优化，代码等价变形，观察代码</li>
</ol>
<h2 id="斜率优化dp">斜率优化DP</h2>
<h3 id="集合">2. 集合</h3>
<h3 id="对比">对比</h3>
<p>状态压缩DP是将所有的状态用一个二进制来表示了</p>
<h2 id="搜素">3. 搜素</h2>
<h3 id="bfs">3.1 BFS</h3>
<p>应用型算法，题目变化很多，题型很多</p>
<p>最核心的问题： 1. “求最小” 2. 基于迭代，不会爆栈</p>
<ol type="1">
<li><p>迷宫：最短距离 &gt; 可以从地图的一个点到达另一个点</p></li>
<li><p>八数码：最小步数 &gt;
把整个地图看作是一个状态，实际上求的就是从一个状态到达另一个状态的</p></li>
</ol>
<h4 id="flodd-fill">3.1.1 Flodd Fill</h4>
<p>洪水覆盖</p>
<p>水可以向周围覆盖。覆盖过的格子又可以覆盖。</p>
<p>不断加入新的格子，直到不能覆盖。</p>
<p>可以在线性时间复杂度内，找到某个点所在的连通块。
100个格子会导致爆栈</p>
<p>在生产空间，栈内存可以设定到内存一样大的 默认1M.
1M/每一层的空间=最大层</p>
<p>算法：思维+代码</p>
<p>常见的连通有两种： 1. 四连通： 只要有公共边就叫连通 人们常认为的模型
2. 八连通： 只要有公共点就叫连通 八连通</p>
<h4 id="最短路模型">3.1.2 最短路模型</h4>
<p>这里实际上是所有边权都一样的最短路模型</p>
<p>单源最短路</p>
<p>在线性时间内，可以得到所有点到某点的最短路</p>
<p>如何输出路径？</p>
<p>对于路径的数组，其实可以pre数组。</p>
<p>因为BFS本身就是按层搜，所以不用其他算法一样存储距离
很多时候从哪个点开始，其实只是为了最后处理结果方便一点而已</p>
<p>!!! BFS实际上就是每条边权为1的最短路模型</p>
<p>为什么可以？
其实来源于迪杰斯特拉最短路算法，它本身是维护一个优先队列，取队列中的最大值和最小值。而当边的权重都是1的时候。BFS所维护的队列就是一个单调增的队列，也就是说队头最小值，队尾最大值</p>
<p>BFS队列中的顺序实际上就是到起点的距离递增的顺序来扩展的</p>
<p>队列： 1. 两段性：最多有两段 2. 单调性： 初始， 假设</p>
<p>证明队首出队的元素一定是最小值 &gt;
反证法，如果出队的元素不是最小值，那么一定是由队列中后面的元素，转了一圈后，然后连接到该点。而由队列的单调性，后面所描述的距离一定是大于之前的距离的，所以矛盾。</p>
<p>每个元素只会入队一次，入队后值就确定，等于说它的值只会被更新一次。</p>
<h4 id="多源bfs">3.1.3 多源BFS</h4>
<p>实际上就是把所有多源路径距离置为0，添加到队列中即可</p>
<h4 id="最小步数模型">3.1.4 最小步数模型</h4>
<p>第二类的最短路的模型</p>
<ol type="1">
<li>如何存状态？ hash法，map(c++11) &gt; 康拓展开, map,
unordered_map</li>
</ol>
<p>思路：
将整个棋盘压缩成的状态。每次按搜索策略搜索，每个走过的状态标记下已经走过。直到到达最终状态为止。</p>
<h4 id="双端队列广搜">3.1.5 双端队列广搜</h4>
<p>专门用来处理边权为0或1的图。</p>
<p>怎么理解？ 将边权为0的放到队列开头，边权为1的放到队列结尾。
仍然满足单调性、两段性</p>
<p>这里因为有边权为0的边的存在，一个点可能会更新多次 #### 3.1.6
双向广搜</p>
<p>对于第二类算法，其实它总共有的状态数为格子的阶乘，太多了</p>
<p>宽搜，因为会存储当前层元素，所以会MLE. 如果状态太多，也会TLE.</p>
<p>实际上，每一层元素是呈指数上升的</p>
<p>双向搜素为什么有效？ 其实可以通过图来观察搜素空间，是变小的</p>
<p>一种直观的感受 6^10, 2*6^5</p>
<p>一般来说，只会用到最小步数模型。</p>
<p>一个优化，每次选择当前队列扩展元素较小的方向来扩展 #### 3.1.7 A*</p>
<p>目标跟双向广搜是一样的</p>
<p>队列换成优先队列， 小根堆</p>
<p>小根堆：
关键字：真实距离（从起点走到当前点的真实距离）+估价距离（从当前点到终点的估计距离）</p>
<p>选一个关键字最小的t 当终点第一次出队时 break; for t的所有邻边:
将邻边入队, 更新距离</p>
<p>图中所有边权都是任何都可以，只要没有非负回路？</p>
<p>迪杰斯特拉算法: 所有估价距离都取0的算法</p>
<p>成立条件：</p>
<p>d(state) + g(state) d(state) + f(state)</p>
<p>f(state) &lt;= g(state)：估价函数小于真实函数 必须要有解才能用
无解的话也需要对所有状态操作一遍，而且由于相比于BFS使用的队列是nlogn,
所以更耗时</p>
<p>如何证明成立？ 假设出队的元素，最小的为dist, 它不是最小的 即 dist
&gt; d最优 那么必然存在最优路径上的某个点u（起点一定在上面）, d[u]+f[u]
&lt;= d[u]+g[u]=d最优。</p>
<p>而队列中最优距离一定是最小的数，即d[u]+f[u]一定是最小的， dist &lt;=
d[u]+f[u] &lt;= d最优， 矛盾</p>
<p>只能保证终点出队的时候，终点一定是最优的点 &gt;
算法进阶指南写错的一点 &gt; 其实是最优路径上的点都是最优</p>
<p>对于其他点，入队出队都不一定是最优距离 <!--  -->
每个点也并不是只扩展一次, 每个点入队多次 Dijkstra f in [0, g]</p>
<p>BFS: 入队的时候判重， 即不再使用<br />
Dijkstra: 出队的时候判重 A*: 出队后不能判重，终点出队才能判重</p>
<p>估计距离： 能用A*算法题目不多</p>
<p>spfa可能会搜索空间多 A*是为了尽可能减少搜索空间</p>
<h5 id="八数码">八数码</h5>
<p>估价函数为当前点的位置与真实位置的曼哈顿距离之和</p>
<h3 id="dfs">3.2 DFS</h3>
<h4 id="dfs之连通性模型和搜索顺序">3.2.1 DFS之连通性模型和搜索顺序</h4>
<p>BFS: 队列 1. 连通性 2. 内部的某个部分能否走到另一个部分 3.
整个看成一个整体 4. 搜索空间减小</p>
<p>DFS: 代码短，但是第一次到达某个点
时间复杂度都是一样的，每个点只需要遍历一次</p>
<p>注意爆栈问题，输入一个数据，想一下会不会在极限情况下爆栈</p>
<p>手动地把递归改为非递归</p>
<p>注意两种模型： 一种是棋盘内部搜索。棋盘内每个点只需要搜索一次，
内部搜索
一种是整个棋盘搜索（对于这种类型时需要恢复现场的），外部搜索</p>
<p>外部搜索即可以处理路径数的问题，又可以处理最优化的问题</p>
<p>暴搜： 2^n, NP完全问题</p>
<h4 id="dfs之剪枝优化">3.2.2 DFS之剪枝优化</h4>
<p>常用的剪枝策略 1.
优化搜索顺序：大部分情况下，我们应该优先搜索分支较少的节点 2.
排除等效冗余：不考虑顺序的情况下，尽可能使用组合 3.
可行性剪枝：搜索到一半发现不合法，提前退出 4.
最优性剪枝：无论如何当前搜索到的结果都比最优取值差，剪枝 5.
记忆化搜索(DP) *</p>
<h3 id="迭代加深">3.3 迭代加深</h3>
<p>BFS:
宽搜的空间复杂度，因为需要把每一层中的所有元素存下来，所以是指数级别的
DFS: O(n)</p>
<p>max_depth 逐步扩大，从0开始</p>
<p>设置一个max_depth, 走完一个，然后再走一个</p>
<p>DFS: 具体的时间复杂度估计就行了，很难具体量算</p>
<h2 id="最短路问题">4. 最短路问题</h2>
<p>最难的点在于问题的转化和抽象 0.7</p>
<p>最大流是更难的一点</p>
<h3 id="单源最短路">4.1 单源最短路</h3>
<ol type="1">
<li>边权均非负
<ul>
<li>朴素Dijkstra: 稠密图，效率高 &gt;
其实就是单源最短路问题：从一个点开始扩展，不断扩展到所有点</li>
<li>堆优化Dijkstra: 稀疏图</li>
</ul></li>
<li>有负权边
<ul>
<li>Bellmair Ford</li>
<li>Spfa</li>
</ul></li>
</ol>
<p>综合运用：和DFS, 二分， DP, 拓扑排序结合</p>
<h3 id="多源最短路">4.2 多源最短路</h3>
<p>关键：使用距离的三角不等式来做各种问题</p>
<p>使用最短路来试图解决某些动态规划问题</p>
<p>floyd floyd: 多源最短路</p>
<ol type="1">
<li>最短路</li>
<li>传递闭包</li>
<li>找最小环</li>
<li>恰好经过k条边的最短路：倍增的思想</li>
</ol>
<p>floyd的原理： d[i,j]==inf, d[i,i]=0 for k: 1..n for i: 1..n for j:
1...n d[i,j]=min(d[i,k]+d[k,j]</p>
<p>floyd, bellman_ford: DP dijkstra: 贪心</p>
<p>d[k,i,j]:
所有从i出发，最终走到j，且中间只经过节点编号不超过k的所有路径 &gt;
注意理解是节点标号. 不包含i,j 路径长度最小值</p>
<p>集合划分 1. 中间经过k: 经过i-&gt;k. d[k-1,i, k]+d[k-1,k,j] 2.
中间不经过k: 说明经过的是d[k-1,i,j]</p>
<h3 id="最小生成树">4.3 最小生成树</h3>
<p>最小生成树中所有的边都是无向边</p>
<p>在当前的连通情况下。选择未连接点中到该连通块最小的点的边。 &gt;
假设不是选取的最小的边。否则可以构造更小的生成树 &gt; 根据环来做</p>
<p>kruskal: 基于并查集，选择两个顶点不在一个连通块的情况</p>
<p>核心证明：如果当前不选，可以在最优解（一棵树）中加上。然后形成一个环，形成一个环一定存在小于该边权的边，因此该边一定可以存在最优解中</p>
<p>最长路：正环 最短路：负环 是否存在某个环？ ### 4.4 spfa求负环
负环和正环的定义其实是对称的</p>
<p>负环是什么？
在求最短路时，如果原图中存在负环，那么dist[t]就会一直得到更新。</p>
<p>如果有负环，往往最短路求的就不准了。</p>
<p>抽屉原理。 求负环的常用方法, 基于spfa: 1.
统计每个点入队的次数，如果某个点入队n次，则说明存在负环。 &gt;
被更新了n次以上，每个边更新点一次 2.
统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于n，则也说明存在环</p>
<p>推荐第二种，因为在某种情况下，1为n^2, 2为n</p>
<p>新图上超级源点</p>
<ol type="1">
<li>spfa存在负权边，会被更新，不是-inf.</li>
<li>为什么等价于将所有点入队</li>
</ol>
<blockquote>
<p>理解负环一定是在最短路上运用的！
但是这里并不是说最短路占用更多的节点。而是利用了最短路，每次更新，实际上是根据一条新边来更新一个新点。
而负环其实就是看一个环的点数是否大于n了。
有负环，在这个算法中边一直都能被更新</p>
</blockquote>
<p><em>{fi} / </em>{ti} 最大 =&gt; 01分数规划 求一个环上的。</p>
<p>(0, 1000]. &gt; mid.</p>
<p>找一个判断的结果来做 <em>{fi} &gt; Mid * </em>{ti} &gt;
点权可以放到出边或者入边上是等价的</p>
<p>_{fi - mid*ti} &gt; 0 图中是否正环</p>
<p>通过最长路来做。</p>
<h3 id="差分约束">4.5 差分约束</h3>
<p>最短路径：最长路的最小值</p>
<h3 id="最近公共祖先">4.6 最近公共祖先</h3>
<ol type="1">
<li>向上标记法：
对点a向上走到根节点的路径进行标记，同时对b点做，当向上走的祖先相同时，即得到O(n)</li>
<li>倍增fa[i,j]: 表示从i开始向上走2^j能到达的节点。 0 &lt;= j &lt;=
logn; depth[i]表示深度，层数，即到根节点的距离+1
<ul>
<li>j = 0, f[i, j]=i的父节点</li>
<li>j &gt; 0, f[i, j] = f(f[i, j-1],j-1) &gt; x,y 基于二进制拼凑的思想.
t&gt;=2^k, t包含k位 &gt; 哨兵：
如果从i开始跳2^j步会跳过根节点，那么fa[i,j]=0, depth[0]=0 &gt; 步骤:
预处理O(nlogn)? 查询O(mlogn) &gt; 1. 先把x,y跳到同一层。
depth[x]-depth[y]. depth(f[x,k]) &gt;= depth(y) logn。 从大到小 &gt; 2.
让两个点一直往上跳，跳到同时是公共祖先的下一层为止。 跳到不等时
logn</li>
</ul></li>
<li>Tarjan: 离线求LCA 查询O(n+m) &gt;
DFS，合并两个集合可以用并查集来做。 遍历，合并，查询一次。 O(1),
合并和查询的时间都是O(1)
<ul>
<li><ol start="2" type="1">
<li>已经搜索过的点</li>
</ol></li>
<li><ol type="1">
<li>正在搜索的点</li>
</ol></li>
<li><ol start="0" type="1">
<li>还未搜索的点 &gt; 根据并查集来做！</li>
</ol></li>
</ul></li>
</ol>
<h3 id="有向图的强连通分量">4.7 有向图的强连通分量</h3>
<p>一般来说，对于一般的图很难做。所以我们常见的想法就是先将一个图缩点为有向芜湖安图DAG,
拓扑图，然后用关键路径来做</p>
<p>求连通分量</p>
<p>DFS: 在搜索过程中这四种边 - 树枝边 (x, y) - 前向边 (x, y) - 后向边
(x, y) - 横叉边 (x, y) &gt;
注意，向左是横叉边，但是向右就不是横叉边了；因为右边的横叉边； &gt;
后向边都是往回走的；前向边不用管</p>
<p>? x它是否在某个强连通分量SCC中 情况1：存在后向边，指向祖先节点
情况2：走到了横叉边，横叉边走到了祖先节点。</p>
<p>时间戳</p>
<p>以前的方法是：一遍DFS，再BFS来着 Tarjan算法求强连通分量SCC
对每个点定义两个时间戳 dfn[u]表示遍历到u的时间戳
low[u]表示从u开始走，所能遍历到的最小时间戳
u是其所在的强联通分量的最高点，等价于dfn[u] == low[u]
此时就把当前的连通分量找出来</p>
<p>时间复杂度 O(n + m)</p>
<p>后续做法： 1. 缩点: DAG for i = 1, i &lt;=n, i ++ for i的所有领点j:
if i,j 不在同一SCC中 加一条新边，id(i) -&gt; id(j);
按照连通分量递减的顺序就是拓扑序列 所有到这个点的顺序已经确定</p>
<p>求拓扑序列： 深度搜索，宽度搜索</p>
<h3 id="无向图连通分量">4.8 无向图连通分量</h3>
<ol type="1">
<li>边双连通分量 e-DCC 极大的不包含桥的连通块
极大：不存在一个包含它的并且比它多的连通分量</li>
</ol>
<p>tarjan算法： - 树枝边 - 前向边 - 后向边 时间戳的思想： dfn[x], low[x]
如何找到桥？ x-y是桥 &lt;-&gt; dfn[x] &lt; low[y]
如何找所有边的双连通分量？ - 将所有桥删掉，剩下的连通分支都是 -
使用栈来找 dfn[x]==low[x]: x所包含的子树就是双连通分量</p>
<p>冗余路径：如果两个路径没有公共边，等价于边的双连通分量
最少加几条边可以构成边的双连通分量
缩点后其实就是一棵树，所有度数为1的点都至少要加一条边。 ceil(cnt/2) =
(cnt+1)/2 证明： 充分性：反证法 必要性：</p>
<ol start="2" type="1">
<li>点双连通分量 v-DCC 极大的不包含割点的连通块</li>
</ol>
<p>反直觉，每个割点至少属于两个连通分量 两个割点之间的边不一定是桥
任何桥的两个端点不一定是割点，如两个点的情况
点连通分量不一定是边连通分量 边连通分量不一定是点连通分量</p>
<p>如何求割点？ x-&gt;y: low[y] &gt;= dfn[x] 1.
如果x不是根节点，那么x是割点 2. 如果x是根节点，那么至少有两个子节点yi,
满足low[yi] &gt;= dfn[x] 电力：统计连通块个数
cnt；依次枚举从哪个块中删，再枚举删除哪个点？s.
依次枚举每个割点然后求全局最大值</p>
<p>如何求双连通分量？ if (dfn[x] &lt;= low[y]) { cnt ++; if (x非根节点
|| cnt &gt; 1) x是割点 将栈中元素弹出，直至弹出y为止
且x也属于该“点双连通分量” } 如果是个孤点的话也是双连通分量。</p>
<p>难点在于答案是怎么算出来的？ ### 4.8 二分图</p>
<ol type="1">
<li>二分图、不存在奇数环，染色法不存在矛盾</li>
<li>匈牙利算法、匹配、最大匹配、匹配点，增广路径</li>
<li>最小点覆盖、最大独立集、最小路径点覆盖、最小路径重复点覆盖
最大匹配数 = 最小点覆盖 = 总点数 - 最大独立集 = 总点数 -
最小路径覆盖</li>
</ol>
<p>点覆盖：每个边都能找到一个点覆盖
最大独立集：选出最多的点，使得选出的点之间没有边
最大团：选出最多的点，使得选出的点两两都有边</p>
<ol start="4" type="1">
<li>最优匹配，KM 最小费用流</li>
<li>多重匹配，每个点可以匹配多个点 最大流</li>
</ol>
<h3 id="欧拉回路和欧拉路径">4.9 欧拉回路和欧拉路径</h3>
<h3 id="拓扑排序">4.10 拓扑排序</h3>
<h2 id="基本数据结构">5. 基本数据结构</h2>
<h3 id="并查集">5.1 并查集</h3>
<p>两个优化：路径优化，按秩合并 1. 记录每个集合大小：绑定到根节点上 2.
每个点到根节点的距离，绑定到每个元素上</p>
<p>带权并查集: 相对距离 扩展域 O(k): 枚举的思想</p>
<h2 id="补充">6 补充</h2>
<p>RSA密钥原理 Q*P=N
N作为公钥，P，Q作为密钥，P知道Q的密钥，分别被双方拥有。实际上是基于大整数分解非常困难的原因。
&gt;
A知道B的密钥，公钥，AB都知道，所以B就可以访问A，A就可以验证是否符合要求。</p>
<p>井田制 &gt; 田字型的土地，土地由农民自己，然后向中心交税</p>
<p>为什么炮兵的炮弹不会被山地阻挡？ &gt; 因为它的运动轨迹是抛物线的</p>
<ul>
<li>DP:
<ul>
<li>数字三角形模型： &gt; 当前步，简单地方格，向右走和向上走
<ul>
<li>扩展：走k次如何计算？</li>
</ul></li>
<li>最长上升子序列模型： &gt; 使用单调队列的方法构造上升子序列？？</li>
<li>背包问题：完全背包和多重背包，形如多少个物品，每个物品有对应的属性，多个，每个属性有自己的约束，求最值和方案数
<ul>
<li>可能扩展
<ul>
<li>预处理，预先排序。把几个属性合在一起看</li>
<li>多重背包问题的重叠</li>
<li>分组背包：有多个依赖：转换为离散值，当太复杂时，过渡到树形DP*</li>
</ul></li>
<li>不熟练点
<ul>
<li>求具体方案</li>
<li>属性</li>
</ul></li>
</ul></li>
<li>状态机模型：
状态直接考虑会依赖到上一层以上的状态，所以将上一层分为离散的状态来考虑</li>
<li>状态压缩DP: 将上一层的状态用二进制来表示</li>
</ul></li>
</ul>
<p>记忆化搜索模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int dp(int l, int r) &#123;</span><br><span class="line">    int&amp; v = f[l][r];</span><br><span class="line">    if (v &gt;= 0) return v;</span><br><span class="line">    // 计算过程</span><br><span class="line"></span><br><span class="line">    return v=get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return f(1, n);</span><br></pre></td></tr></table></figure>
<p>现象-&gt; 逻辑（写法）：应试教育</p>
<p>最大独立集：有很多点，很多边</p>
<p>不包含一个字符串, KMP 包含多个字符串，树形DP</p>
<p>闫式最优化问题分析法</p>
<p>在一个有限集合中秋最值，或者个数。 &gt;
有可能方案是无限集，通过贪心证明，结果在有限集中
将所有情况划分到集合中，从而来查看集合与集合之间的关系</p>
<p>古代的烽火传递：
现在一般都用光纤等，电波等传递信号，而古代的时候是怎么传递信号的呢。用的是可见光，即烟能够向上空飘去，点表示敌人来犯。</p>
<p>白天用烟，晚上用火。</p>
<p>容错机制。 在可见范围内多放几座信号塔</p>
<p>物理化学是第二次工业革命的产物，信息技术才是第三四次工业革命的产物</p>
<p>一个行业要在前几年入，但有风险是肯定的。不能有很好的晋升机会，现在大公司都在裁员</p>
<p>一个经济周期往往会不断的波动，但是整个平均值是在提高的，平均值就是生产力的增长。
在不久的将来很多人就可以不工作
每天的需要是什么？吃饭、电力、暖气、WIFI、睡觉</p>
<p>经济周期好的时候放债具有更好的收益。债务放出来说明整个社会的钱变多了，说明社会的平均工资变多了。
债务达到一个峰值没有跟生产力匹配的时候就会产生泡沫。
经济就会下行，资本就会进入寒冬，没有人放债。
当它低于一个下行值时，又会上升</p>
<p>数组越界，爆栈</p>
<p>错误，检查for循环的终止条件是否正确</p>
<p>注意由于对齐原理，结构体有时间开辟的空间更大</p>
<p>对于BFS,DFS，其实还需要考虑的一个问题就是，这个点访问几次</p>
<p>奇怪的问题 queue<int> q; cout &lt;&lt; 一大堆数</p>
<p>迪杰斯特拉在非负权边上做都可</p>
<p>define 会多两条指令</p>
<h3 id="最短路-vs-dp">最短路 vs DP</h3>
<p>两个是有着不同的交集的</p>
<p>起点：(0,0) 终点: f[0,0], f[0,1], ..., f[0,m]</p>
<p>状态转移方程 f[i,j] = min(f[i,j], f[i-1,j] + w)
其实f[i,j]就可以看作是一个点。然后加的值表示权</p>
<p>然后，好像对于方案数为什么是相加，豁然开朗</p>
<p>f[n,m]到起点的最长路径。</p>
<p>绝大部分DP是拓扑图上的最短路问题</p>
<p>DP和最短路的交集就是拓扑图 DP未交的地方未想到例题</p>
<p>启示： DP依赖关系不具有拓扑序，可以用最短路来做</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/algorithm-basic-class-848088d6b8a0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/algorithm-basic-class-848088d6b8a0/" class="post-title-link" itemprop="url">algorithm basic class</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-16 08:02:32" itemprop="dateCreated datePublished" datetime="2019-09-16T08:02:32+08:00">2019-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/" itemprop="url" rel="index"><span itemprop="name">acwing</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/basic/" itemprop="url" rel="index"><span itemprop="name">basic</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/basic/summary/" itemprop="url" rel="index"><span itemprop="name">summary</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>快排 &gt; 难分，易于归并 &gt; eg: 第k个数</p>
<p>归并 &gt; 易分，难合 &gt; eg: 逆序对</p>
<p>二分：整数，浮点数 &gt;
二分，多种场合，分治的取一情况。分割两种不同的性质</p>
<p>高精度,A+B, A-B, A*a, A/a &gt; A+B, tmp临变量。
末尾存储，a[0]存个位。</p>
<p>前缀和差分 &gt; 前缀和[;,r], s[r]-s[l-1]. 一维和二维。 &gt;一维前缀和
<span class="math inline">\(a_l+a_{l+1}+...+a_r = S_r - S_{l-1}\)</span>
&gt; 一次O(n),后面线性时间查询 &gt; 差分:
多次为某个区间中的数进行操作，单位时间即可解决</p>
<p>双指针 &gt; 模板很好用，找单调性</p>
<p>位运算： 怎么析取每一位1，怎么找到最低位1 &gt; 位操作才是</p>
<p>离散化 &gt;在一个小的区间上反复做操作和查询</p>
<p>区间合并 &gt; 为后面做准备。 怎么处理特殊情况？让情况考虑完全！</p>
<p>单链表和双链表 &gt; 单： e[N],ne[N],idx,head=-1; e[idx++]=x;
注意！删除头元素！
数组中自然下标对应的是按顺序插入的值，不考虑删除的情况; &gt; &gt;
注意节点的值存储在e[i]中 &gt; &gt; 常用在图和hash表的存储中 &gt; 双：
e[N],l[N],r[N],idx,r[0]=1,l[1]=0; e[idx++]=x;
从2开始计数，删除时直接用指针即可</p>
<p>栈和队列 &gt; 栈: st[N],tt st[++tt]=x; tt?No:Empty &gt;
队列：q[N],hh,tt=-1 q[++tt]=x hh&lt;=tt ? No: Empty</p>
<p>单调栈和单调队列（滑动窗口） &gt;
首先给出暴力做法，然后去掉没有用的元素，发现剩余的元素具有单调性。
没有用的元素考虑使用栈或者队列将其抛弃，剩余的元素则进行保留。 &gt;
对单调性的东西，可以考虑用栈来访问最近最值元素，队列来访问全局最近最小元素？，另外由于单调性还可以用二分法进行模拟。
&gt; 实现： &gt; 单调栈： 队中存储的就是元素 &gt; 滑动窗口：
队中存储的是元素的下标 &gt; 时间复杂度优化：
每个元素最多进栈和出栈一次，优化为了O(n); &gt; ?
二元关系的下界知道，怎么知道一个问题的下界是多少？ <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">单调栈</span><br><span class="line">st[N], tt=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">    int x;</span><br><span class="line">    while(tt &amp;&amp; st[tt]&gt;=x) tt--;</span><br><span class="line">    if(tt) puts(&quot;-1&quot;);</span><br><span class="line">    else printf(&quot;%d&quot;,st[tt]);</span><br><span class="line">    st[++tt]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">单调队列</span><br><span class="line">a[N], q[N], hh, tt=-1;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">    if(hh&lt;=tt &amp;&amp; q[tt]&lt;i-k+1) hh++;</span><br><span class="line">    while(hh&lt;=tt &amp;&amp; a[q[tt]]&lt;=a[i]) tt--;</span><br><span class="line">    q[++tt]=i;</span><br><span class="line">    if(i&gt;=k-1)&#123;</span><br><span class="line">        cout&lt;&lt;q[hh]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>KMP &gt;
用于搜索模板串在子串上出现的位置，思想是提前对模板串做信息标志，即利用最大后缀。
&gt; next[i]: 以i为终点的，最长连续后缀的长度。 next[1]=0; // 初始化
&gt; 关键为next数组, 时间复杂度,
匹配的时候while不执行和while执行时均摊可以知道，while最多减m次 ？？？
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for(int i=2, j=0;i&lt;=n;i++)&#123;</span><br><span class="line">    while(j &amp;&amp; p[i]!=p[j+1]) j=next[j]; //j=0,表示一个都还没成功匹配</span><br><span class="line">    if(p[i]==p[j+1]) j++;</span><br><span class="line">    next[i]=j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i=1,j=0;i&lt;=m;i++)&#123;</span><br><span class="line">    while(j &amp;&amp; s[i]!=p[j+1]) j=next[j];</span><br><span class="line">    if(s[i]==p[j+1]) j++;</span><br><span class="line">    if(j==n)&#123;</span><br><span class="line">        printf(&quot;%d&quot;,i-j+1); // 返回从1开始的s的下标</span><br><span class="line">        j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Trie树 &gt; 利用相同的前缀，进行搜索；将每个字母当做一个节点。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">son[N][26],cnt[M],idx; // 这里M应该是最多出现的节点的个数，因为这里M是节点的计数</span><br><span class="line">这里的N是最大出现的层数，即字符串的最大长度。</span><br><span class="line">str[N];</span><br><span class="line"></span><br><span class="line">int add(char str[N])&#123;</span><br><span class="line">    p=0;</span><br><span class="line">    for(int i=0;str[i];i++)&#123;</span><br><span class="line">        int u=str[i]-&#x27;a&#x27;;</span><br><span class="line">        if(!son[p][u]) son[p][u]=idx++;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">时间复杂度 插入O(n),查找O(n); 可用于在大批的字符串中进行查找</span><br></pre></td></tr></table></figure></p>
<p>并查集 &gt; 将两个元素合并，询问两个元素是否在一起; 用树来模拟 &gt;
1. 如何判断根 2. 如何求x的集合编号 3. 如何合并 &gt;
可用于一切集合合并的问题 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int find(int x)&#123;</span><br><span class="line">    if(p[x]!=x) p[x]=find(p[x]);</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;=n;i++) p[i]=i;</span><br><span class="line"></span><br><span class="line">M: p[find(a)]=find(b);</span><br><span class="line">Q: find(a)==find(b);</span><br></pre></td></tr></table></figure></p>
<p>堆 &gt; down(i), up(i); i从1开始， 变小往上走，变大往下走 &gt;
堆排序，建堆O(n), 修复一个元素O(n). O(klogk):找前k个元素？？ &gt;
模拟堆，额外维护一个第几个插入与堆中元素的链表</p>
<p>哈希表 &gt; 注意区别离散化，离散化是借助前缀和来做 &gt; 如何哈希？
如何解决冲突？ 开放寻址法+拉链法 &gt; 无序性，O(1) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">关键find函数，找到元素或者找到该插入元素的位置</span><br><span class="line">拉链法</span><br><span class="line">h[N],e[N],ne[N],idx;</span><br><span class="line">int insert(int x)&#123;</span><br><span class="line">    int k=(x%N+N)%N;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    ne[idx]=h[k];</span><br><span class="line">    h[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    int k=(x%N+N)%N;</span><br><span class="line">    for(int i=h[k];i!=-1;i=ne[i])&#123;</span><br><span class="line">        if(e[i]==x) return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">memset(h,-1,sizeof(h));</span><br><span class="line"></span><br><span class="line">开放寻址法：找坑法</span><br><span class="line">如何填满了会出问题，所以经验上会用2-3倍空间</span><br><span class="line">const int N=200003,null=0x3f3f3f3f;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    int k=(x%N+N)%N;</span><br><span class="line">    while(h[k]==null &amp;&amp; h[k] != x)&#123;</span><br><span class="line">        k++;</span><br><span class="line">        if(k==N) k=0;</span><br><span class="line">    &#125;</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br><span class="line">memeset(h,0x3f,sizeof(h)); // 关键null要大于x数值的范围</span><br></pre></td></tr></table></figure></p>
<p>字符串哈希 &gt; 前缀哈希，正常按高到低来。由p进制来转换为十进制数。
&gt; 经验值： p=131,13331, Q: 2^64; &gt;
[l,r]的哈希值h[r]-h[l-1]*p[r-l+1] &gt;
所以只需要比较两个哈希值是否相等就能知道两个字符串是否相等。如果h和p提前计算好就是O(1),作用快速比较两个字符串是否相等
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ULL h[N],p[N];</span><br><span class="line">char str[N];</span><br><span class="line"></span><br><span class="line">ULL get(int l, int r)&#123;</span><br><span class="line">    return h[r]-h[l-1]*p[r-l+1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p[0]=1;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    p[i]=p[i-1]*p;</span><br><span class="line">    h[i]=h[i-1]*p+str[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>STL初步 vector 变长数组，倍增思想 size() dequeue 特别慢 string
可用作模拟栈, pair queue(), priorityqueue stack
set有序序列，基于平衡树实现 O(logN) map a["adad"]=1, a.count()? 好用！
unorder_set,.._map,哈希，O(1), 单独头文件 bitset(): bitset&lt;10000&gt;
s; ~,&amp;,|,^</p>
<p>DFS: 回溯，暴力搜索，恢复现场 1. 简单的框架 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 回溯法: u代表了每一层</span><br><span class="line">int dfs(int u)&#123;</span><br><span class="line">    if(u==n)&#123;</span><br><span class="line">        //print</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!st[i])&#123;</span><br><span class="line">            st[i]=true;</span><br><span class="line">            dfs(u+1);</span><br><span class="line">            st[i]=false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 2.
树和图的框架 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">h[N],e[N],ne[N],idx;</span><br><span class="line">st[N];</span><br><span class="line"></span><br><span class="line">void add(int x,int y)&#123;</span><br><span class="line">    e[idx]=y,ne[idx]=h[x],h[x]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注意这里是图的遍历框架，所以跟前面的不一样，考虑的不是到达某一显示的层；而是将图中所有节点搜索完得到结果</span><br><span class="line">void dfs(int u)&#123;</span><br><span class="line">    st[u]=true;</span><br><span class="line"></span><br><span class="line">    for(int i=h[u];i!=-1;i=ne[i])&#123;</span><br><span class="line">        int j=e[i];</span><br><span class="line">        if(!st[j])&#123;</span><br><span class="line">            // 预处理</span><br><span class="line">            int t = dfs(j);</span><br><span class="line">            // 后处理</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BFS: 最短路的性质 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">h[N],e[N],ne[N],idx;</span><br><span class="line">int d[N],q[N];</span><br><span class="line"></span><br><span class="line">void bfs()&#123;</span><br><span class="line">    // 声明数组</span><br><span class="line"></span><br><span class="line">    // 初始化加入第一个元素</span><br><span class="line"></span><br><span class="line">    while(queue不空)：</span><br><span class="line">        t&lt;-队头</span><br><span class="line">        枚举所有出边：</span><br><span class="line">            if(constraint(x))&#123;</span><br><span class="line">                更新d[j];</span><br><span class="line">                入队；</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    // 队列中的元素就是拓扑序列</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最短路问题 - 单源最短路 - 正权边 &gt; Dijkstra算法 O(n^3) &gt;
d[i]=0; for(i:1-n) min, S&lt;-t, update min &gt; 堆优化的Dijkstra算法
O(mlogN) - 负权边 &gt; Bellman_ford() &gt; spfa() - 多源最短路 floyd,
动态规划</p>
<p>最小生成树 Prim算法 朴素版 算法思想 d[1]=0, d[2..n]=INF
while(q.size()) (t=q.min() for v: t-v: if(!st[v])
d[v]=min(d[v],d[t][v]);) O(n^2): n轮，每轮1-m Kruskal O(mlogm)
从小到大选边， mlogm进行排序</p>
<p>二分图 染色法 O(n+m):对所有边和点进行遍历 匈牙利算法O(nm)
找最大匹配</p>
<p>数论 质数 从2开始具有某种性质的整数； 判定方法：试除法：d|n, n/d |n,
d&lt;=n/d 分解n的质因数：不断砍质数 &lt;=n/i
筛质数：筛选出2~n之间的所有质数 - 从小到大筛数的倍数 - 筛素数的倍数：
埃式筛法 - 利用乘积来筛：线性筛法 &lt;=n</p>
<p>约数
试除法求约数：成对出现。然后在排序，可以计算出排序的时间复杂度远小于一般情况
约数个数：自然数基本定理 a=p1^a1 p2^a2 ... pk^ak
约数之和：(p1<sup>0+...+p1</sup>a1)(p2<sup>0+...+p2</sup>a2)...
(利用了组合数学)</p>
<p>最大公约数 辗转相除法</p>
<p>欧拉函数 p(n): 1~n之间与n互质的数 如何求？容斥原理，去掉不互质的
N-N/p1-N/p1+..进行统计 N(1-1/p1-1/p2-... + 1/p1p2) 然后公式改写可以得到
N(1-1/p1)(1-1/p2)...(1-1/pk) - 公式法：计算出某一个数的欧拉函数 -
筛法：计算多个数的欧拉函数 phi[primes[j]*i]=primes[j]*phi[i] //
primes[j]是i的第一个质因数 分为质数 最小质因数是该数的因子
最小质因数不是该数的因子 使用线性筛法的模板来解题</p>
<p>费马定理 a^(phi[p]) mod p = 1</p>
<p>a^k mod p的快速幂:
将等比数列，等差数列之类的东西很容易用循环结构来写，这样从某种程度就会让问题的难度降低很多</p>
<p>快速幂求逆元： aa^-1 mod p = 1 根据费马定理 a^(p-1) mod p=1,
所以逆元为a^(p-2) logP</p>
<p>扩展欧几里得算法 ax+by=gcd(a,b)
求x和y：本身其实是有多个解的，注意这里的循环结构是非常妙的！</p>
<p>线性同余方程 ax =b mod m, 转化为ax-my mod m=b,
然后再扩充解，如果(a,m)|b不成立的话，无解</p>
<p>中国剩余定理：
第一种方法：使用公式法来做；第二种做法：使用线性同余方程的合并来做</p>
<p>组合计数 - 10万组 2000 递推 C(n,m)=C(n-1,m)+C(n-1,m-1) O(n^2) - 1万组
10^5 运用逆元的思想 fib[a] infib[b] infib[a-b] mod n, N<em>logN - 20组
10^18 使用卢斯卡定理 C(a,b)=C(a mod p, b mod p)</em>C(a/p, b/p) mod p
后面mod p 必须有否则不成立, p这里一般不会太大 -
无模运算：直接求a!中p的个数, 用大整数乘法来做</p>
<p>有序的01序列 卡特兰数，转化为图形，数轴翻转进行理解 (2n)! / n!(n+1)!
= 1/(n+1) C(2n,n) 应用很多，如栈的顺序</p>
<p>高斯消元 手动模拟人工计算的工程 1. 对列进行循环 2. 寻找首元素最大的行
3. 如果为不存在或为0， continue 4. 交换最大行和首元素行 5.
将当前行首元素置为1，从后往前循环 6. 将后面的行的首元素变为0 7.
对有多组解、无解、唯一解情况进行判断</p>
<p>异或：不进位的加法 1. 枚举列 2. 找非零行 3. 交换 4. 消零</p>
<p>容斥原理 韦恩图
有什么用？能减少枚举的数量的个数？如果找到某种性质的话
比如：1~n之间能被p1,p2,...等多个数整除的数的个数？使用容斥原理 k(2^k-1)
复杂度</p>
<p>简单博弈 公平组合游戏 Nim游戏： 必败状态=0和必胜状态!=0, 自然数的异或
Nex游戏，sg(x)终止状态为0状态，反推最小非负整数的运算，每一个都是到不了状态
&gt; 每个可以根据形成一个单独图，sg(b1,b2)=sg(b1)^sg(b2) 实例：
Nim游戏、台阶-Nim游戏、集合-Nim游戏、拆分Nim游戏</p>
<p>背包问题 - 01背包 i v max(w) 每个物品选或不选 f[i][v]=w:
所有只使用前i个物品且总体积小于v的取法的权重的Max
根据最后一个元素i放或不放进行拆分 f[i][v]=max(f[i][v],
f[i-1][v-v[i]]+w[i]) N<em>V </em>1 N - 完全背包 每个物品可以选任意次
f[i][v]=w 所有只使用前i个物品且总体积小于v的取法的权重的Max
根据最后一个元素i取多少次进行限制 由容量大小确定取的次数
根据递推关系可以简单写成 f[i][v]=max(f[i][v], f[i][v-w]+w) N<em>V</em>1
N - 多重背包问题 每个物品有si个 &gt;
思路将0~si,用1,2,4,..,2^k,c枚举转化为01背包问题 NlogS<em>V</em>1 NlogS -
分组背包问题 每组物品中只能选一个或不选 f[i][v]= N
所有只从前i组中选择且总体积不小于v的取法的权重的最大
根据每组选哪个元素来分类 f[i][v] = max(f[i][v], f[i][v-v[i][k]]+w[i][k])
// k=0~k-1 N<em>V</em>K N*K &gt;
这里用组的概念代替了单个背包，所以也多出了多种选择</p>
<p>线性DP &gt; 考虑的方式都是线性的</p>
<ul>
<li><p>数字三角形 从上到下的权重最长的路径 f[i][j]
所有从起点走到(i,j)的路径的权重和的最大值
根据前一方向的来源，左上方还是右下方 f[i][j]=max(f[i-1][j], f[i-1][j-1])
+ a[i][j] n^2*1 n^2 &gt; 因为出口有多条路，所以数据结构不可缩减</p></li>
<li><p>最长上升子序列 &gt; 注意发现的话，可以看出这里的做法是很妙的 f[i]
所有以第i个数为结尾的上升子序列的结合长度的最大值
考虑上升子序列中上一元素的位置 f[i]=max(f[j]+1) j:0~i-1 n<em>n n
非DP,优化 n</em>logn
发现长度的最后一个位置具有递增关系，可以用二分法搜索进行优化 &gt;
代码！！！</p></li>
</ul>
<p>最长公共子序列 f[i][j]
所有由第一个序列的前i个字母和第二个序列的前j个字母构成的最长公共子序列的Max
根据第i个和第j个字母是最长公共子序列的结尾元素，优化后可得
f[i][j]=max(f[i-1][j],f[i][j-1], f[i-1][j-1]+1) N<em>M</em>1 N*M</p>
<p>最短编辑距离 f[i,j]
将a[1,i]编辑成b[1,j]的所有操作方式的集合，操作方式有插入、删除、替换
根据最后一次属于哪种操作方式进行分类 f[i,j]=min(f[i-1,j], f[i,j-1],
f[i-1,j-1]+(a[i]!=b[j]))</p>
<p>区间DP &gt; 二维的i,j一般为区间的起始和终点坐标 石子合并 前缀和的运用
大整数相乘 f[i][j]
所有将第i堆石子和第j堆石子合并成一堆石子的合并方式的代价的最小值
按最后一次合并的位置进行划分 f[i,j] = max_k (f[i,k]+f[k,j]+pj)
k=i,..,j-1 n*n n^2<br />
&gt; 这里循环用了len和i，值得借鉴</p>
<p>计数类DP 属性为数量，直接相加得到最终结果 整数划分 f[i,j]
从0~i中选择整数，组成恰好是j的所有方式的集合的总数量
按i加入的次数进行分类 完全背包问题 f[i,j] = f[i-1,j] + f[i,j-v[i]] ans =
f[i,i]</p>
<p>f[i,j] 使用j个元素构成的数恰好是j的所有方式的集合的数量
最小的元素是否是1 f[i,j] = f[i-1,j-1] + f[i-j, j] ans = sum_i f[n,i]</p>
<p>数位统计DP 比如计数问题，对数位上出现的数进行统计</p>
<p>状态压缩DP f[i][j], 某一个位使用二进制位来表示整体的状态方程
蒙德里安的梦想 &gt; 非常妙的一种做法，想到每个小格进行递推得到方程式
矩形可以有多少中1*2的小矩形的填充方法，首先考虑横着的矩形，竖着放的矩形就唯一确定了。
对于横着放的矩形，总共的方案数，研究每列上每个状态的情况！！ 多加理解
最短Hamilton路径 为什么要用这个？ f[i][j]
所以从0走到j，走过的所有点的状态是i的所有路径的长度 &gt;
用状态压缩是因为这里的路径不是按自然序来的，可能有多种组合方式</p>
<p>树形DP 没有上司的舞会 容易，直接用父子关系即可建立DP关系 &gt;
注意最大值这里可能会犯错</p>
<p>记忆化搜索 滑雪 &gt;
非常妙的一个东西！对于方格型DP,想到了用方向来分类做，非常好</p>
<p>贪心 证明 A=B: A&lt;=B &amp;&amp; A&gt;=B 区间问题 - 右端点排序 1.
区间选点问题，数轴选最少的点覆盖所有的区间 &gt;
排序，从前到后枚举每个区间，ed=-2e9,如果当前区间被覆盖，即区间的左端点小于ed,下一个；否则，更新ed
证明：最小不用; cnt&lt;=Ans, cnt覆盖了所有不相交的点，是基本情况</p>
<ol start="2" type="1">
<li>最大不相交区间数量 &gt; 同上 证明：最大不用；cnt&gt;=Ans,
Ans选择的是两两没有交集的区间，那么是点覆盖区间的基本情况，所以必然点的数量大于区间的数量</li>
</ol>
<ul>
<li>左端点排序</li>
</ul>
<ol type="1">
<li><p>区间选组，选择每组内部不相交组的，所分的最小组数 &gt; 排序，
一定是左端点最大的（意味着不可替换性）L[i] &lt;=
所有组的Max_r，则要开辟一个新的组；否则，选择其中r最小的组进行加入，并更新该组的r
正确性：最小不用；Ans&gt;=cnt L[i]
成为新组前一定是形成了cnt+1个相交的区间，这些相交的区间必然花费等量的组，于是得证</p></li>
<li><p>区间覆盖，给定区间，如何用最少的相交区间将其覆盖，也就是怎么安排可以使得任务量最少
&gt;
排序，在所有能覆盖某一点start,选择最大右端点的，作为新的start，依次类推得到最优解
正确性：Ans&lt;=cnt显然， Ans&gt;cnt,
如果与该算法不同，即选择的不是最右的，那么任何最优的算法均能转换为该算法得到的结果，因此大于。</p></li>
</ol>
<p>Huffman树，合并n组东西，如何合并才能使总代价最小。
Huffman树的结构，用层数来解决。</p>
<p>贪心算法</p>
<ul>
<li>排队打水问题 &gt;
贪心题一般是猜一个做法，然后思考为什么是对的。调整法和反证法</li>
</ul>
<p>调整法，对于其实要满足某种顺序，比如正序或者降序的序列，可以假定有两个不满足该序列，然后从而推出矛盾（因为有目标值的存在）</p>
<p>如果不是按照从小到大的顺序排序，必然存在两个逆序的数。此时得出的结果必然小于交换这两个数得出的结果</p>
<ul>
<li><p>货仓选址 &gt; 用数学和用函数来进行建模 &gt; f(x) = |x_1-x| + |x_2
- x| + .. &gt; 猜是中位数 考虑进行分组
二维，基于随机的思路；如果总和变小就有情况获取</p></li>
<li><p>推公式 &gt;
贪心某种常用的做法其实是推公式，然后使用不等式从而得到最优解 &gt;
均值不等式，调和不等死，柯西不等式，绝对值不等式，几何不等式 &gt;
贪心大多问题都是数学上研究过的问题</p></li>
</ul>
<p>贪心得到的答案 &gt;= 最优解 贪心得到的答案 &lt;= 最优解 &gt;
同时比较大小，请注意要学会进行比较。不考虑不变项，然后加上和减去一个无关的变量
&gt; 此贪心的策略只会使最优解结果变小</p>
<ul>
<li>从数据范围反推算法复杂度以及算法内容（一般情况下，题目的时间为1s或者2s.
所以，C++代码中的操作次数控制在1e7最佳）
<ol type="1">
<li>n&lt;=30, 指数级别，dfs+剪枝，状态压缩dp</li>
<li>n&lt;=100, O(n^3) floyd, dp</li>
<li>n&lt;=1000, O(n^2) O(n^2 logn) dp,二分</li>
<li>n&lt;=1e4, O(n sqrt(n)) 块状链表特别难写，用不到</li>
<li>n&lt;=1e5, 最常见的是nlogn算法。线段树和树状数组特别复杂，没讲。
求凸包、求半平面交</li>
<li>n&lt;=1e6, O(n): hash, 双指针扫描, kmp, ac自动机;
常数比较小的O(nlogn): sort(即前面的系数特别小), 树状数组，heap,
ac自动机、线性筛素数 &gt; 树状数组和线段树都是用来解决线段的</li>
<li>n&lt;=1e7, O(n)</li>
<li>n&lt;=1e9, O(sqrt(n)) 判断质数，快速幂</li>
<li>n&lt;=1e18, O(logn) 最大公约数</li>
</ol></li>
<li>如何分析代码时间复杂度?
<ol type="1">
<li>纯循环，dp分析</li>
<li>递归，主定理，套公式求即可, todo</li>
<li>logn的分析，二分</li>
<li>双指针！！ 内层循环只加不减,两层</li>
<li>数据结构，单链表，删除和插入O(1); 栈，O(1);
单调栈，单调队列O(1）</li>
<li>kmp内层循环最多执行n次 22:44</li>
<li>并查集（!!!记住）O(1)，find最坏logn的效率，加状态压缩；再加按秩合并，loglogn</li>
<li>堆，插入和删除需要up和down, 走一遍，O(logn); 原始建堆 o(n)???</li>
<li>hash表，碰撞的概率特别低，平均来说，增删改查都是O(1) &gt;
和快排类似，最坏情况下非常坏，但概率低</li>
<li>搜索和图论：从最基本的出发
<ul>
<li>排列： 最后一层输出答案O(n), 查看树的分支来计算n!n</li>
<li>图的遍历：遍历所有的点，然后对每个点选择遍历所有的边。O(n+m)</li>
<li>迪杰斯特拉:n^2 mlogm (m&lt;=n^2&gt;)</li>
<li>bellsman-ford: nm</li>
<li>spfa, 匈牙利算法，最大流算法；? 实际很快，分析很慢</li>
<li>floyd, prim n^2 kruskal</li>
</ul></li>
<li>数学
<ul>
<li>欧式筛法， 调和级数 n/1+n/2+n/3 nlogn的级别，自然数的和;
如果是质数， n/1+n/2+n/3+n/5+n/7+... nloglogn的级别</li>
<li>最大公约数，辗转相除法，logn</li>
<li>快速幂 logk的级别</li>
</ul></li>
<li>动态规划问题的计算量=状态数量*状态转移的计算量
<ul>
<li>树形DP: 每个点只会遍历一次，遍历其所有的边 O(m)</li>
<li>滑雪： n^2 * 1</li>
</ul></li>
<li>贪心： 排序+循环</li>
</ol></li>
</ul>
<p>1 Byte = 8 bit 1 KB = 1024 Byte 1 MB = 1024<em>1024 Byte 1 GB =
1024</em>1024 Byte</p>
<p>int 4 Byte char 1 Byte double, long long 8 Byte *point
4Byte(32位机器) 8Byte(64位机器) bool 1 Byte</p>
<p>64MB = 2^26 Byte 2^26 / 4 - 2^24, 1600 0000 1e7</p>
<p>直接用代码算即可 &gt; sizeof v + sizeof w + sizeof w 单位是字节 &gt;
但注意有时算的时候开了很大的空间，但是没用是没事的，因为操作系统不会把数据一下子全部给你,
会一点一点给。 所以memset(), 只需要设计到要用的量即可 &gt;
注意递归栈也需要空间， logn</p>
<blockquote>
<p>对于网速来说， 8M/s 指的是8M位， 实际上每秒最多只能下载1MB的数据；
对于流量来说是兆字节 # 总结 数据结构的使用 最值，堆
区间和，区间数组，树状数组，线段树 有序链表，平衡树，set</p>
</blockquote>
<p>技巧：一维转为二维</p>
<p>开始审题很重要，不要什么都没有就往前面跑，首先心理要有一个很好的思路
还有模板哪些步骤一开始只是套路，越到后面越没有必要去实实在在地在意它，这样是完全地浪费功夫的感觉</p>
<ul>
<li>高精度压位 int 2<em>10^10 加法一般压9位 乘法一般压4位
10000</em>10000=1e &gt;
实际上的想法就是在进行高精度计算的时候，一位一位用char来做太费时间和内存了；可以考虑用int来做，
加法9位9位地压，乘法4位4位地压</li>
</ul>
<p>从高位开始读数： 整个数一直左移 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char str[7]=&#x27;121213&#x27;</span><br><span class="line">for(int i=0, t=0;i &lt; n;i++)&#123;</span><br><span class="line">    s= s*10 + str[i]-&#x27;0&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从低位开始读数 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char str[7]=&#x27;121212&#x27;</span><br><span class="line">for(int i=0, s=0,t=1;i&lt;n;i++)&#123; // t表示每一位的进制，每位的数乘以每位的进制</span><br><span class="line">    s += (a[i]-&#x27;0&#x27;)*t;</span><br><span class="line">    t*=10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DP的属性可以有布尔值之间的传递，长度，最值</p>
<p>DFS 递归 BFS 队列 循环 # 错误 - Segmelut Flait
数组，全局变量局部不可访问 数组长度未开够 使用删代码法</p>
<p>将函数return false; 如果问题未改变，则说明不是该函数的问题 -
TLE时间受限 算法出错 局部变量初试为初始化 循环变量名抄错</p>
<p>c++ inline
编译器在执行不会将其转化为函数调用，少了函数栈的空间，一般适用于简单的函数
register int 将变量保存在寄存器中</p>
<p>遍历想想也就两大类啊，深度优先和宽度优先 宽度优先就是层次遍历</p>
<p>宽度优先具有最小的性质，一定能够得出到根节点的最短性。但是宽度优先需要耗费很大的空间，至少存储两层的节点，所以极其耗费空间</p>
<p>深度优先虽然没有最小的性质，但是空间复杂度低，只需要空间复杂度为树的高度的空间</p>
<p>书上的公式是书面语，不是大白话，讲究优美性，实际理解时往往需要抽象我们所理解的大白话。</p>
<p>讲题的境界： 怎么想出来的？正确性</p>
<p>动作记忆！！！</p>
<p>C++中0，NULL，nullptr是一个东西</p>
<p>声音越小越有气势，更重要的是听别人的东西，把别人的东西听懂</p>
<h2 id="待做">待做</h2>
<p>https://blog.csdn.net/weixin_39778570/article/details/86484020
基本算法篇 - 模拟 - 枚举 - 排序 - 分治 - 二分 - 倍增 - 贪心</p>
<p>链表 指针 二叉树 二叉搜索树</p>
<blockquote>
<p>二叉搜索树，父节点， 左孩子节点的函数值严格小于父节点，
右孩子节点的函数值严格大于父节点</p>
</blockquote>
<p>后序遍历： 左、右、中 前序遍历： 中，左，右 中序遍历： 左，中，右</p>
<p>进一步总结 ## 总结</p>
<p>DFS两种框架</p>
<p>第一种 起始点未定, 用层数来表明，子节点都很清晰 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int n;</span><br><span class="line">int path[]</span><br><span class="line">dfs(int i)&#123;</span><br><span class="line">    if(i==n)&#123;</span><br><span class="line">        collect path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        if(check(i))&#123;</span><br><span class="line">            p[i] = 1;  //  赋值</span><br><span class="line"></span><br><span class="line">            dfs(s);</span><br><span class="line"></span><br><span class="line">            p[i] = 0;  // 恢复</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(0)</span><br></pre></td></tr></table></figure></p>
<p>第二种 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int st[N];</span><br><span class="line">int path[N];  //?</span><br><span class="line"></span><br><span class="line">dfs(int v)&#123;</span><br><span class="line">    st[v] = true; // 保证遍历不重复，不需要恢复</span><br><span class="line">    path[i] = f;</span><br><span class="line"></span><br><span class="line">    if(end)  collect</span><br><span class="line">    for(w: vw)</span><br><span class="line">        if(!st)  dfs(w);</span><br><span class="line"></span><br><span class="line">    path[i] = -1; // 其他变量需要恢复</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>BFS的写法 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int fun( )&#123;</span><br><span class="line"></span><br><span class="line">    q.push(v);</span><br><span class="line">    while(q.size()) &#123;</span><br><span class="line">        auto t=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;4;i++)</span><br><span class="line">            if(check(i)) q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> // ? 层次怎么体现？？</span><br></pre></td></tr></table></figure></p>
<p>DP的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f[0][0] = ?</span><br><span class="line">for(i:1~n)</span><br><span class="line">    for(j:1~m)</span><br><span class="line">        f[i][j] = f[i-1][j-1]</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;f[n][m]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int f(int i,int j)&#123;</span><br><span class="line">    if(f[i][j]!=-1) return f[i][j];</span><br><span class="line">    if(base) &#123;</span><br><span class="line">        初值</span><br><span class="line">    &#125;</span><br><span class="line">    res=?</span><br><span class="line"></span><br><span class="line">    for(i:1~n)</span><br><span class="line">        for(j:1~m)</span><br><span class="line">            res=f(i-1,j-1);</span><br><span class="line">    return f[i][j]=res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dfs(0,0)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dp[0][0]</span><br><span class="line"></span><br><span class="line">bool dp(int i,int j)&#123;</span><br><span class="line">    if(f[x][y]!=-1) return f[x][y];</span><br><span class="line">    if(base) &#123;</span><br><span class="line">        return ; // 这里一般是f[i][j]具有某种具体含义的，比如两个字符串匹配，A的前i个字母和B的前j个字母这类极大值情况具有意义的</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[x][y] = dp[x+1][y+2] // 看这里的状态是否好推演</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DP集合划分的方式总结</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/python-pylint-29782d020373/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/python-pylint-29782d020373/" class="post-title-link" itemprop="url">python pylint</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-15 13:15:11" itemprop="dateCreated datePublished" datetime="2019-09-15T13:15:11+08:00">2019-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/coding-reference/" itemprop="url" rel="index"><span itemprop="name">coding_reference</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/coding-reference/pylint/" itemprop="url" rel="index"><span itemprop="name">pylint</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>58</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>https://blog.csdn.net/Jason_Lewis/article/details/75386598</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/deeplearning-dropout-48098b712722/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/deeplearning-dropout-48098b712722/" class="post-title-link" itemprop="url">deeplearning dropout</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-12 21:27:26" itemprop="dateCreated datePublished" datetime="2019-09-12T21:27:26+08:00">2019-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/deeplearning/" itemprop="url" rel="index"><span itemprop="name">deeplearning</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/deeplearning/dropout/" itemprop="url" rel="index"><span itemprop="name">dropout</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>87</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>dropout的总结
https://blog.csdn.net/stdcoutzyx/article/details/49022443</p>
<p>bias &gt; output += bias</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/vscode-using-e71ff5fd83de/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/vscode-using-e71ff5fd83de/" class="post-title-link" itemprop="url">vscode using</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-12 20:35:29" itemprop="dateCreated datePublished" datetime="2019-09-12T20:35:29+08:00">2019-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tools/" itemprop="url" rel="index"><span itemprop="name">tools</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tools/vscode/" itemprop="url" rel="index"><span itemprop="name">vscode</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>26</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>? 关闭终端的快捷键: 暂时未发现</p>
<p>搜索文件: ctrl+p</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/numpy-study-99af00a28daf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/numpy-study-99af00a28daf/" class="post-title-link" itemprop="url">numpy study</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-12 19:41:55" itemprop="dateCreated datePublished" datetime="2019-09-12T19:41:55+08:00">2019-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/machinelearning/" itemprop="url" rel="index"><span itemprop="name">machinelearning</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/machinelearning/numpy/" itemprop="url" rel="index"><span itemprop="name">numpy</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="numpy">2. numpy</h2>
<p>https://www.numpy.org.cn/</p>
<blockquote>
<p>python
太慢！！有个点就是关于python的切片都是复制，不是引用！不同numpy
numpy基于C直接操作连续内存空间，比纯Python快10到100倍，并且使用内存更少</p>
</blockquote>
<p>numpy提出的ndarry很好用,主要理解通用的数值数据处理上的强大功能，特别是在数组操作上
pandas主要用于统计和分析</p>
<p>！！！ 如何用整个数组的思想 &gt; %time 可以直接统计时间</p>
<h3 id="ndarry">2.1 ndarry</h3>
<ul>
<li>属性与方法 &gt; 可以认为如果改变了属性，必然会返回一个新的结构
<ul>
<li>ar.shape: () 元组
<ul>
<li>di.reshape(): 改变形状, 返回一个新的数组 &gt; di.reshape() ==
np.reshape(di, 4)</li>
</ul></li>
<li>ar.dtype:
<ul>
<li>基本类型
<ul>
<li>int64: 指的是位数, 64位，即8字节; 代码i8</li>
<li>float64 default</li>
<li>uint8</li>
<li>complex64: 用两个32位的浮点数表示 &gt; ? 复数如何定义</li>
<li>bool: 代码?</li>
<li>object: python对象 代码O</li>
<li>string_: 固定长度 S10, 10字节，每个字符一字节</li>
<li>unicode_: U10</li>
</ul></li>
<li>ar.astype(np.float64): 转换类型, 总会创建一个新的数组</li>
</ul></li>
<li>ar.ndim： 有几维</li>
<li>ar.T: 返回转置，仍然未原数组的引用</li>
<li>ar.tranpose((1,0,2)):
轴对换，按照给定的元组进行重新轴的安排，比如获得新的数组</li>
<li>转置=轴变换, ar.swapaxes(1,2): x,y,z;
这里就是对y轴和z轴进行变换</li>
</ul></li>
<li>创建
<ul>
<li>已有
<ul>
<li>np.array(sequence， dtype="")</li>
<li>np.asarray(arr) // 不确定是否是该类型</li>
</ul></li>
<li>特定矩阵
<ul>
<li>np.ones(shape) , ones_like(x): 根据shape和类型创建</li>
<li>np.zeros(shape) zeros_like np.zeros((2,3))</li>
<li>np.eye(3) 单位矩阵</li>
<li>np.arange(10): 返回一维矩阵</li>
<li>np.linspace(a, b, nums): 返回[a,b]闭区间的nums个数的数据</li>
</ul></li>
<li>随机初始化
<ul>
<li>随机数： np.random.randint(a, size)</li>
<li>不同: np.random.choice(a, size=(4,))</li>
<li>np.random.shuffle(arr) 打乱现有的</li>
</ul></li>
</ul></li>
<li>运算: vectorization, 作用到元素级别
<ul>
<li>基本操作 &gt; *, -, /, **, &gt;(bool)， == &gt;
保证shape相同，不同用到广播
<ul>
<li>基本操作上可以大做文章，比如跟已知的数组进行比较，</li>
<li>条件之间可以进行 ==, !=, ~, &amp;, | 等多种操作 &gt; 对于<em>,
如果两个操作树维度不等，按低维开始进行运算 </em>相等于 np.multiply
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data[name == &#x27;Bob&#x27;, 2:], 如果name是一维矩阵，矩阵的长度需要与比较的轴的长度相等</span><br><span class="line">mask = (names = &#x27;Bob&#x27;) | (names == &#x27;Will&#x27;), 注意这里and,or无效，要使用&amp;，|</span><br></pre></td></tr></table></figure> &gt;
因此，可以通过布尔将数组中所有的值给置为某种操作。</li>
</ul></li>
<li>切片操作 &gt;
注意是原始数组的试图，即不会被赋值，任何其他操作都会反映到原变化.
即是等号也会如此 &gt; ? 如何复制, reshape是否会改变原本的值 &gt;
看了下，是不能step的</li>
<li>花式索引
<ul>
<li>arr[i]:
即如果是二维的，那么默认操作就会直接将该轴对应的值全都进行改变</li>
<li>arr[[1,2,3],[1,2,3]]: 可以直接返回对应的列和行， 直接进行切片</li>
</ul></li>
<li>扩展，赋值运算 拷贝arr.copy()
<ul>
<li>np.tile(arr, shape) &gt;
如果shape的维数大于arr的维数，那么直接按shape的坐标来分配 &gt; 否则,
就考虑操作在对应维度上，比如先操作在行上，接着在列上，等等</li>
<li>np.repeat(3, 4) [3,3,3,3] &gt; np.repeat(arr, [1,2], axis=0) //
axis轴上, 第0行复制1次，第1行复制2次</li>
</ul></li>
<li>stack 将arr进行合并，打包在一起
<ul>
<li>vstack((arr1, arr2)): 默认 axis=1, 组合在一起 =
np.stack((arr1,arr2), axis=0)</li>
<li>hstack((arr1, arr2)): [1,2,3] , [2,3,4] =&gt; [1,2,3,2,3,4]:
一维扁平化的感觉</li>
<li>stack((arr1, arr2)): 高级，重新组合为性的数组</li>
</ul></li>
</ul></li>
<li>高级操作
<ul>
<li>通用函数ufunc: 快速的元素级数组函数
<ul>
<li>一元 &gt; 如果设置一个参数，返回array; 设置两个参数，在原数组操作;
当然二元除外
<ul>
<li>幂函数 np.sqrt(arr) <code>arr**0.5</code>; np.square(arr)
<code>arr**2</code></li>
<li>指数函数, 底数函数 np.exp(arr) np.log(arr) np.log10() np.log2(),
np.log1p(arr) <code>log(1+x)</code> &gt;
这里参数可以是一个，即对一个数组进行统计；如果是两个矩阵，则对应元素级别做</li>
<li>拆分小数 remainer, whole_part = np.modf(arr):
返回小数的小数，整数部分</li>
<li>绝对值 np.abs, fabs: 对于非复数值，fabs更快</li>
<li>获取符号 np.sign(arr): 获取符号</li>
<li>对数进行近似整数化 np.ceil() 上; np.floor() 下; np.rint()
四舍五入;</li>
<li>判断值的类型，np.isnan() 不是一个数字的; np.isfinite() np.isinf</li>
<li>三角函数 cos, cosh, sin</li>
<li>逻辑非 np.logical_not -arr</li>
</ul></li>
<li>二元
<ul>
<li>最值np.maximum(x,y) np.NaN为最终结果 np.fmax() np.NaN不考虑;
np.minimum(), np.fmin()</li>
<li>加减 np.add(), np.subtract()</li>
<li>乘 np.multipy, 除np.divide, 丢弃余数 np.floor_divide, 向下整除;
np.mod求余</li>
<li>乘方 np.power</li>
<li>传递正负号 np.copysign</li>
<li>greater, greater_equal, less, less_equal, not_equal</li>
<li>&amp;, | , ^ , ~可对数组使用，list不行, 使用np.logical_and,
np.logical_or, np.logical_xor</li>
</ul></li>
</ul></li>
<li>利用数组进行数据处理
<ul>
<li>范围值 np.arange(start, end, step)</li>
<li>网格数据 x,y = np.meshgrid(arr_1d, arr_1d) &gt; 得到
arr_1d作为x轴的网格数据, 即x的每列元素相同</li>
</ul></li>
<li>将条件逻辑表述为数组运算 np.where(cond, true_ope, false_ope) &gt;
将条件表达式的思想进行转变 <code>result = [(x if c else y) for x,y,c in
zip(xarr, yarr, cond)]</code>
<ul>
<li>数组比较res = np.where(cond, xarr, yarr) //后面两个不必为数组 &gt;
cond为真, 按xarr操作；否则，按yarr操作</li>
<li>值比较 res = np.where(cond, 2, -2)</li>
<li>值、数组比较 res = np.where(arr&gt;0, 2, arr)</li>
</ul></li>
<li>数学和统计方法 &gt; aggregation, reduction, 属于arr的操作;
axis是站在留下来的数据角度思考的
<ul>
<li>和，平均值 arr.mean(), arr.sum() &gt; axis=0,
表示留下第一维,其余维度都会进行计算;
如果，如果没有参数，则对所有元素操作</li>
<li>最值 max, min</li>
<li>最值索引 agrmin, argmax, 同上</li>
<li>标准差和方差 std, var</li>
<li>累加和 累加积 arr.cursum() arr.cumprod , 同上, axis=0,
0维不进行操作</li>
</ul></li>
<li>用于布尔数组的方法
<ul>
<li>(arr==1).sum() bool当做0和1</li>
<li>存在 (arr==1).any()</li>
<li>任意 (arr==1).all()</li>
</ul></li>
<li>排序
<ul>
<li>就地排序 arr.sort() ; 返回副本 np.sort() &gt; 参数为1,
对第1维进行排序</li>
</ul></li>
<li>唯一化及集合逻辑
<ul>
<li>返回唯一元素 np.unique(x)</li>
<li>返回公共元素 np.intersect(x,y)</li>
<li>返回并集 np.union1d(x,y)</li>
<li>返回是否包含的布尔数组 np.in1d()</li>
<li>集合的差 np.setdiff1d()</li>
<li>集合的对称差 np.setxor1d()</li>
</ul></li>
<li>用于数组的文件输入输出
<ul>
<li>np.save, np.load</li>
</ul></li>
<li>线性代数 <code>numpy.linalg</code>
<ul>
<li>矩阵相乘 x.dot(y) np.dot(x,y) x @ np.ones(3)</li>
<li>对角矩阵的操作 arrdd=np.diag(arr1d) arr1d=np.diag(arrdd)</li>
<li>计算对角线元素的和 a.trace() np.trace()</li>
<li>行列式 det()</li>
<li>本特征值、本征向量？ <span class="math inline">\(D = U^T A
U\)</span> U^T, np.diag(A) = LA.eig(D) &gt; 为什么有本?</li>
<li>QR分解？ qr</li>
<li>SVD分解？ svd</li>
<li>矩阵的逆 inv</li>
<li>解线性方程组 Ax=b, x=LA.solve(A,b)</li>
<li>最小二乘解？ x=LA.lstsq(A,b)</li>
</ul></li>
<li>伪随机数生成 import np.random as nrd &gt; np.random.seed(1234):
指定了全局状态;
那么每次设置这个值时，第一次都会产生相同的数,这个特点可以进行利用; &gt;
想真正的实现随机数，1. 随机种子随机指定： 2. 使用np.random.RandomState,
创建一个与其他隔离的随机数生成器
<ul>
<li>指定随机种子
<ul>
<li>nrd.seed(int) 随机种子</li>
</ul></li>
<li>返回某种数
<ul>
<li>nrd.permutation(arr/list1)
返回一个序列的随机排列或返回一个随机排列的范围</li>
<li>shuffle(arr/list1) 对一个序列就地随机排列</li>
<li>randint(a, size=shape) [0,a) randint(a,b, size=shape) [a,b) &gt;
注意和python自带的randint不同[a,b]</li>
</ul></li>
<li>根据分布产生样本值，paras = (d1,d2,d3)
<ul>
<li>rand(d1,d2) 产生均匀分布的样本值 [0,1)
随机数的分布范围属于【0,1)</li>
<li>binomial 产生二项分布的样本值</li>
<li>normal(loc=0.0, scale=1.0) randn 产生正态高斯分布的样本值</li>
<li>beta 产生beta分布的样本值</li>
<li>chisquare 卡方分布</li>
<li>gamma Gamma分布</li>
<li>uniform [0,1) 均匀分布</li>
</ul></li>
<li>均匀分布 ranf = random = sample = random_sample [0,1)</li>
</ul></li>
<li>随机漫步 &gt;
一个简单随机漫步的例子：从0开始，步长1和-1出现的概率相等;
即取0,1之间的随机数,然后记录每一步的位置，就可以认为走路的过程为随机漫步
&gt; 多维，一次模拟多次随机漫步; 也可用分布来模拟随机漫步</li>
</ul></li>
</ul>
<blockquote>
<p>一些tips: 转换为对角阵，使用乘法来做 1. 对列求和, 然后做每行；直接 T
/ np.sum(T, axis=1, keepdims=True) // 保证最后得出的结果是矩阵 2.
np.mat(A): 返回矩阵的抽象类型，什么时候用到也不知道</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/spcipy-study-4b76b86cf66d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/spcipy-study-4b76b86cf66d/" class="post-title-link" itemprop="url">spcipy study</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-12 14:24:20" itemprop="dateCreated datePublished" datetime="2019-09-12T14:24:20+08:00">2019-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/machinelearning/" itemprop="url" rel="index"><span itemprop="name">machinelearning</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/machinelearning/scipy/" itemprop="url" rel="index"><span itemprop="name">scipy</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概览">概览</h2>
<p>scipy库依赖于numpy库，它提供了便捷且快速的N维数组操作。构建scipy库的原因是，它能与numpy数组一起工作，并提供许多用户友好和高效的数字实践，例如数值积分和优化的教程
numerical integration, interpolation插值， optimization, linear
algebra线性代数 statistics统计</p>
<ul>
<li>cluster： cluster algorithms
<ul>
<li>vq: 只支持矢量化 vector quantization, k-means algorithms
<ul>
<li>whiten: normalize a group of observations on a per feature
basis</li>
<li>vq: assign codes from a code book to observations</li>
<li>kmeans:</li>
</ul></li>
<li>hierarchy: hierarchical and agglomerative clustering,
支持层次聚类和凝聚聚类; 1. generating hierarchical clusters from
distance matrices 2. calculating statistics on clusters 3. cutting
linkages to generate flat clusters 4. visualizing clusters with
dendrograms</li>
</ul></li>
<li>constants: physcial and mathematical constants
<ul>
<li>math
<ul>
<li>pi</li>
<li>golden</li>
<li>golden_ratio</li>
</ul></li>
<li>physical
<ul>
<li>c: 光速</li>
</ul></li>
<li>quick getting: constants.value(u"elementary charge"), unit,
precision, find</li>
</ul></li>
<li>fftpack: fast fourier transform routines
<ul>
<li>fft: discrete 离散, both real or complex sequence</li>
<li>ifft: inverse相反</li>
<li>fft2, ifft2: 2-d</li>
<li>fftn, ifftn</li>
<li>dct 余弦变换</li>
<li>dst: discrete sine transform</li>
</ul></li>
<li>integrate: integration and orginary differential equation slovers
<ul>
<li>quad: definite integral: 有限积分，三个参数，函数、上下限</li>
<li>dblquad: dobule类型</li>
<li>tplquad: 计算多重积分的表达式, 积分限是函数</li>
<li>nquad: 多重积分，积分限是具体的值</li>
<li>fixed_quad: 计算一个固定的积分使用fixed-order的高斯分布</li>
<li>trapz: 使用复合梯度算法计算, 同理simpz, romb</li>
</ul></li>
<li>interpolate: 插值, interpolation and smoothing splines
<ul>
<li>interp1d</li>
</ul></li>
<li>io: input and output &gt; loadmat, savemat,可以加载matlab文件</li>
<li>linalg: linear algebra
<ul>
<li>basic
<ul>
<li>inv</li>
<li>solve(a,b) a*x=b</li>
<li>solve_banded(): a是带状矩阵</li>
<li>solve_triangular(a,b): 解决三角举证</li>
<li>det 行列式</li>
<li>norm 范数</li>
<li>lstsq() 二乘解</li>
<li>pinv: 矩阵的伪逆</li>
<li>kron: 元素乘积</li>
</ul></li>
<li>eigenvalue problems: 特征值问题
<ul>
<li>eig: 方阵特征值问题</li>
</ul></li>
<li>Decompositions
<ul>
<li>lu: LU分解</li>
<li>svd： 奇异值分解</li>
<li>qr：QR分解</li>
</ul></li>
<li>Matrix Functions
<ul>
<li>expm: 使用近似方法</li>
</ul></li>
<li>Matrix Equation Solvers</li>
</ul></li>
<li>ndimage: n-dimensional image processing
<ul>
<li>convolve(): 多维卷积操作</li>
<li>gaussian_filter(): 高斯过滤</li>
<li>laplace： 拉普拉斯过滤</li>
<li>floutier_ellipsoid: 多维ellipsoid fourier filter</li>
</ul></li>
<li>odr: orthogoal distance regression 正交距离回归问题</li>
<li>optimize: optimization and root-finding routines
<ul>
<li>Optimization
<ul>
<li>scalar function标量函数: minimize_scalar</li>
<li>Local(Multivariate) Optimization: 多元回归</li>
<li>Global Optimization: brute()</li>
<li>Least-squares and Curve Fitting
<ul>
<li>nonlinear</li>
<li>linear</li>
<li>curve fitting</li>
</ul></li>
<li>Root finding</li>
</ul></li>
<li>Linear Programming
<ul>
<li>linprog</li>
</ul></li>
<li>Utilities
<ul>
<li>Finite-Difference Approximation
<ul>
<li>approx_fprime</li>
<li>check_grad</li>
</ul></li>
<li>Line Search</li>
<li>Hessian Approximation</li>
<li>Benchmark Problems</li>
</ul></li>
<li>Legacy Fuctions 遗留功能
<ul>
<li>fmin</li>
</ul></li>
</ul></li>
<li>signal: signal processing
<ul>
<li>convolution
<ul>
<li>convolve</li>
</ul></li>
<li>B-splines
<ul>
<li>bspline, cubic</li>
</ul></li>
<li>Filtering</li>
<li>Filter design</li>
<li>Matlab-style IIR filter design: butter, cheby1</li>
<li>Continuous-Time Linear Systems: lti()</li>
<li>Discrete-Time Linear Systems</li>
<li>LTI Representations</li>
<li>Waveforms</li>
<li>Window functions</li>
<li>Wavelets</li>
<li>Peak finding</li>
<li>Spectral Analysis</li>
</ul></li>
<li>sparse: sparse matrices and associated routines
<ul>
<li>Contents
<ul>
<li>bsr_matrix: block sparse row matrix</li>
<li>coo_matrix: coordinate format</li>
<li>csr_matrix,, csc_matrix: compressed sparse row matrix</li>
<li>dia_matrix: sparse matrix with disgonal storage</li>
<li>dok_matrix: dictionary of keys based sparse matrix</li>
<li>lil_matrix: row-based linked list sparse matrix</li>
<li>spmatrix: 以上的所有类型</li>
</ul></li>
<li>Functions
<ul>
<li>eye(): ones on diagonal</li>
<li>identity()</li>
<li>kron(A,B)</li>
<li>kronsum</li>
<li>diags(), spdiags</li>
<li>block_diag</li>
<li>tril</li>
<li>bmat: build, hstack, vstack</li>
<li>rand: uniformly distributed values. random()</li>
</ul></li>
<li>Save and load sparse matrices</li>
<li>Sparse matrix tools: find(A)</li>
<li>identifying sparse matrices: issparse(x)</li>
</ul></li>
<li>spatial: spatial data structures and algorithms
<ul>
<li>Spatial Transformations</li>
<li>Nearest-neighbor Queries
<ul>
<li>KDTree</li>
<li>ckDTree</li>
<li>Rectangle: Hyperrectangel</li>
</ul></li>
<li>Delaunay Triangulation, Convex Hulls and Voronoi Diagrams</li>
<li>Plotting Helpers</li>
<li>Simplex representation</li>
</ul></li>
<li>special special functions</li>
<li>stats: statistical distributions and function
<ul>
<li>Statistical functions</li>
<li>Continuous distributions</li>
<li>Multivariate distributions</li>
<li>Discrete distributions</li>
<li>Summary statistics: descrube, gmean</li>
<li>Frequency statistics: cumfreq</li>
<li>Correlation functions</li>
<li>Statistical tests</li>
<li>Transformations</li>
</ul></li>
</ul>
<h2 id="常用">常用</h2>
<ul>
<li>bsr_matrix: block sparse row matrix - coo_matrix: coordinate format
- csr_matrix,, csc_matrix: compressed sparse row matrix - dia_matrix:
sparse matrix with disgonal storage - dok_matrix: dictionary of keys
based sparse matrix - lil_matrix: row-based linked list sparse matrix -
spmatrix: 以上的所有类型</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/blog-todo-669568eee92d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/blog-todo-669568eee92d/" class="post-title-link" itemprop="url">blog:todo</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-12 13:37:22" itemprop="dateCreated datePublished" datetime="2019-09-12T13:37:22+08:00">2019-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/todo/" itemprop="url" rel="index"><span itemprop="name">todo</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/todo/hexo/" itemprop="url" rel="index"><span itemprop="name">hexo</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>61</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol type="1">
<li><p>文字加密访问</p></li>
<li><p>收录到百度</p></li>
<li><p>new 文章时，可选参数决定是否需要创建对应的文件夹 &gt; ctrl+`,
打开终端</p></li>
<li><p>仿照博客园，添加日历</p></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/gnn-semi-paper-code-read-44546d201ff5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/gnn-semi-paper-code-read-44546d201ff5/" class="post-title-link" itemprop="url">semi-paper code read</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-12 12:47:23" itemprop="dateCreated datePublished" datetime="2019-09-12T12:47:23+08:00">2019-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/gnn/" itemprop="url" rel="index"><span itemprop="name">gnn</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/gnn/semi-gnn/" itemprop="url" rel="index"><span itemprop="name">semi-gnn</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="论文1">论文1</h2>
<p>https://github.com/tkipf/gcn</p>
<p>Data - n<em>n n</em>d d=c:channels e=f:classes</p>
<ol type="1">
<li>gcn 文件组织结构
<ul>
<li>readme.md
<ul>
<li>data: d=c: chanels e=f:classes
<ul>
<li>citation network data: cora, citeseer, pubmed</li>
<li>nell: revisiting semi-supervised learning with graph embedding</li>
</ul></li>
<li>model: gcn, gcn_cheby, dense</li>
</ul></li>
<li>gcn
<ul>
<li>data
<ul>
<li>.tx the feature vectors of test instances</li>
<li>.ty the one-hot labels</li>
<li>.index the indices of test instances in graph, inductive
setting</li>
<li>.x : the feature vectors of the labeled training instances</li>
<li>.y : the labeled</li>
<li>.allx: all</li>
<li>.ally</li>
</ul></li>
<li>inits.py
<ul>
<li>uniform, glorot: [input_dim, output_dim], zeros, ones</li>
</ul></li>
<li>metrics.py
<ul>
<li>cross_entropy + accuary</li>
</ul></li>
<li>models.py
<ul>
<li>gcn: semi-superised</li>
<li>gcn_cheby: convolutional</li>
<li>dense: basic multi-layer perceptron</li>
<li>Model &gt; self.layers[0], 第一层的layer.
对第一层中的var的值，进行相加，这里的var只有weights, bias.
进行乘以固定系数相加 &gt; num_features_nonzero: dropout的方法也不同
<ul>
<li>init
<ul>
<li>name, logging</li>
<li>vars, placeholdres</li>
<li>layers, activations</li>
<li>inputs, outputs</li>
<li>loss, accuary</li>
<li>optimizer, opt_op</li>
</ul></li>
<li>build: tf.variable_scope(self.name)
<ul>
<li>build sequential layer model</li>
<li>store model variables for easy access</li>
<li>build metrics: weight_decay: 5e-4: weight for L2 loss on embedding
matrix. ???</li>
</ul></li>
<li>predict</li>
<li>_loss</li>
<li>_accuracy</li>
<li>save</li>
<li>load</li>
</ul></li>
<li>MLP
<ul>
<li><strong>init</strong>: inputs: features, input_dim, output_dim,
placeholders, optimizer, build</li>
<li>_loss: 变量的l2 loss???? += 交叉熵</li>
<li>_build; Dense</li>
</ul></li>
<li>GCN
<ul>
<li>_build: GraphConvolution</li>
</ul></li>
</ul></li>
<li>utils.py
<ul>
<li>load_data</li>
</ul></li>
<li>layers.py
<ul>
<li>get_layer_uid: 全场唯一uid</li>
<li>sparse_dropout: dropout for sparse tensors????</li>
<li>Layer
<ul>
<li>init: name, vars, logging, sparse_inputs</li>
<li>_call: return inputs</li>
<li>__call: add inputs, outputs ??? tf.summary.histogram()?//
为了方便展示直方图?</li>
<li>_log_vars: add vars in histogram</li>
</ul></li>
<li>Dense(Layer)
<ul>
<li>__init: input_dim, output_dim, placeholders, dropout=0.,
sparse_inputs, act, bias=false, featureless=false glorot()</li>
<li>_call
<ul>
<li>dropout:</li>
<li>transform: 是否使用稀疏矩阵相乘</li>
<li>bias: self.vars['bias']
没有输入的，只有输出，在隐藏层中，对结果产生影响</li>
</ul></li>
</ul></li>
<li>GraphConvolution: graph convolution layer(Layer)
<ul>
<li>act? support? bias? featureless? act: tensorflow activation</li>
<li>init
<ul>
<li>support 变量的个数 weights_i: glorot bias=zeros</li>
</ul></li>
<li>_call
<ul>
<li>convlve ??</li>
</ul></li>
</ul></li>
</ul></li>
<li>train.py
<ul>
<li>flags &gt; dataset, model, learning_rate, epochs,, hidden1-16,
dropout
<ul>
<li>weight_decay: weight for l2 loss on embedding matrix</li>
<li>early_stopping</li>
<li>max_degree: Chebyshev 不等式的阶</li>
</ul></li>
<li>placeholders
<ul>
<li>support: [preprocess_adj(adj)] &gt; 为什么要这么做?
因为gcn_cheby模型中每层的A实际上是不一样的</li>
<li>features:</li>
<li>labels:</li>
<li>labels_mask:</li>
<li>dropout: 注意稀疏矩阵和稠密矩阵 dropout方法还不一样</li>
<li>num_feature_nonzero:</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<p>corn - x: 140,1433 tx: 1000,1433 ty: 1000, 7 - allx: 1708 1433 ?
为何总数不相等</p>
<pre><code>- (allx,tx) 说明这两个不相等 </code></pre>
<h3 id="论文2">论文2</h3>
<p>https://github.com/kimiyoung/planetoid</p>
<ul>
<li>test_ind.py: induce model 的测试</li>
<li>test_trans.py: transive model的测试</li>
<li>ind_model.py: model add_data build gen_train_inst gen_graph
gen_lable_graph</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ypwang.github.io/2019/daily-thinking-7d135d21c29f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/daily-thinking-7d135d21c29f/" class="post-title-link" itemprop="url">daily thinking</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-12 00:22:55" itemprop="dateCreated datePublished" datetime="2019-09-12T00:22:55+08:00">2019-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/daily/" itemprop="url" rel="index"><span itemprop="name">daily</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/daily/summary/" itemprop="url" rel="index"><span itemprop="name">summary</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>感觉不及时写写自己的想法，自己可能会对自己所犯的错误记得不够牢靠</p>
<h2 id="一点想法">一点想法</h2>
<h3 id="问题">问题</h3>
<ol type="1">
<li><p>前段时间，没头没脑地看似很认真地同时并行地学习tensorflow，结果发现笔记也有很多。其实还是给忘的差不多了，仍然不会；
&gt; ! 某段时间应该集中在一件事情上，事情不在多，在精</p></li>
<li><p>用来三天时间搭博客，前面看一些教程，东看看西看看，结果一遇到bug啥都不会。资料不是最新的，不是学习的官方的资料
&gt; ! 一定要自己对大纲了解，以及学习最官方的资料</p></li>
<li><p>关于论文的梯度公式看了很多篇文章以及进行推导，结果实现却花了很多时间仍未完成。
&gt; !
一开始学习的途径不对，计算机最大的特点就是在于实践！每做一件事情时请务必动手</p></li>
<li><p>论文太多，太杂? 感觉看不过来 &gt; ! 学会慢慢地分类</p></li>
<li><p>比如画出一个图形，其实用matplotlib很好画，可就是没想通？ &gt;
记住别人的设计是面向对象的，图灵机，一切都是由最简单的堆叠而成</p></li>
<li><p>代码迟迟不想下手 &gt;
记住！代码这件事，只有不断地练习；谨记！永远不要期望第一版的代码有多好，重点是自己的想法实现了才是最重要的；
而且当你做了之后才发现自己哪些地方问题特别大</p></li>
<li><p>时间应该花在最基本的东西的学习和了解上! &gt;
最基础的东西应该要反复过才行，不要贪多</p></li>
<li><p>现在的时间自己仍然不可控 &gt; !
现在最重要的是能把自己的想法做完和事情做完，其他地慢慢就会会了
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/daily-thinking-7d135d21c29f/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yun-Pan Wang"
      src="/images/default-avatar.png">
  <p class="site-author-name" itemprop="name">Yun-Pan Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">115</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AugF" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AugF" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wangyp@smail.nju.edu.cn" title="E-Mail → mailto:wangyp@smail.nju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/Joswxe" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;Joswxe" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.google.com/" title="https:&#x2F;&#x2F;www.google.com" rel="noopener" target="_blank">Google</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://cn.bing.com/" title="https:&#x2F;&#x2F;cn.bing.com" rel="noopener" target="_blank">Bing</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">Baidu</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">[object Object]</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">466k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:04</span>
</div>!

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://ypwang.github.io/page/11/',]
      });
      });
  </script>



</body>
</html>
