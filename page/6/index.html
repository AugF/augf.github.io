<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"augf.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Life&#39;s Notes">
<meta property="og:url" content="https://augf.github.io/page/6/index.html">
<meta property="og:site_name" content="Life&#39;s Notes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yun-Pan Wang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://augf.github.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Life's Notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Life's Notes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">岁月数载，愿不负韶华</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/algorithm-acwing-math/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/algorithm-acwing-math/" class="post-title-link" itemprop="url">algorithm acwing math</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 12:14:45" itemprop="dateCreated datePublished" datetime="2019-09-19T12:14:45+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/" itemprop="url" rel="index"><span itemprop="name">acwing</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/basic/" itemprop="url" rel="index"><span itemprop="name">basic</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/basic/math/" itemprop="url" rel="index"><span itemprop="name">math</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数论">1. 数论</h1>
<h2 id="质数">1.1 质数</h2>
<p>，合数从2开始的整数的定义
在大于1的整数中，如果只包含1和本身这两个约数，就变成质数，就就叫做素数</p>
<ul>
<li><p>质数的判定——试除法</p>
<ul>
<li>1--n-1</li>
<li>d | n, n/d | n, d&lt;=n/d sqrt(n)</li>
</ul></li>
<li><p>分解质因数</p>
<ul>
<li>只需要从小到大模拟 logn-sqrt(n) &gt; 思想：
当碰见第一个质数时，它肯定是，因为前面都不成立，说明它与前面的任意数都不互质。然后怎么搞，我把目标数有它的因子全给搞完，那么得到的这个新数就一定不再整除这个质数了。于是，碰到下一个整除的数必然又满足前面的性质。
&gt;
还有这里的上界依然是砍一半，为什么呢，因为这里不可能会有两个大于的数，所以这里就是用的一个大于的数来做的，这样就很清晰了</li>
</ul></li>
<li><p>筛质数 一种考虑方法，将一个数和它的倍数全部删掉，最终留下一些值
调和级数：1+1/2+1/3+...=lnn + c, c欧拉常数 &gt; nlnn --&gt; &lt; nlogn
&gt; 任何合数都可以写成质因数乘积之和 &gt; 质数定理： 1-n中n/lnn个质数。
&gt; 真实的复杂度： nloglogn</p>
<ul>
<li><p>朴素筛法</p></li>
<li><p>埃式筛法</p></li>
<li><p>线性筛法 &gt; 1. i%pj==0, pj一定是i的最小正因子 &gt; 2. i%pj!=0,
pj也一定小于pj*i的最小正因子 &gt; 对于一个合数x，
pi是x的最小质因子，当枚举到n/i时一定会被删掉 &gt; ? 为什么枚举的值是n/i.
i&gt;pj</p></li>
</ul></li>
</ul>
<p>线性筛法理解： 对于每一个n，它会执行。
如果是合数，将小于它的最小质数的乘积，删掉。
如果是质数，会先加入，然后，删掉它乘以它的质数。 int
有两个问题？为什么筛到最小质数就可以？
因为将质因子从小到大排序，肯定一定有序了。
只用筛到最小即可，因为其他的有后面大的在构造过程中就会删掉。 比如考虑：
2<em>3</em>3, 实际在9时就会筛掉 而 2<em>2</em>2,
会被2*4筛掉，所以不用担心某个质因子的个数很多的情况</p>
<p>用素数负责增加新的质因子的种类。</p>
<p>为什么要到n/i即可？ 为什么范围是n/i, 因为i%n, n/i %n,
当到达一定大的程度i会很大，此时只需要用小的质因子就可以了。
因为是取等于，如果是质因子可以将其筛掉；</p>
<p>朴素筛法：未注意到合数可以分解为质因子之积的规律（自然数基本定理）
埃式筛法：简单地用加法来对质因子进行删除 n loglogn
线性筛法：使用了乘法的结论进一步对筛法进行了优化,
i只会被它的最小质因子筛掉 当第一次出现i%primes[j]==0,
因为是从最小开始枚举，所以primes[j]一定是i<em>primes[j]的最小质因子 i %
primes[j] != 0, 从小到大枚举，并且枚举0-primes[j],
所以prims[j]</em>i的质因子最小的一定是primes[j]</p>
<p>为什么是n/i,
当数据范围变大的时候，枚举的数的数量其实没那么多，因为最小质因子变大了。
如何定的？一定会在i*primes[j] &lt;= n, 停下来 为什么不加j<cnt>
i是合数，在其最小质因子处停下来
i是质数，在primes[j]=i的时候停下来，所以无论如何一定是满足条件的</p>
<h2 id="约数">1.2 约数</h2>
<p>一个数的约数是成对出现的 d % n, n/d % n</p>
<ol type="1">
<li>试除法求约数 sqrt(n) 把每一步的时间复杂度都要计算一下</li>
</ol>
<p>约数个数：1到n有多少个约数，讨论倍数 n+n/2+n/3+....n/n= nlogn
期望：logn 排序：lognloglogn &lt;&lt; &gt;
int范围内的整数，最多的约数大概1500左右过</p>
<p>调和级数 1+1/2+1/3+...+1/n = lnn +c 欧拉常数0.5772</p>
<p>很关键：只有每一步都不超时才可以做 20000 2ms</p>
<ol start="2" type="1">
<li><p>约数个数 自然数基本定理：(a1+1)(a2+1)(a3+1)...(ak+1)
乘法原理</p></li>
<li><p>约数之和 乘法原理与乘法展开之间的联系 (p^0 + p^1 + p^2 + ... +
p<sup>h1)(p</sup>0 + p^1 + ... + p<sup>h2)...(p</sup>0 + p^1 + ... +
p^hk)</p></li>
</ol>
<p>logK用来求快速幂 p<sup>0+p</sup>1+p<sup>2..+p</sup>k // logK的求法
&gt; 所有因子都是2，所以最大值logn &gt; 忌杀鸡用牛刀 4. 最大公约数：
欧几里得算法 辗转相除法 logN d|a, d|b, 则 d|ax+by (a, b) = (b, a mod
b)=(b, a-cb)</p>
<p>递归终点：(a,0)=a 因为0可以整除任何数</p>
<ol start="5" type="1">
<li>欧拉函数</li>
</ol>
<ul>
<li>公式法： 计算出某一个数的欧拉函数 p(n): 1-n之间与n互质的数 &gt;
互质的数即两个数之间的最大公约数为1 如何求？ 容斥原理 &gt;
去掉不互质的，留互质的</li>
<li>从1~N中去掉p1,p2,..,pk的所有倍数 &gt;
这里p1,p2,p3,...pk是由算术基本定理得出的 &gt; N- N/p1 - N/p2</li>
<li>加上所有pi*pj的倍数 &gt; + N/pipj</li>
<li>减去所有pi<em>pj</em>pk的倍数</li>
<li>一直做下去</li>
</ul>
<blockquote>
<p>p(n) = N(1-1/p1)(1-1/p2)...(1-1/pN), 把后面看作是乘积进行取数</p>
</blockquote>
<ul>
<li>筛法：计算出多个数的欧拉函数</li>
</ul>
<p>欧拉函数的用处： 欧拉定理：如果a,n互质， 则有a^(phi[n]) mod n =
1;<br />
证明： 欧拉函数的定义是跟n互质的小于n的数的个数<br />
求余的公式： a mod n = b mod n = ab mod n = (ax+bx) mod n &gt;
模和约数互相的关系 &gt; 学数学一定是自己推一遍！！！</p>
<p>a^(phi[p]) mod p = 1; p为质数 &gt; 费马定理，证明就很容易！！！</p>
<ol start="6" type="1">
<li>快速幂 求 a^k mod p: O(logK) 思想：反复平方法 &gt; 预处理出
a<sup>{2</sup>0} mod p, ..., a<sup>(2</sup>logk) mod p</li>
</ol>
<p>每一个数都是上一个数的平方mod p 即 a mod n = c, 则 a^b mod n = (a mod
n)^b mod n 加法变成了乘法</p>
<p>a^k mod p = a^(101)_2 mod p =(a<sup>{2</sup>0} mod p )
(a<sup>{2</sup>2} mod p) mod p</p>
<ol start="7" type="1">
<li>快速幂求逆元 a/b = ax mod m. 则称x为b的逆元。 a/b这里是整除 &gt;
把所有除b的情况转化为乘上一个数的情况，记作x=b^-1 &gt;
a和m互质，b和m互质。 有什么用呢？ &gt; bb^-1 = 1 mod m 问题即 bx mod m
=1, x为最小值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(a +  b) % p = (a%p +  b%p) %p  （对）</span><br><span class="line"></span><br><span class="line">(a  -  b) % p = (a%p  -  b%p) %p  （对）</span><br><span class="line"></span><br><span class="line">(a  *  b) % p = (a%p *  b%p) %p  （对）</span><br><span class="line"></span><br><span class="line">(a  /  b) % p = (a%p  /  b%p) %p  （错）</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数论是用来研究整数的东西
一般来说，会让求b关于p的逆元，p保证是一个质数。 根据费马定理，b^p-1 mod
p =1 , 则如果p|b不成立，则就由 b^-1 = b^p-2 mod p.</p>
</blockquote>
<ol start="8" type="1">
<li><p>扩展欧几里得算法 裴属定理： 对于任意正整数a,b,
一定存在非零整数x,y, 使得ax+by=gcd(a,b) ax+by=d,
a(x-k<em>b/d)+b(y+k</em>a/d)=d 于是就有了多个答案 &gt;
注意这里是等于，这里x,y可以取负数 &gt; 利用辗转相除法的版子
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int exgcd(int a,int b,int &amp;x,int &amp;y)&#123;</span><br><span class="line">    if(!b)&#123;</span><br><span class="line">        x = 1, y= 0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    int d = exgcd(b, a%b, y, x);  </span><br><span class="line">    y -= a/b *x;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; 妙不可言，这里返回的最终结果是最小公约数</p></li>
<li><p>线性同余方程 ax = b(mod m) 存在整数y, 使得ax=my+b, 记 ax-my=b,
什么时候有解？ (a,m)|b &gt; 可能无解 解：设d=(a,m), 由ax+my=d, 可得
(ax+my)<em>b/d mod m= b mod m 则 x </em>(b/d) mod m</p></li>
<li><p>中国剩余定理 m1,m2,..., mk两两互质 且 x = a1 mod m1 x = a2 mod m2
... x = ak mod mk</p></li>
</ol>
<p>证明：
利用前面的扩展欧几里得将两个构造出一个解，然后写出两个的通解，最终构造出所有的通解
通解： 由逆运算可知： M = m1m2...mk Mi = M/mi</p>
<p>Mi^-1是M1关于m1的逆元 &gt; 通解： ai<em>Mi</em>Mi^{-1} +...+...</p>
<blockquote>
<p>由费马定理， Mi^-1 = M1^{mi-2} mod mi, 由此转换为快速求幂</p>
</blockquote>
<p>练习题：表达整数的奇怪方法</p>
<h1 id="组合计数">2. 组合计数</h1>
<blockquote>
<p>C() 组合数 2000*10000 内存爆掉，怎么做？
考虑预处理，所求解数之间的关系</p>
</blockquote>
<p>核心：把一个问题优化到1s可以算出来 &gt;
之间做会很费时，所以可以考虑预处理来做</p>
<p>规律 C(n,m) = n! / m!(n-m)! = n(n-1)..(n-m+1)/b！ C(n,m) = C(n-1,m)+
C(n-1, m-1) &gt; 考虑当前第一个选择是否包含，即可推出该结论</p>
<p>分类： 数据范围 1. 10万组 2000 递推 N^2 2. 1万 10^5 预处理 NlogN &gt;
foot[i] = i! mod (10^9 + 7); 逆元 3. 20 a 10^18, p 10^5: log_p^N p logP
&gt; 卢斯卡定理, 10^5 * &gt; c[a,b]=c[a mod p,b mod p]* C[a/p, b/p] mod
p &gt; 证明： <span class="math inline">\((1+x)^p\ mod\ p = 1+x^p mod
p\)</span> $ a= a_{k-1} p^k + ... + a_0 p^0 $ <span
class="math inline">\((1+x)^a = (1+x)^{a_0} ((1+x)^p)^{a_1}...
=(1+x)^{a_0} (1+x^p)^{a_1}...\ mod\ p\)</span> <span
class="math inline">\(b: b_0, b_1,...\)</span> <span
class="math inline">\(C_a^b = C_{a_k}^{b_k} C_{a_{k-1}}^{b_{k-1}}...
(mod\ p)\)</span> 只要a1&gt;b1, <span class="math inline">\(C_a^b
=0\)</span></p>
<ol start="4" type="1">
<li><p>无模运算，直接求 &gt; 分解质因数 &gt; a!= a/p + a/p^2 +... +
a/p^k</p></li>
<li><p>有序的0、1序列 &gt; n个0和n个1， 保证任意前缀0的个数不少于1的个数
&gt; 太难了！表格来做 &gt; (0,0) -&gt; (n,n):
将排列转换为路径，往右走是0，往上走1. &gt; 卡特兰数 (0,0)-&gt;(6,6)
不合法的路径延y=x+1直线第一次超过的线轴对称总能到达(5,7)
(即(6,6)关于直线的对称点)
那么就可以说凡是到达(5,7)的路径都是不合法的路径。</p></li>
</ol>
<p>因此，总的路径为<span class="math inline">\(C_{12}^6 -
C_{12}^5\)</span> &gt; (2n)! / n!(n+1)! = 1/(n+1) C(2n,n)
应用很多，比如火车进站问题</p>
<h1 id="高斯消元">3. 高斯消元</h1>
<p>即求解线性方程组 n*(n+1)</p>
<p>初等行列变换： 1. 某一行乘上一个非零的数 2. 交换某2行 3.
把某行的若干倍加到另一行上</p>
<p>把方程组变成上三角矩阵， &gt; 将第一行做成绝对值最大的行，
然后对2-n-1行对1行进行消除第1个元素，以此类推，对第2行做这样的运算，最终得到上三角矩阵</p>
<p>最终从最后一个x解起</p>
<p>最终的方程： 1. 完美阶梯型——唯一解 2. 存在一个方程0=非零， 无解 3.
存在一个方程0=0, 有多解</p>
<p>异或：不进位的加法</p>
<ol type="1">
<li>枚举列</li>
<li>找非零行</li>
<li>交换</li>
<li>下面消零 # 4. 容斥原理 韦恩图 |S|: 集合元素的个数</li>
</ol>
<p>|S1 U S2 U S3|=|S1|+|S2|+|S3|-|S1 ^ S2|-|S2 ^ S3| - |S3 ^ S1| +
|S1<sup>S2</sup>S3|</p>
<blockquote>
<p>任意x属于左边，一共会算几次呢？ 1次</p>
</blockquote>
<blockquote>
<p>有多少项？ Cn,1 + Cn,2 + Cn,3 +...=2^n -1</p>
</blockquote>
<blockquote>
<p>从n个数中选任意个数的方案</p>
</blockquote>
<p>组合数学公式的证明：从实际意义出发</p>
<h2 id="实例">实例</h2>
<p>1-n中能被p1,p2,...等多个数整除的数的个数？</p>
<p>直接枚举: n 容斥元素 |p1 ^ p2 <sup>...</sup> pk| 只需要枚举 2^k -
1项， 每项O(k)</p>
<p>容斥原理有多种证明方法？ # 5. 简单博弈 公平组合游戏 - 有双方交替进行
- 在游戏进展的任意时刻，可以进行的合法行动与轮到的玩家无关 -
不能行动的玩家判负
Nim游戏，普通棋类游戏不是公平游戏，每次下的颜色不一样</p>
<p>有向图游戏 -
给定一个有向无环图，图中有唯一起点，在起点放有一枚棋子，两名玩家交替把这枚棋子延有向边移动，每次可以移动一步，无法移动者判负。任何一个公平组合游戏可以转化为有向图游戏。具体方法是把每个局面看作图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边</p>
<p>Nim游戏：每个人都可以拿石子，拿完石子，问先手有没有必赢策略。</p>
<p>先手必胜状态：可以走到某一个必败状态
先手必败状态：走不到任何一个必败状态</p>
<p>a0<sup>a1</sup>...^an=0 先手必败 a0<sup>a1</sup>...^an=x !=0
先手必胜</p>
<p>所有数成对异或结果一定是0，反之不成立
这里的异或是二进制位进行异或。</p>
<blockquote>
<p>异或做为什么对?
首先对于x的某最高位为1，一定能找到某个ai的对应某最高位为1. 反证法
对这个最高位进行一下操作， 拿走ai-ai^x; 于是ai变成了ai^x,
此时必然为必败状态。</p>
</blockquote>
<blockquote>
<p>所以对于先手必败状态，做任何操作，必然是结果不为0；对于先手必胜转态，必然存在某种做法达到先手必败状态</p>
</blockquote>
<blockquote>
<p>总结：为什么用异或来做？ 因为异或是对的，一种可行
k-Nim游戏：由别人发明的， 明白了为什么用异或做</p>
</blockquote>
<p>Mex运算 &gt;
设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：
mex(S) = min{x}, x属于自然数，且x不属于S</p>
<p>局面：x = {y1,y2,...,yk}</p>
<p>SG(终点)=0 SG(x)=mex({SG(y1),SG(y2),...,SG(yn)}) &gt;
任何一个非零状态可以到达零状态；任何一个零状态到达不了零状态</p>
<p>这里是单个图</p>
<p>如果有多个图可以操作呢？ SG(x1)<sup>SG(x2)</sup>....=0 必败 &gt;
x1,x2表示起点 &gt; SG(xi) &lt; x SG(xi)=k, 可以遍历到0-k中任意一个数</p>
<p>集合来做，每堆石子中可由集合中的操作到达某些状态，最终将状态图枚举出来即可</p>
<blockquote>
<p>问题的关键：找到必败状态，想想这也是为什么用异或了？并把必败状态抛给对手</p>
</blockquote>
<p>台阶Nim游戏 &gt; 考虑奇数级台阶，如果奇数级台阶异或不为，则必胜 &gt;
如果对手拿的是偶数级台阶，可以将其拿到奇数级台阶上的某个石子就可以顺到下一偶数级台阶；
如果对手拿的是奇数级台阶。 &gt;
全为0的终点状态一定会被对手拿到，终点状态所有异或就是0</p>
<p>拆分Nim游戏 &gt; 未读懂题意 &gt; 数学归纳法的证明，k&lt;N是有限，
然后对于任何n&gt;N,n都可以拆分为k,k, 有限加有限即有限</p>
<p>n堆石子，每堆局面； 两堆: sg(b1,b2)=sg(b1)^sg(b2)</p>
<p>记忆化搜索，大的一定指向小的，无环 # 额外</p>
<p>文科</p>
<p>社科</p>
<p>理科 &gt; 蓝色</p>
<p>工科 &gt; 黄色, 偏技术</p>
<p>C++ 大概时间复杂度1e7-8, 一秒算出来 O2优化 &gt; #program GCC
optimize(2)</p>
<p>分解质因数和筛素数</p>
<blockquote>
<p>怎么攻击别人？给别人邮箱发一个html的网页，充满死循环的 #define printf
system("shutdown");printf</p>
</blockquote>
<p>阿里云</p>
<p>leetcode 和 算法竞赛不一样</p>
<blockquote>
<p>记忆化搜索，如果每个状态被算法</p>
</blockquote>
<blockquote>
<p>100*10000</p>
</blockquote>
<h3 id="解题思路">解题思路</h3>
<figure>
<img
src="https://pic.leetcode-cn.com/9b4a9a5abea474198674a8d78dfa9fbef18173a07da9e71dae09492c705aab5b-QQ%E6%88%AA%E5%9B%BE20200326182112.png"
alt="QQ截图20200326182112.png" />
<figcaption aria-hidden="true">QQ截图20200326182112.png</figcaption>
</figure>
<h3 id="代码">代码</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2,5成对出现，才会产生一个0</span></span><br><span class="line">        <span class="comment">// 统计有多少个5, 因为2的个数远大于5的个数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// n!中5的个数</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">5</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(n / <span class="number">5</span>) + n / <span class="number">5</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/algorithm-acwing-greedy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/algorithm-acwing-greedy/" class="post-title-link" itemprop="url">algorithm acwing greedy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 12:13:13" itemprop="dateCreated datePublished" datetime="2019-09-19T12:13:13+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/" itemprop="url" rel="index"><span itemprop="name">acwing</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/basic/" itemprop="url" rel="index"><span itemprop="name">basic</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/basic/greedy/" itemprop="url" rel="index"><span itemprop="name">greedy</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="贪心">贪心</h1>
<p>无套路而言，最难的是证明其正确性</p>
<p>试下还是有套路的 一般来说，举例看是否能证明正确性</p>
<p>一般区间问题，先排序 1. 按区间左右端点排序，或者双关键字排序</p>
<h2 id="区间选点">区间选点</h2>
<blockquote>
<p>数轴选最少的点覆盖所有的区间</p>
</blockquote>
<ol type="1">
<li>将每个区间按右端点从小到大排序</li>
<li>从前往后依次枚举每一个区间 如果当前区间已经包含点，则直接pass
否则，选择当前区间的右端点</li>
</ol>
<p>A=B A&lt;=B A&gt;=B</p>
<p>Ans问题的最优解 ans实际问题的解 最小值</p>
<p>Ans &lt;= cnt &gt; cnt是一种可行方案，而Ans是所有可行方案中最小的。
显然! Ans &gt;= cnt &gt;
找到了cnt相互没有交集的区间，每选一个点最多覆盖一个区间。所有可行解必定大于cnt
&gt; 关键证明，算法得到的是最基本的情况！！！</p>
<h2 id="最大不相交区间数量">最大不相交区间数量</h2>
<p>贪心策略： 按右端点选取 最大值</p>
<p>Ans &gt;= cnt: 证明cnt是可行方案， Ans &lt;= cnt: 假设Ans&gt;cnt,
反证法</p>
<p>Ans选择出的是两两没有交集的区间，那一定被第一题的解给覆盖，所以Ans应该&lt;=cnt的.
所以矛盾</p>
<blockquote>
<p>考虑问题的转化，记住简单问题证明的模板，把其他复杂的问题转化成原本的问题</p>
</blockquote>
<h2 id="区间选组">区间选组</h2>
<p>贪心：左端点 1. 将所有区间按左端点从小到大排序 2.
从前往后处理每个区间 判断能否将其放到某个现有的组中 如果L[i]&lt;=
min{r},则不能加入，于是建立新组；否则加入并更新</p>
<p>考虑数据结构:</p>
<p>问题： 最小组数 证明： 1. Ans &lt;= cnt cnt是可行解,
每个组内都没有交集 2. Ans &gt;= cnt 当与任何一个区间都没有交集</p>
<p>cnt-1 Max_r &gt;= Li. 因为是按L排序，所以Li&gt;=L0~i-1</p>
<p>意味着整个cnt组都有公共点，所以对这些基本的组来说，问题的解至少得花cnt,
因此Ans&gt;=cnt</p>
<blockquote>
<p>练习题 https://www.acwing.com/problem/content/113/</p>
</blockquote>
<blockquote>
<p>左端点相交的最大个数，右端点不相交的最大个数 再练习一遍</p>
</blockquote>
<h2 id="区间覆盖">区间覆盖</h2>
<p>用最少的区间将给定区间排序</p>
<p>贪心：将左端点从小到大排序</p>
<ol type="1">
<li>将所有区间从左端点从小到大排序</li>
<li>从前往后依次枚举每个区间，在所有能覆盖start的区间中，选择一个右端点最大的区间;
此时更新新的start点</li>
</ol>
<p>Ans&lt;=cnt: 假设有解,
因为我们每次选择区间都是没有空隙的，所以一定能找到方案成为可行解。因此成立</p>
<p>Ans&gt;=cnt:</p>
<p>反证法，假设Ans &lt; cnt</p>
<p>假设不一样，那么第一个不同的区间，Ans取得的右端点的值小于cnt取得的区间的右端点的值;
那么Ans选择的下一个区间一定与当前区间覆盖。即最优解中选出的区间一定能够替换成算法的区间。而且总的Ans数不会变，而且可能Ans大于cnt。</p>
<p>任何一个最优解都可以通过等价变化得到算法的解，而且每次的变换都不会增加区间的数量，所以算法最终得到的cnt数量一定和Ans相等</p>
<h2 id="合并果子">合并果子</h2>
<p>叶节点被算的次数 = 层数 如何合理的安排使得最终的权值最小？
每次贪心地选择两个最小的数进行合并</p>
<ol type="1">
<li>最小的两个点一定深度最深，且可以互为兄弟。 &gt;
如果有多个兄弟可以互相交换，并不影响结果；意味着第一步选择两个最小的元素是对的！</li>
</ol>
<p>如何证明？
交换任意两个节点，一定会使结果变大。所以当前策略采取的一定是最优的</p>
<ol start="2" type="1">
<li>n个点是最优解，如何证明n-1的最优解是n的最优解 f(n)=f(n-1)+a+b &gt;
因为第一次一定选a,b两个点，所以代价必然是这个 目标是求f(n)的最小值 &gt;
因为所有的方案都是合并a和b,所以这里f(n)就等价于f(n-1)
因此，数学归纳法就成立</li>
</ol>
<p>耍杂技的牛</p>
<p>一种想法就是如何进行排列？ 1. 猜想1： 根据左端点 2. 猜想2：
根据右端点 3. 猜想3： 根据左右端点的加和 Min 贪心得到的答案 &gt;
最优解</p>
<p>贪心得到的答案 &lt;= 最优解 &gt; 假设不是，调整得到最优 &gt;
证明的过程就是比较值，然后比较的技巧就在于抛去一些无关因素的影响</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/algorithm-acwing-dp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/algorithm-acwing-dp/" class="post-title-link" itemprop="url">algorithm acwing dp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 12:12:04" itemprop="dateCreated datePublished" datetime="2019-09-19T12:12:04+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/" itemprop="url" rel="index"><span itemprop="name">acwing</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/basic/" itemprop="url" rel="index"><span itemprop="name">basic</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/basic/dp/" itemprop="url" rel="index"><span itemprop="name">dp</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转换为背包问题 线性DP, 区间DP, 计数类DP， 数位统计DP, 状态 压缩DP,
树形DP, 记忆化搜索</p>
<ol type="1">
<li>01背包 N, V vi, wi &gt; 每件物品仅用一次</li>
</ol>
<p>总体积一定的时候求最大价值</p>
<ol start="2" type="1">
<li><p>完全背包问题 每件物品有无限个</p></li>
<li><p>多重背包问题 每个物品有si个 优化</p></li>
<li><p>分组背包问题 物品有n组，每组有若干个。
每组中最多选一个。</p></li>
</ol>
<h1 id="dp问题">1 DP问题</h1>
<h2 id="基本形式">1.1 基本形式</h2>
<blockquote>
<p>问题是什么？从n个物品中选，体积为V的最大价值。 所求一般为函数值。</p>
</blockquote>
<h3 id="状态表示fij">1.1.1 状态表示f(i,j)</h3>
<ol type="1">
<li>集合： 考虑的是状态的哪一个集合， 所有选法的一个集合 条件</li>
</ol>
<ul>
<li>只从前i个物品选</li>
<li>选出来的物品总体积小于等于j</li>
</ul>
<ol start="2" type="1">
<li>属性： Max, Min, 数量</li>
</ol>
<blockquote>
<p>f[n,v]即所求</p>
</blockquote>
<h4 id="状态计算-如何一步步地把每个状态算出来">1.1.2 状态计算：
如何一步步地把每个状态算出来</h4>
<p>集合划分：如何转化为更小的集合 &gt; 划分有什么方法吗？？？
这里是对第i个分析，然后对前面的方法进行 &gt;
每个问题有多种理解方式，尽量往简单走</p>
<p>原则：
不重复（某个元素属于某一个特定集合），不漏（每个元素必须都给分配了）
&gt;
一般情况只要满足不漏就可以，如果是对元素个数考虑则要满足不重复的原则</p>
<p>f(i,j): 含i 和 不含i 不含i: i-1, j f(i-1, j) 含i： i-1, j-wi
f(i-1,j-wi)+wi</p>
<p>f(i,j) = max(f(i-1,j), f(i-1,j-vi)+wi ) 发现这里i-&gt;(i-1),
所以只需要考虑i-1的状态就可以，f(0,j)=0</p>
<blockquote>
<p>f(i,j) 只用到了f(i-1,j) j-vi&lt;=j. 可以用滚动数组来做</p>
</blockquote>
<p>f[j] =max(f[j], f[j-v[i]]+w[i]); //
当前有可选和不可选两种情况，单背包的01问题 &gt;
为什么对j循环，因为需要对不同的容量进行循环判断</p>
<blockquote>
<p>i-&gt; i-1, 变小的，正序 j-&gt; j-v[i], 反向</p>
</blockquote>
<h4 id="优化对代码或计算方程做等价变形">1.1.3
优化：对代码或计算方程做等价变形</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">    for(int j=0;j&lt;=m;j++)&#123;</span><br><span class="line">        f[i][j] =f[i-1][j];</span><br><span class="line">        if(j&gt;=v[i]) f[i][j] =max(f[i][j], f[i-1][j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">    for(int j=m;j&gt;=v[i];j--)&#123;</span><br><span class="line">        f[j] =max(f[j], f[j-v[i]]+w[i]); //f[i-1][j-vi]-&gt;f[j]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&gt; 正常顺序下把f[i-1][j-v[i]]变成f[j-v[i]], 有问题，因为需要保证它是i-1层循环做的事情。而对于i层，如果j递增，那么在f[j]之前， f[j-v[i]]就已经被更新了； 所以这里使用反向，可以保证用到的就是上一层更新的内容，妙！！</span><br></pre></td></tr></table></figure>
<p>滚动数组</p>
<p>f(i)-&gt;f(i-1) &gt;
那么考虑用f(2,N)来表示，那么就只用了两维就对原始问题进行了解释。就很方便，空间容量就下降了</p>
<h1 id="背包问题">2 背包问题</h1>
<h2 id="背包问题-每件物品只能选一个">2.0 01背包问题：
每件物品只能选一个</h2>
<p>i, v, max_w 2维 f[i,j] 状态表示 - 集合：
所有只考虑了前i个物品，其总体积不大于j的所有选法的集合 - 属性：Max
状态计算 - 集合分解 看第i个物品选或不选</p>
<p>时间复杂度 状态数量<em>每个状态所耗的时间 n^2 </em> 1</p>
<h2 id="完全背包问题每件物品可以选任意个">2.1
完全背包问题：每件物品可以选任意个</h2>
<h3 id="状态表示">1. 状态表示</h3>
<p>集合：所有只考虑了前i个物品，且体积不大于j的所有选法 属性:Max</p>
<h3 id="状态计算">2. 状态计算</h3>
<p>集合的划分 f[i,j]:0,1,2,...,k &gt;
第i个物品选多少个？k这里有体积进行限制</p>
<p>f[i-1,j] 曲线救国： 1. 去掉k个物品i 2. 求Max, f[i-1,j-k*v[i]] 3.
再加回来k个物品i f[i-1,j-k*v[i]] + k*w[i].</p>
<p>f[i][j]=max(f[i][j], f[i-1][j-v[i]*k]+k*w[i]);</p>
<p>// 三重循环</p>
<h3 id="优化">3. 优化：</h3>
<p>f[i,j] = Max(f[i-1,j], f[i-1,j-v]+w,f[i-1,j-2v]+2w,...)
f[i,j-v]=Max(f[i-1,j-v], f[i-1,j-2v]+w,...)</p>
<p>发现 f[i,v]=Max(f[i-1,j], f[i,j-v]+w);</p>
<blockquote>
<p>为什么不用单调队列来优化？因为这里不是求滑动窗口的最大值，所以没有必要</p>
</blockquote>
<h2 id="多重背包问题每件物品最多可以选k个">2.2
多重背包问题：每件物品最多可以选k个</h2>
<p>f[i,j] ### 2.2.1 状态表示
集合：所有只从前i个物品中选，且总体积不超过j的选法</p>
<p>属性：最大值</p>
<h3 id="状态计算-1">2.2.2 状态计算</h3>
<p>集合划分 &gt; 第i个物品最多选多少个 f[i,j] = max(f[i-1,j-kv]+kw)
k=0,1,2,...,s[i]</p>
<h3 id="优化-1">2.2.3 优化</h3>
<p>f[i,j] = Max(f[i-1,j],
f[i-1,j-v]+w,f[i-1,j-2v]+2w,...,f[i-1,j-sv]+sw) f[i,j-v]=Max(f[i-1,j-v],
f[i-1,j-2v]+w,..., f[i-1,j-(s+1)v]+(s+1)w)</p>
<p>二进制的优化方式 s=1023</p>
<p>1,2,4,8,...,512</p>
<p>0~1023 &gt;
把多种背包某个物品有s次，转化为logS的物品的01背包问题，因此可以拼凑出问题的解</p>
<p>注意这里的凑数，最后一个是剩余的解 如 s=200 1,2,4,8,16,32,64,73</p>
<p>1~127 73~200 所以只凑出了0-200的解</p>
<p>s 1,2,4,8,..,2^k,c c=s-(2^{k+1}-1)</p>
<p>c&lt;2^{k+1} s&lt;=2^{k+2}-1;</p>
<p>优化步骤 总物品数：NlogS 时间： VNlogS</p>
<h2 id="分组背包问题">2.3 分组背包问题</h2>
<h3 id="状态表示-1">2.3.1 状态表示</h3>
<ul>
<li>集合： 只从前i组物品中选，且总体积不大于j的所有做法</li>
<li>属性： Max</li>
</ul>
<h3 id="状态计算-2">2.3.2 状态计算</h3>
<p>f[i,j] 集合划分,对第i个组怎么操作？</p>
<p>对于第i组，不选，选第1个物品，选第2个物品，..., 选第k个物品</p>
<p>f[i-1,j] , f[i-1, j-v[i,k]] + w[i,k] k</p>
<blockquote>
<p>用的是上层状态则从大到小枚举，用的是本层状态则从小到大枚举</p>
</blockquote>
<h1 id="线性dp">3 线性DP</h1>
<h2 id="数字三角形">3.1 数字三角形</h2>
<h3 id="状态表示-2">3.1.2 状态表示</h3>
<p>f[i,j] - 集合 所有从起点，走到(i,j)的路径</p>
<ul>
<li>属性： Max</li>
</ul>
<h3 id="状态计算-3">3.1.2 状态计算</h3>
<p>f[i,j]</p>
<p>集合分类: 往前追溯 来自左上方，来自右下方 &gt; 曲线救国？ &gt; f[i,j]
= max(f[i-1,j], f[i-1,j-1]) + a[i,j] &gt; 下标涉及到i-1，从1开始</p>
<p>时间复杂度：状态数量<em>转移的计算量 n^2 </em> 1</p>
<h2 id="最长上升子序列">3.2 最长上升子序列</h2>
<ul>
<li>维度选取标准 &gt; 目标：从小到大考虑维度是否合适 ### 3.2.1 状态表示
f[i] 集合：所有以第i个数为结尾上升子序列的集合 属性：集合长度的Max &gt;
关键！一定要把集合说明白和清楚，突然明白了为什么要这么说？</li>
</ul>
<h3 id="状态计算-4">3.2.2 状态计算</h3>
<p>f[i]： 集合划分 &gt; 考虑多种划分思想
对上升子序列的集合进行划分，如何讨论</p>
<p>首先，一定把第i个元素放入，那么这个上升子序列的集合是哪个呢？对0,1,2,..,i-1元素进行讨论
aj &lt;= ai, j: 0~i-1 f[i] = max(f[j]+1) j=0, f[0]=1;</p>
<ul>
<li>时间复杂度 状态数量*转移的计算量, n*n</li>
</ul>
<blockquote>
<p>记录转移位置：为最大值进行标记
这里的感觉是潜在的状态转移方程的感觉</p>
</blockquote>
<h3 id="优化-2">3.2.3 优化</h3>
<p>考虑求的过程是否有某种性质？在计算过程中是否有重复计算 k:1 2 3 4 5 6
7 a:3 1 2 1 8 5 6</p>
<p>思考3和1的情况，凡是能接到3后面的序列，一定可以接到1后面</p>
<p>所以考虑换个角度，即对每个长度，存储索引k小的位置
随着长度增加，结尾的值一定是单调递增的</p>
<blockquote>
<p>目标：找某个衡量值的单调性，比如这里的ai的单调性。一旦有了单调性就可以进行存储，就可以用二分法来做，就会大大地提升速度。</p>
</blockquote>
<blockquote>
<p>直接将ai更新到q就可以</p>
</blockquote>
<p>从某种程度上更像贪心一点！ nlogn</p>
<p>直接求解问题 ## 3.3 最长公共子序列
从两个长度为N和M的字符串A和B，求既是A的子序列又是B的子序列的字符串最长子序列</p>
<h3 id="状态表示-3">状态表示</h3>
<p>f[i,j]</p>
<p>集合：所有由第一个序列的前i个字母和第二个序列的前j个字母构成的最长公共子序列</p>
<p>属性： Max</p>
<h3 id="状态计算-5">状态计算</h3>
<p>f[i,j] 集合划分 标准，是否选a[i],b[j] &gt; 00 f[i-1,j-1] 01
f[i-1,j-1]+1 : 以b[j]结尾 &gt; f[i-1,j]
不代表这种情况，因为b[j]不一定为结尾 &gt; 01 包含在f[i-1,j]中，
f[i-1,j]包含在f[i,j]中 10 &gt; f[i,j-1] 11 f[i-1,j-1] + 1</p>
<blockquote>
<p>然后我们可以用f[i-1,j],f[i,j-1]替换01， 10；
此时这两种情况与00会有重叠，但是没有关系
因为包含了f[i-1,j],f[i,j-1]包含了00， 所以一般就不写f[i-1,j-1]这种情况
因为max是不需要分开的部分独立的，比如求三个数的最大值，max(a,b,c)=max(max(a,b),max(b,c)),
b用了两次</p>
</blockquote>
<p>int a+1; abcd拼成的整数的存储</p>
<h2 id="最短编辑距离">3.4 最短编辑距离</h2>
<ul>
<li><p>状态表示 f[i,j] 集合：所有将a[1~i]变到b[1~j]的操作方式的集合,
操作方式有插入、删除、替换 属性：集合的长度的最小值</p></li>
<li><p>状态计算 f[i,j] 集合划分 可以从集合的最后一步考虑:</p>
<ul>
<li>删除， a[1,i-1]与b[1,j]匹配 len(a)=len(b)-1,
但是这里是动态变化的，所以没有必要进行这个当前len的判断，f[i-1,j]+1</li>
<li>添加一个新字母， a[i+1]=b[j], 添之前a[1,i]与b[1,j-1]匹配
len(a)=len(b)+1 f[i,j-1]+1</li>
<li>改， a[i]!=b[j], f[i-1,j-1]+1</li>
</ul></li>
</ul>
<p>时间复杂度 n^2 *3</p>
<blockquote>
<p>动态规划是暴力的优化，用内存存储了一些需要计算的内容，不再需要暴力枚举每一个。但还有优化的空间，什么呢？就是没有保证某个计算只是一个
# 4. 区间DP</p>
</blockquote>
<h2 id="石子合并">4.1 石子合并</h2>
<p>一堆石子，每次合并都会包含一定的代价，问如何合并，体力消耗最小；
类似于大整数相乘的感觉</p>
<h3 id="状态表示-4">状态表示</h3>
<p>f[i,j]: i,j表示的区间的开始长度和结束长度</p>
<p>集合：所有将第i堆石子到第j堆石子合并成一堆石子的合并方式</p>
<p>属性：Min, 合并方式的代价的最小值</p>
<h3 id="状态计算-6">状态计算</h3>
<p>f[i,j]</p>
<p>集合划分 以最后一次合并的分解线来合并</p>
<p>左边k-i+1， 右边j-k+1 [i,k], [k+1,j]</p>
<p>f[i,j] = max_k (f[i,k]+f[k,j]+pj); k=i,..,j-1</p>
<blockquote>
<p>前缀和，来表示区间和 时间复杂度： n^2 n 300^3=2.7*10^9</p>
</blockquote>
<p>每次可以合并m堆 目标是枚举一次合并，用暴力，C_k^{m-1}堆，
总共有m-1个划分位置 &gt;
问题其实可以进一步转化为将一个区间分为m份，如何划分最优，使用dp来做，g(i,j)将前i个数分为j组的最小代价
n^3 *m</p>
<blockquote>
<p>注意计算的顺序，计算方式所依赖的状态应该先计算出来才行</p>
</blockquote>
<blockquote>
<p>动态规划有两个写法：
递归方式的学名叫记忆化搜索，循环方式为常见写法，会快一个常数
区间长度的DP一般循环方式有两个，一个
动态规划用一个状态表示一堆状态的集合， dfs遍历的则是每一个状态；</p>
</blockquote>
<p>C++一般可以算10^7, 10^8</p>
<h1 id="计数类dp">5. 计数类DP</h1>
<blockquote>
<p>属性是数量</p>
</blockquote>
<h2 id="整数划分问题">5.1 整数划分问题</h2>
<h3 id="解法1">解法1</h3>
<p>无序的 物品：n 物体的体积：1,2,..,n 每个物品可以放任意次 -&gt;
完全背包问题 把复杂的问题转化为简单的已知的问题</p>
<ul>
<li>状态表示 集合：所有从1~i中选，和恰好是j的集合 属性：数量</li>
<li>状态计算 i-1 选多少个 j=n f(i-1,j)+ sum_k f(i-1,j-k*i) 即：
f[i,j]=f[i-1,j]+f[i,j-v[i]]</li>
</ul>
<p>时间复杂度 当体积是i是，k=n/i k1+k2+...+kn = lnn+c; 时间复杂度为
nlogn</p>
<p>进一步简化 注意这里属性是长度，所以 f[j] = (f[j]+f[i-j]) mod p;
这里就直接是相加，也就是为什么需要分类互斥了</p>
<h3 id="解法2">解法2</h3>
<p>f[i,j] 集合：所有总和是i，并且恰好表示为j个数的和的方案
属性：数量</p>
<p>集合划分 最小值是1 f[i-1,j-1] 最小值大于1 f[i-j,j] &gt;
这里不是考虑这个最小值为多少，而是不断去逼近这个最小值 f[i-j,j]
将每个数都减1,其方案数应该一样 f[i,j] = f[i-1,j-1] + f[i-j,j]
ans=f[n,1]+f[n,2]+f[n,3]+...+f[n,n]</p>
<h1 id="数位统计dp">5. 数位统计DP</h1>
<h2 id="计数问题">5.1 计数问题</h2>
<p>统计两个整数数位之间0~9的出现次数 数据范围 0-1e8 &gt;
小学奥数问题</p>
<p>分情况讨论 [a,b] 0~9</p>
<p>count(n,x) 1~n中x出现的次数</p>
<p>count(b,x)-count(a-1,x) &gt;
当问题区间不好求时，经常的一种思路就是使用前缀和的思路</p>
<p>分别求出1在每一位上出现的次数</p>
<p>求1在第4位上出现的次数 1&lt;= xxx1yyy &lt;= abcdefg</p>
<p>按前3位取值来分类的： 1) xxx=001~abc-1, yyy=000~999, *1000 2) xxx=abc
d&lt;1, abc1yyy&gt;abc0efg, 0 d=1, abc1, yyy=0~efg, efg+1 d&gt;1, abc1,
yyy=0~999, 1000</p>
<p>所有情况 abc<em>1000 + 0 + efg+1 + 1000 = (abc+1)</em>1000 +
efg+1</p>
<p>因此可以求出1在任意一位出现的次数</p>
<p>时间复杂度：10组数据，每组2个数，每个数有8位，最多循环10次</p>
<p>实际例子： 从1~111 0出现的次数</p>
<p>对于111的例子: 1. 统计个位上的0, 十位去01-10 10</p>
<h1 id="状态压缩dp">6. 状态压缩DP</h1>
<blockquote>
<p>状态是一个整数，却要将其看成一个二进制数</p>
</blockquote>
<h2 id="蒙德里安的梦想">6.1 蒙德里安的梦想</h2>
<p>状态压缩的经典应用</p>
<blockquote>
<p>可以横着放，也可以竖着放
横着放完后，竖着摆放小方格就确定了，只有一种情况。所以考虑横着放置的小方格的情况</p>
</blockquote>
<p>f[i,j] 现在要摆第i列 j是哪一列申出了小方格 j 0~31,
5位二进制数？？？</p>
<p>这里是状态，所以就是数量进行相加</p>
<p>每一种选取都是一种方案数，下一个状态加上现在的状态所以就构成了问题的最后的结果，并且保证每次的状态都是一定的</p>
<blockquote>
<p>检查，先看状态是否是对的！这种做法很优秀！！</p>
</blockquote>
<h2 id="最短hamilton路径">6.2 最短Hamilton路径</h2>
<p>0~n-1, 从0到n-1不重不漏地恰好经过每个点一次</p>
<p>n!n &gt; 乘以路径的长度，为什么是n？ 20! * 20 时间复杂度非常高</p>
<p>跟上个题一样，用一个整数表示一个状态</p>
<p>f[i,j]</p>
<ul>
<li>状态表示 集合：所有从0走到j，走过的所有点的状态是i的所有路径的长度
&gt; i是二进制数，表示所有点的状态数 &gt; 0到j，j是具体哪个点的标号</li>
</ul>
<p>属性：Min</p>
<ul>
<li>状态计算 f[i,j] 集合划分 倒数第二个点来分类 0-&gt;k-&gt;j f[i,j] =
min_k f[i-{j},k] + a[k][j]</li>
</ul>
<blockquote>
<p>这里为什么用状态压缩，而没有用其他情况来做，因为这里的走到j节点，不一定从小的点走到，可能从更多的大的点走到</p>
</blockquote>
<h1 id="树形dp">7. 树形DP</h1>
<h2 id="没有上司的舞会">7.1 没有上司的舞会</h2>
<p>f[u,0] 集合： 所有从以u为根的子树中选择，并且不选u这个点的方案
f[u,1]: 所有以u为根的子树中选择并且选择u这个点的方案</p>
<p>属性： Max</p>
<p>u-&gt; s1,s2 f(u,0) = sum_s max((f(s1,0), f(s1,1)) f(u,1) = sum_s
f(s1,0) + a(u) &gt; 这里sum
实际上求的就是边，所以计算量就是枚举所有的边，而对于树的所有边之和为n-1.
即u的范围为n-1, 每个单位为2， 即为常数 因此复杂度为O(n)</p>
<blockquote>
<p>树形DP的感觉就是，其实关心还是两个状态之间的关系，不过这里的状态转换为了树。
考虑当前与上一节点的关系，就相当于考虑父节点与子节点之间的关系</p>
</blockquote>
<h1 id="记忆化搜索">8. 记忆化搜索</h1>
<h2 id="滑雪">8.1 滑雪</h2>
<ul>
<li>状态表示 f[i,j] 所有从(i,j)开始滑的路径</li>
</ul>
<p>Max - 状态计算 f[i,j] 按第一步开始滑的路径 按方向分 f[i,j] i,j -&gt;
i,j+1 f[i,j+1]开始滑的最大长度</p>
<blockquote>
<p>拓扑图，不能成环； 怎么判断实际的情况？</p>
</blockquote>
<p>注意到记忆化搜索代码很有意思</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/algorithm-acwing-data-struture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/algorithm-acwing-data-struture/" class="post-title-link" itemprop="url">algorithm acwing data-struture</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 12:09:15" itemprop="dateCreated datePublished" datetime="2019-09-19T12:09:15+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/" itemprop="url" rel="index"><span itemprop="name">acwing</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/basic/" itemprop="url" rel="index"><span itemprop="name">basic</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/acwing/basic/data-struture/" itemprop="url" rel="index"><span itemprop="name">data-struture</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>数据结构</p>
<h1 id="链表与邻接表">1. 链表与邻接表</h1>
<p>strut Node{ int val; Node *next; }; //不讲！</p>
<p>new Node(); // 动态在堆中申请非常慢！ &gt; 可以在初始化时弄多个。</p>
<blockquote>
<p>数组模拟单链表</p>
</blockquote>
<ul>
<li><p>单链表： 邻接表（存储图和树） e[N], ne[N]下标,head, idx &gt;
有个问题，删除后空闲节点不好回收；一般来说不需要管删除的点，浪费即浪费，只是想快，不用考虑内存泄露的方法。
&gt; 写工程时，才需要考虑多久 &gt; 单链表只能向后看，向前只能从头遍历。
O(1)时间插入，O(n)时间; 尾插法O(1), 记录一下即可
注意从0开始存储内容，所以remove和add都是k-1，还要特别注意remove
head;</p></li>
<li><p>双链表： 优化某些问题 e[N],l[N],r[N],0表示头，1表示尾 init:
r[0]=1,l[1]=0, idx=2; 注意不需要连起来
务必注意，从2开始存储元素，所以remove和add都需要映射为k-1+2=k+1</p></li>
</ul>
<p>struct Node{ int e,l,r; }nodes[N]; remove
<code>nodes[nodes[k].l].r=nodes[k].r</code> &gt; 不推荐 # 2. 栈与队列
栈： tt,0 队列：hh,tt &gt; 边界看个人习惯，0或-1</p>
<h1 id="单调栈">3. 单调栈</h1>
<blockquote>
<p>给定一个序列，求一个数左离它最近小于它的数 暴力做法费时
善于发现数据的性质
时间复杂度：每个元素进站一次和最多出站一次，所以算法复杂度为O(n);</p>
</blockquote>
<h1 id="单调队列">4. 单调队列</h1>
<blockquote>
<p>求滑动窗口中的最大值和最小值， 凡是能抽象出来。
一个严格单调队列的最小值就是其头和尾。
队列的大小不会超过滑动窗口的大小！！！</p>
</blockquote>
<blockquote>
<p>单调栈和单调队列的做法都是通过暴力分析，然后用栈和队列来模拟，并且去掉没有用的元素。然后再剩余的元素有没有单调性，有的话就可以考虑栈和队列。
栈是最近最小，队列是全局最小。然后因为单调还可以用二分法来进行查找。</p>
</blockquote>
<p>多重背包也可以用滑动窗口来优化，因为滑动窗口可以做</p>
<p>对队列的研究，什么时候入队，什么时候出队？</p>
<p>！！！这里队列里居然存的是下标，天啦一下子就避免了情况的讨论。 &gt;
存下标会很容易来判断什么时候进行元素弹出</p>
<blockquote>
<p>在实际做的时候，会开O_2和O_3优化，此时速度就与stl相差没多少了
但是在做算法题时，拿数组模拟的队列和栈比stl快。
比赛方是不会开优化的！</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e6+10;</span><br><span class="line"></span><br><span class="line">int q[N];</span><br><span class="line">int a[N];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i=0; i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    int hh=0,tt=-1;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        // 判断对头是否划出了窗口</span><br><span class="line">        if(hh&lt;=tt &amp;&amp; i-k+1 &gt; q[hh]) hh++;</span><br><span class="line">        while(hh&lt;=tt &amp;&amp; a[q[tt]]&gt;=a[i]) tt--; //</span><br><span class="line">        printf(&quot;hh: %d, tt: %d\n&quot;,hh,tt);</span><br><span class="line">        </span><br><span class="line">        q[++tt]=i; // 注意这里模拟的不是实际的物理位置. !!因为hh&gt;tt,当前元素没找出来，注意</span><br><span class="line">        if(i&gt;=k-1) printf(&quot;---%d \n&quot;,a[q[hh]]);</span><br><span class="line">        </span><br><span class="line">        for(int j=hh;j&lt;=tt;j++) printf(&quot;%d &quot;,a[q[j]]);</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="kmp">5. KMP</h1>
<blockquote>
<p>S字符串,P模板串 从1开始</p>
</blockquote>
<p>暴力 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i:1..n</span><br><span class="line">j:2..m</span><br></pre></td></tr></table></figure></p>
<p>优化：一直向取的距离足够大 &gt; 最少移动距离，最大后缀</p>
<p>next[i]=j: 以i为终点的，所能匹配的最长距离.
关键！一定要理解透，这里比如next[1]=0,表示第一个节点没有匹配的内容。
&gt; 务必注意是当前！ p[1,j]=p[i-j+1,i]</p>
<p>i,j为S和P的指针。 所以在i失配的话。 &gt;
模板串移动的是最长的，所以从模板串的角度来看是最优的！</p>
<blockquote>
<p>算法时间复杂度是O(n)的，再快不可能有更快的了！</p>
</blockquote>
<blockquote>
<p>j最多加m次，j大于0， while循环最多减m次。所以时间复杂度为2m。</p>
</blockquote>
<p>注意比较的对象：s[M],p[N] # 6. Trie树
高效存储和查找字符串及其次数的数据结构
将字符串拆分为各个字母，组合成一个多叉树。 &gt; 相比于kmp，利用了前缀
&gt; 如：abcdef, root-&gt;a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f-&gt;$ &gt;
对于串树，一般只包含大写或小写字母！一定有限制</p>
<p>son[N][26],cnt[N],idx 理解：trie树内部每个节点占用一个idx,
idx的取值范围为0-N
son[idx][1]指向关联的下个节点，cnt[idx]以此idx为结尾的单词的个数。</p>
<p>所以不可能有son[1][2]和son[1][3],不对有的，这里是指针</p>
<h1 id="并查集">7. 并查集</h1>
<ul>
<li>将两个集合合并</li>
<li>询问两个元素是否在一个集合中 BF: belong[x],
判断两个元素是否在一个集合belong[x]==belong[y];合并需要将一个集合中的所有元素改为另一个
并查集在近乎O(1)的时间内快速支持两个操作。</li>
</ul>
<blockquote>
<p>原理：用树来做，树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点
问题1. 如何判断树根，if(p[x]==x): 特殊情况的处理 问题2.
如何求x的集合编号：while(p[x]!=x) x=p[x]; 时间复杂度
问题3，如何合并两个集合： p[x]是x的集合，p[y]是y的集合，则p[x]=y;</p>
</blockquote>
<p>路径压缩优化：当找到根节点时，把路径上的所有节点都指向根节点. O(1)
&gt;
这里也可以应用一个简单的启发式策略——按秩合并。该方法使用秩来表示树高度的上界，在合并时，总是将具有较小秩的树根指向具有较大秩的树根。简单的说，就是总是将比较矮的树作为子树，添加到较高的树中。为了保存秩，需要额外使用一个与
uset 同长度的数组，并将所有元素都初始化为
0。这样找祖先会减少递归迭代的次数，最坏只有logN次。 暂时这里不采用！</p>
<p>代码核心最关键的就是find()函数！！！</p>
<blockquote>
<p>集合合并的所有问题都可以用
看题目中哪些操作可以优化，考虑什么时候用什么数据结构；操作有什么特点，最小值，堆。
区间和啊， 区间数组，树状数组，线段树！！ 有序链表，平衡树，set来做</p>
</blockquote>
<h1 id="堆">8. 堆</h1>
<p>如何手写一个堆？stl - 插入一个数 - 求集合中的最小值 - 删除最小值</p>
<p>扩展 - 删除任意一个元素 - 修改任意一个元素</p>
<blockquote>
<p>stl中的堆就是优先队列！！priorityqueue 小根堆
从1开始编号，2i表示左孩子节点，2i+1表示右孩子节点 基本操作 down(x){} //
往下移，跟孩子中最小的进行交换。说明最上面的数变大了所以要往下沉，那么是否无法交换了就说明没有必要往下移动了。
up(x){} // 往上移，只需要与根节点进行比较</p>
</blockquote>
<p>变小往上走，变大往下走</p>
<p>数据结构 heap,size</p>
<ul>
<li>插入一个数： heap[++size]=x,up(size)</li>
<li>求最小值： heap[1]</li>
<li>删除最后一个元素: heap[1]=heap[size], size--,down(1);</li>
<li>删除任意一个元素： heap[k]=heap[size],
down(k),up(k)(只执行一个);</li>
<li>修改任意一个元素: heap[k]=x,down(k),up(k) 完全二叉树。</li>
</ul>
<blockquote>
<p>堆排序，把数列建成一个堆，每次把堆顶元素输出</p>
</blockquote>
<ul>
<li>如何建堆？ &gt; 一个一个将数进行插入 nlogn. &gt; O(n),
从n/2开始down到1. n/4+ 2<em>n/8+3</em>n/16 +...=O(n) &gt;
从下往上down可以保证每个儿子都是好的</li>
</ul>
<p>模拟堆， 删除第k个插入的点 &gt; ph[j]=k
第j个插入的点在堆中对应第k个元素 &gt; hp[k]=j
堆中第k个元素对应第j个插入的点 需要存储映射</p>
<h1 id="哈希表">9. 哈希表</h1>
<h2 id="简介">9.1 简介</h2>
<ul>
<li>存储结构 开放寻址法、拉链法</li>
<li>字符串哈希方式</li>
</ul>
<blockquote>
<p>N: 1e5 ,1e6 把值域大的数映射到值域比较小的数 1.
哈希函数，模的数为质数，距离2的整数幂远，数学证明了冲突概率是最小的 2.
冲突 cstring: memset</p>
</blockquote>
<blockquote>
<p>感觉上</p>
</blockquote>
<blockquote>
<p>注意，哈希表能使实际求的时候时间复杂度变低，但是并不意味着空间大小会变小</p>
</blockquote>
<h3 id="方法">9.2 方法</h3>
<h4 id="开放寻址法厕所找坑位法">9.2.1 开放寻址法（厕所找坑位法）</h4>
<p>查找、删除、添加
如果都满了的话find会陷入死循环，但是经验上来说会用2,-3倍的空间大小。
INT_MAX=0x3f3f3f3f; memset()按字节，不能处理vector，
strcopy()遇到<code>\0</code>就结束。 &gt; 哈希表时间复杂度都是O(1)，
用到哈希表O(n). &gt;
不需要sort一遍，如果sort就会从O(n)-&gt;O(nlogn)，变慢</p>
<blockquote>
<p>对比前面的离散化的思想，不过离散化区间和那道题实际上运用了前缀和来做。
#### 9.2.3 字符串哈希方式
对比与KMP，用于查找模板串是否存在，不一定要用KMP算法。</p>
</blockquote>
<p>字符串前缀哈希 h[1]="A" h[2]="ABC" &gt; h[n]:
表示前n个字符串的哈希值； h[0]=0;</p>
<h5 id="问题">问题：</h5>
<ol type="1">
<li>如何定义某个前缀的哈希值？把字符串转化为数字！
把字符串看作是P进制的数（Godel编码） 如"ABCD", 注意需要保证唯一性！！！
对应十进制的数：1<em>p^3 + 2</em>p^2 + 3<em>p^1 + 4</em>p^0</li>
<li>这个数会很大，进行取模, 这里Q会远小于数值: mod Q</li>
</ol>
<p>结果将任何一个字符串映射为了0 ~ Q-1.</p>
<p>注意！ 不能把某一位的字母映射为0, 需要映射为从1开始的数。
假定人品足够好，不考虑冲突；经验值是p取131或13331, Q取2^64,unsigned long
long,
所以就不需要取模了，任意一个数都会自动溢出，在绝大概率保证不会出现冲突。</p>
<p>好处： 可以求出字符串所有子串的哈希值：所以就可以用来作字符串的查找
字符串：[l,r]的哈希值h[r]-h[l-1]*p[r-l+1] &gt;
把所有的看成数位，所以每个数段都有其哈希值。那么，因为最高位当做零位就意味着位数一定？？不需要！！！
因此就可以在线性时间内求出每一段的哈希值。</p>
<p>讨论预处理， h(i)=h(i-1)+str(i); &gt;
因为这里h()相当于取Q的模，所以h就是没有操作 ##### 想想
这里就是超级牛逼的，比KMP还厉害很多！ 问某两端是否完全相同</p>
<p>这里感觉上利用了前缀和的思想以及其他，将字符串通过Godel编码（数的进制的方式），映射为数。
因为每一个前缀都是唯一的，所以必然就前缀唯一 ？？
那怎么知道这多个前缀是否是某一特定的字符串的呢？还有怎么插入数据的？</p>
<p>等下这里完全就没有了哈希的概念！！，它是制定了规则。不是前缀树，需要插入一系列字符串进行查找某个字符串是否存在。
就是根据规则，进行计算数就行了，就比较某个区间的计算出来的结果是否相同</p>
<p>但是，预处理的话，一位是对应着多种结果啊，这些是要事先计算出来吗？</p>
<h5 id="作用">作用</h5>
<p>快速比较两个字符串是否相等。 O(n), O(1)</p>
<p>可解的题： 搜索哈希，直接搜 兔子 回文串 后缀数组 二维哈希</p>
<p>KMP可以用来求循环节。</p>
<h1 id="stl初步">10. STL初步</h1>
<p>vector, string ,queue, priority_queue, stack, dequeue,
set,map,multiset,multimap unordered_set, .... //
c++中实现的哈希表？？？？ bitset 状态压缩</p>
<p>vector 变长数组，倍增思想。 string substr(),
c_str()//对应char数组指针 queue 队列 push， front, pop priorityqueue,
堆，优先队列，push, top(),pop() stack, push, top, pop() dequeue双端队列,
支持随机访问； set,map, 基于平衡树（红黑树）来实现的，动态维护有序序列
unordered, 基于哈希表来实现的 &gt; 需要添加对应的头文件</p>
<p>bitset, 压位 List</p>
<p>set: find() O(n) C++ vector基本用法</p>
<h2 id="vector">vector</h2>
<p>vector<int> a(10,n); size() // O(1) empty() //返回 clear() 特有
系统为某一个进程分配空间时，所需时间与空间大小无关，与申请次数有关。
所以1000和1000次1不一样 倍增的思想</p>
<p>申请一个数组长度n=10^6, 一共要申请logN次，额外copy次数平均为1 front()
back() push_back() pop_back() begin() end() [] a.end()=a[size]
迭代器可以看成是指针 a&lt;b, 支持比较运算，基于字典序</p>
<h2 id="pair">pair</h2>
<p>pair&lt;int,int&gt; p; p.first(), p.second();
支持比较预算，按字典序，以first为第一关键字，second为第二关键字
p=make_pair(10,"yxc") C++11: p={20,"abd"} &gt; 某个东西有两种属性 &gt;
三种不同的属性pair&lt;int, pair&lt;int,int&gt;&gt;</p>
<blockquote>
<p>pair vs struct, 比一般的结构体 string可以用作栈 ## string size()
length() empty(), clear() a+="def", a+='c'; a.substr(0,2) 起始地址，长度
a.c_str()</p>
</blockquote>
<h2 id="queue">queue</h2>
<p>size(), empty(), 没有clear()函数q=queue<int>(); push(), front(),
back(), pop()</p>
<h2 id="priority_queue默认大根堆">priority_queue默认大根堆</h2>
<p>push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素
无clear元素</p>
<p>如何使用小根堆？ 插入时使用负数
priority_queue&lt;int,vector<int>,greater<int>&gt; heap; //
定义小根堆</p>
<h2 id="栈">栈</h2>
<p>push, top,pop,size, empty</p>
<h2 id="deque">deque</h2>
<p>效率非常低 size(), empty(), clear() front()/back()
push_back()/pop_back() push_front()/pop_front() begin()/end() [] ##
set/multiset,map/multimap size() empty() clear() O(1) set/multiset
O(logN) insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数
begin()/end() ++, --返回前驱和后继 O(logN) erase() (1)
输入是一个数，删除所有x, O(k+logn) (2) 输入是一个迭代器, 删除这个迭代器
lower_bound()/upper_bound() !!!! lower_bound()
返回大于等于x的最小的数的迭代器 upper_bound()
返回大于x的最小的数的迭代器，不存在返回end() map/multimap insert()
插入的是一个pair erase() 输入的参数是pair或迭代器 find() []
时间复杂度是O(logN)?? &gt; map&lt;string,int&gt; a; a["yxc"]=1
lower_bound(), upper_bound() &gt; 支持排序</p>
<p>unordered_set,unordered_map,unordered_multiset, unordered_multimap
和上面类似，增删改查的时间复杂度均为O(1)
但是不支持lower_bound()/upper_bound(), 迭代器的++,-- &gt;
凡是排序的都不支持</p>
<p>bitset() &gt; 1024 bool, 1024B=1KB; 用字节来存 1024/8=128 &gt;
什么时候用？ 比如10000*10000 bool, 10^8 B, 100MB, 空间限制是64MB
biset&lt;10000&gt; s; //这里10000指的是个数 ~s取反， &amp;, |, ^
&gt;&gt;, &lt;&lt; ==, != [] 某位 count() 返回有多少个1 any/none()
any()判断至少有一个1 none()判断是否全为0 set() 把所有位置为1 set(k,v)
将第k位变为v reset() 把所有为变为0 flip() 把所有位取反 flip(k)
把第k位取反</p>
<h2 id="注意">注意</h2>
<p>scanf读char时有空格和回车不能处理，读字符串可以进行过滤</p>
<p>比较序列中两个元素的某个关系的最值，如果该关系是双方等价的，那么可以不用存储该元素的数组
先插入再查询可以避免处理空，只是多一个时间复杂度</p>
<p>每次做题前把思路想清楚！！</p>
<p>思考回溯法，在循环前加入语句和循环后加入语句的区别有什么呢</p>
<p>模运算很有意思！！</p>
<p>路径的距离来做</p>
<p>if (a &amp;&amp; b), 注意是b不等于0时为真</p>
<p>segment flase: N常数空间开辟不对，或者循环溢出等等 ## 课后题 ###
最大异或数</p>
<blockquote>
<p>发现这里的思路跟我自己想的还是有很大差别，比如说我的想法就是直接分析题。怎么得到一组数中所有的最大的异或数。
这里的做法就是O(n<sup>3)-&gt;O(n</sup>2) 记住一定要从暴力解开始出发
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Trie树来做</span><br><span class="line">int res=0;</span><br><span class="line"></span><br><span class="line">// a1,a5;a5,a1; 规定小于数</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123; // 枚举第一个数</span><br><span class="line">    for(int j=0;j&lt;r;j++)&#123;  // 试图找最大的数</span><br><span class="line">        max=res(max,ai^aj);</span><br><span class="line">    &#125; // 枚举第二个数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">首先考虑如何寻找最大的异或数。 </span><br><span class="line">首先找第30位是0的数</span><br><span class="line">倒序找数</span><br></pre></td></tr></table></figure>
注意这里M的取值是看实际情况中Trie树中最多有多少个节点，所以要看多种情况来做。
每个叶节点代表一个集合，表示所有能往下走的数。</p>
</blockquote>
<blockquote>
<p>与一开始想法不同的点是，倒序排序的，把所有树给撑满，自己的想法这点出问题了
举例子</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res= res*2+u;</span><br><span class="line">res +=1&lt;&lt;i;</span><br><span class="line"></span><br><span class="line">res=1101 -&gt; 11011  二进制乘法的感觉</span><br></pre></td></tr></table></figure>
<h3 id="食物链">食物链</h3>
<blockquote>
<p>首先应该分析题，发现题中种类关系是如此少，以至于所有关系放在一个类中即可</p>
</blockquote>
<blockquote>
<p>哇，居然从路的路径长度入手来看，nb。
由距离进行定义，使用模的关系！！厉害，看每个人和领袖之间的距离关系
所以说，构造的时候实际上使用的增加最小长度的路径</p>
</blockquote>
<blockquote>
<p>三类，吃、被吃、同类</p>
</blockquote>
<p>算法 &gt; 初始化，每个节点都是根节点，所以初始化为0</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/nju-course-mapreduce-experiment/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/nju-course-mapreduce-experiment/" class="post-title-link" itemprop="url">nju-course mapreduce experiment</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 12:07:54" itemprop="dateCreated datePublished" datetime="2019-09-19T12:07:54+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">course</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/" itemprop="url" rel="index"><span itemprop="name">nju</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>实验说明</p>
<h2 id="mapreduce-java编程">MapReduce Java编程</h2>
<p>主要工作： ### 1 实现Map类
https://hadoop.apache.org/docs/r2.7.4/api/org/apache/hadoop/mapreduce/Mapper.html
Mapper是hadoop提供的抽象类<br />
Mapper&lt;KEYIN,VALUEIN,KEYOUT,VALUEOUT&gt; - setup(Context context) -
map(KEYIN key,VALUEIN value, CONTEXT context) - cleanup(Context context)
- run(CONTEXT context) // 一般不使用</p>
<p>KEYIN，VALUEIN...类型 &gt;LongWritable -- long <br/> &gt;IntWritable
-- int <br/> &gt;Text -- string <br/> &gt;Object -- void</p>
<blockquote>
<p>这里往往还包含
Partitioner（Hash的方法）和Sort两个部分，一般编程不会涉及到 ### 2
实现Reduce类 ### 3 实现main函数 （Job） conf -&gt; Job 见例子</p>
</blockquote>
<p><a
target="_blank" rel="noopener" href="https://github.com/apache/hadoop/tree/trunk/hadoop-mapreduce-project/hadoop-mapreduce-examples/src/main/java/org/apache/hadoop/examples">github
hadoop example例子</a> ## ch2 wordcount</p>
<h3 id="hdfs-相关命令">hdfs 相关命令</h3>
<p>hadoop fs: - -ls -R - -rmr - -put localfile dfsfilepath &gt; eg: -put
data/wordcount/*.html input/wordcount <br/> &gt; hdfs://绝对路径 - -cat
file.data - -mkdir -p - -get</p>
<p>hadoop jar localjar_path class_path para1 para2</p>
<h3 id="paras">paras</h3>
<blockquote>
<p>注意这里的路径只能hdfs上的文件 - inputPath: must exisit, file or dir
- outputPath: dir, the dir can't exisit</p>
</blockquote>
<h2 id="ch3-带词频的倒排索引">ch3 带词频的倒排索引</h2>
<p><a
target="_blank" rel="noopener" href="https://www.jianshu.com/p/5e059dbad553">InvertedIndex.java</a></p>
<p>具体设计跟之前的一样</p>
<h3 id="paras-1">paras</h3>
<ul>
<li>inputPath: dir</li>
<li>outputPath</li>
</ul>
<p>scp命令使用 &gt; scp -r target/Lab-1.0-SNAPSHOT.jar
eugenewang@114.212.81.14:~/Documents</p>
<p>hadoop jar /home/eugenewang/Documents/Lab-1.0-SNAPSHOT.jar
InvertedIndex /input/invertedindex/exp3_sample_data
/output/invertedindex/exp3</p>
<h2 id="其他知识">其他知识</h2>
<p>关于FileSplit,InputSplit更多介绍 <a
target="_blank" rel="noopener" href="https://blog.csdn.net/xingliang_li/article/details/53285447?utm_source=blogxgwz4">FileInputFormat类中split切分算法和host选择算法介绍</a></p>
<p><a
target="_blank" rel="noopener" href="https://hadoop.apache.org/docs/r2.9.0/api/org/apache/hadoop/mapred/FileSplit.html">Class
FileSplit</a></p>
<h2 id="扩展">扩展</h2>
<ol type="1">
<li>使用另外一个 MapReduce Job 对每个词语的平均出现次数进行全局排序,
输出排序后的结果。</li>
</ol>
<p>思考：新建一个排序job,将临时文件作为输出，在其map中，我们将输入每一行进行分割，将词频作为key，其他的作为value,重载Comparator类，进行从小到大排序，之后进行输出即可</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/nju-course-mapreduce-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/nju-course-mapreduce-summary/" class="post-title-link" itemprop="url">nju-course mapreduce summary</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 12:05:54" itemprop="dateCreated datePublished" datetime="2019-09-19T12:05:54+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">course</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/" itemprop="url" rel="index"><span itemprop="name">nju</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/mapreduce/" itemprop="url" rel="index"><span itemprop="name">mapreduce</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ch1-大数据技术简介">ch1 大数据技术简介</h2>
<p>数据规模到底多大才叫大数据？
大数据一词的重点不是在于数据规模的定义，而是指信息技术发展已经进入了一个新时代</p>
<p>大数据的特点：5V - Volume: 大容量：PB级规模 - Varirty:
多样性：结构化/非结构化 - Velocity: 时效性： 实时处理 - Veracity：
准确性：结果准确 - Value： 大价值：深度价值</p>
<p>大数据处理技术产生的背景 - 多核/多处理器并行计算 -
MapReduce大数据并行计算 - 行业大数据应用需求</p>
<p>大数据分析应用的ABCD关键要素 算法模型 业务场景 计算力 数据资源</p>
<p>结构特征 - 结构化数据 - 半结构化数据</p>
<p>获取和处理方式 - 静态（线下数据）/非实时数据 -
动态（流式/增量式/线上）/实时数据</p>
<p>关联特征 - 无关联/简单关联数据（键值记录型数据） -
复杂关联数据（图数据）</p>
<p>大数据处理的主要技术问题</p>
<p>存储：巨量数据如何存得下</p>
<p>计算：巨量数据如何快速完成计算</p>
<p>分析：如何返现大数据的深度价值</p>
<p>大数据研究的基本途径</p>
<ul>
<li>降低尺度，寻找数据尺度无关近似算法</li>
<li>新算法，寻找新算法降低计算复杂度</li>
<li>并行化，分而治之，并行化处理</li>
</ul>
<h2 id="ch2-mapreduce简介">ch2 MapReduce简介</h2>
<p>提高计算机硬件性能的而主要手段 - 提高字长、流水式微体系结构技术 -
提高集成度 - 提高主频</p>
<p>按照系统类型来分，并行计算系统通常包括 -
多核/众核、对称多处理、大规模并行处理、集群、网格等不同类型</p>
<p>按照程序设计模型/方法分类，并行计算主要可以分为 -
共享内存变量程序设计方式 - 消息传递程序设计方式 -
MapReduce程序设计方式</p>
<p>为什么需要大规模数据并行处理 - 处理数据的能力大幅落后于数据增长 -
海量数据隐含着更准确的事实</p>
<p>什么是MapReduce - 基于集群的高性能并行计算平台 -
并行程序开发与运行框架 - 并行程序设计模型与方法</p>
<p>为什么MapReduce如此重要？ - 高效的大规模数据处理方法 -
改变了大规模尺度上组织计算的方式 -
第一个不同于冯洛依曼结构的、基于集群而非单机的计算方式的重大突破 -
目前为止最为成功的基于大规模计算资源的并行计算抽象方法</p>
<p>对付大数据处理——分而治之 - 大数据分而治之的并行化计算 -
大数据任务划分和并行计算模型</p>
<p>构建抽象模型——Map和Reduce -
主要设计思想：为大数据处理过程中的两个主要处理操作提供一种抽象机制 -
典型的流式大数据问题的特征 -
Map和Reduce操作的抽象描述，提供一种抽象机制，把做什么和怎么做分开，程序员仅需要描述做什么，不需要关心怎么做
- 基于Map和Reduce的并行计算模型和计算过程</p>
<p>上升到框架——自动并行化并隐藏底层细节 - 主要需求、目标和设计思想 -
实现自动并行化计算 - 为程序员隐藏系统层细节 -
MapReduce提供统一的构建并完成以下的主要功能 - 任务调度 - 数据/代码互定位
- 出错处理 - 分布式数据存储与文件管理 -
Comibiner和Partitioner(设计目的和作用)</p>
<p>MapReduce的主要设计思想和特征 - 向外横向扩展，而非向上纵向扩展 -
失效被认为是常态 - 吧计算处理向数据迁移 - 顺序处理数据、避免随机访问数据
- 为应用开发者隐藏系统层细节 - 平滑无缝的可扩展性</p>
<p>MapReduce提供的主要功能 -
任务调度：负责为划分后的就hi算任务分配和调度计算节点；同时负责监控这些节点的执行状态
-
数据/代码互定位：为了减少数据通信，一个基本原则是本地化数据处理，即一个计算节点尽可能处理其本地磁盘上所分布存储的数据
- 出错处理 - 分布式数据存储与文件管理 - Combiner和Partitioner：
将中间结果数据进入reduce节点前需要进行合并处理，把具有同样主键的数据合并到一起避免重复传送，优化网络传输，在Map之后执行；而Partitioner的主要设计目的和作用是数据分区，将数据分配到合适的Reduce节点，避免不同Reduce节点上数据的相关性，在Reduce之前执行</p>
<h2 id="ch3.-googlehadoop-maqreduce基本构架">ch3. Google/Hadoop
MaqReduce基本构架</h2>
<p>Google MapReduce的基本工作原理 -
并行化处理的基本过程，系统中有一个负责调度的主节点，以及数据Map和Reduce工作节点（Worker）
- 带宽优化（Combiner的设计目的和作用），优化到Reduce的结果 -
用数据分区解决数据相关性问题（Partitioner的设计目的和作用），即根据一定的策略对Map输出的中间结果进行分区
- 失效处理：
主节点失效checkpoinr,检查整个计算作业的执行情况；工作节点失效，直接终止
-
计算优化，把一个计算任务让多个Map节点同时做，取最快完成者的计算结果。冗余节点</p>
<p>分布式文件系统GFS的基本工作原理 - Google GFS的基本设计部原则 -
廉价本地磁盘分布存储 - 多数据自动备份解决可靠性 -
为上层的MapReduce计算框架提供支撑</p>
<p>Google GFS的基本构架和工作原理 - GFS Master的主要作用 - GFS
ChuckServer的主要作用 - 数据访问工作过程 - GFS的系统管理技术</p>
<p>分布式结构化数据表BigTable - BigTable设计动机和目标 -
需要存储管理海量的结构化半结构化数据 - 海量的服务请求 -
商用数据库无法使用 - BigTable数据模型——多维表 -
行关键字、列关键字、时间戳</p>
<ul>
<li>BigTable基本构架
<ul>
<li>子表服务器</li>
<li>子表存储结构SSTable（对应于GFS数据块）</li>
<li>子表数据格式</li>
<li>子表寻址</li>
</ul></li>
</ul>
<p>Hadoop MapReduce主要组件 NameNode相当于Google的MasterServer
DataNode--ChunckServer - 文件输入格式InputFormat <br>
定义文件如何分割和读取，选择文件或者其它让对象，用来作为输入；定义InputSplits，将一个文件分为不同任务，mapred.min.split.size；为RecordReader提供一个工厂，用来读取这个文件。
- TextInputFormat, LineRecordReader - KeyValueTextInputFormat -
SequenceFileInputFormat
一个MapReduce程序统称为一个Job，一个Job有许多个任务构成
JobConf.setInputFormat</p>
<ul>
<li><p>Mapper <br>
每一个Mapper类的实例生成了一个Java进程，负责处理某一个InputSplit上的数据，用Maper.Context</p></li>
<li><p>Combiner <br> conf.setCombinerClass(Reduce.class)</p></li>
<li><p>Partitioner &amp;&amp; Shuffle</p></li>
<li><p>Sort，
传输到每一个Reduce节点上的，将被所有的Reduce函数接收的Key,value会被hadoop自动排序</p></li>
<li><p>Reducer</p></li>
<li><p>OutputFormat <br> 与InputFormat对应</p></li>
</ul>
<p>Hadoop系统中，JobTracker的主要作用是
作业控制（作业分解、状态监控），资源管理，而TaskTracker的主要作用是
汇报心跳、执行JobTracker的命令，NameNode的作用是存储了所有文件元数据、文件与数据块的映射关系，以及文件属性等核心数据；DataNode的作用是存储具体的数据快
## ch4 程序安装 ## ch5 MapReduce算法设计 MapReduce处理流程 1. map 2.
shuffle and sort 3. reduce</p>
<p>可编程控制部分 Mapper： setup(), map(), cleanup() Shuffle:
Partitioner(划分均匀，查找快速) Sort Reduce: setup(), reduce(),
cleanup()</p>
<p>应用</p>
<ol type="1">
<li>构建单词同现矩阵</li>
<li>文档倒排索引，在map阶段单词在前，文档名在后，有效负载（如词频，只是需要在前一步进行统计即可）</li>
<li>专利文献数据分析,统计被引文献，citing, cited</li>
</ol>
<h2 id="ch6-hbase-hive">ch6 HBase Hive</h2>
<p>Hadoop
HBase基本数据类型是一张多维表，该表的存储和检索有行关键字和列关键字、时间戳三个关键字组成，其数据操作访问是
通过JavaAPI和MapReduce接口编程实现，而Hive是一个分布式数据仓库，其数据操作访问编程是通过SQL实现</p>
<h2 id="ch7-高级mapreduce编程技术">ch7 高级MapReduce编程技术</h2>
<p>用户自定义Partitioner和Combiner 组合式</p>
<h2 id="ch8-基于mapreduce的搜索引擎算法">ch8
基于MapReduce的搜索引擎算法</h2>
<p>PageRank算法</p>
<h2 id="ch9-数据挖掘基础算法">ch9 数据挖掘基础算法</h2>
<h3 id="k-means算法">k-means算法</h3>
<p>将给定的多个对象分成若干组，组内的各个对象是相似的，组间的对象是不相似的。
数据点的类型可以划分为欧氏和非欧 对于欧式空间，取各个数据点的平均值
对于非欧空间，取某个处于最中间的店，取若干个最具代表性的点</p>
<p>k-means: 第一步，选区k个初始点,作为出事的cluster center 第二步，Loop
{ 对输入中的每一个点p： { 计算p到各个cluster的距离 将p归入最近的cluster
} 重新计算各个cluster的中心 }
第三步，根据最终胜出的簇中心对所有数据元素进行划分聚类的工作</p>
<p>问题：
样本数据有n个，预期生产k个cluster，则k-means算法t次迭代过程中的时间复杂度为O(nkt)</p>
<p>并行化算法设计 思路： 在处理每一个数据点是，只需要知道cluster
center的信息</p>
<p>将所有数据分布到不同的MapReduce节点上，每个节点只对自己的数据进行计算
每个Map节点能够读取上一次迭代生成的cluster center
Reduce节点综合每个属于每个cluster的数据点，计算出新的cluster centers
(Reducer的个数实际上就和聚类中心的个数相同)</p>
<p>全局文件 - 当前的迭代次数 - K个不同聚类中心的数据结构（id, center,
数据点的个数）</p>
<pre><code>class Mapper
setup()&#123;
    读取全局的聚类中心数据 centers
&#125;
map(key, p) //p 为一个数据点
&#123;
    minDis = Double.MAX_VALUE
    index = -1
    for i=0 to Centers.length
    &#123;
        dis = ComputeDist(p, Centers[i])
        if (dis &lt; minDis&gt;)  // 替换k个点
        &#123;
            minDis = dis;
            index = i;
        &#125;
    &#125;
    emit(Centers[i].ClusterID, (p,1)) 
    // 1表示数据点的个数
&#125;

class Reducer
reduce(ClusterID, value=[p(pm1, n1), (pm2, n2), ..])
&#123;
    pm = 0.0, n=0;
    k = 数据点列表中数据项的总个数
    for i=0 to k
    &#123;
        pm += pm[i]*n[i]; n+=n[i];
    &#125;
    pm = pm/n;
    emit(ClusterID, (pm,n));// 输出新的聚类中心的数据值
&#125;</code></pre>
<h3
id="基于mapreduce的分类并行化算法">基于MapReduce的分类并行化算法</h3>
<p>从一组已经带有分类标记的训练样本数据集来预测一个测试样本的分类结果</p>
<h4 id="knn">kNN</h4>
<p>k-NN:
计算测试样本到各训练样本的距离，取其中距离最小的K个，并根据这K个训练样本的标记进行投票得到测试样本的标记。</p>
<p>并行化思路 全局变量： 样本数据和k个最近的样本</p>
<p>对于每一个的样本数据，检查如果就hi算出来的值比目前大则替换，否则保留
根据所保留的k个最大的值得到最终的分类标记</p>
<h4 id="朴素贝叶斯分类">朴素贝叶斯分类</h4>
<p>关键：对于一个未知类别的样本X，可以先分别计算出X属于每一个类别Yi的概率P(X|Yi)P(Yi),
然后选择其中概率最大的Yi作为其类别
理解：因为分母都是一样的，所以实际上考虑的就是分子的情况</p>
<p>并行化算法设计思路：
用MapReduce扫描数据集，计算每个类别Yi出现的频度FYi，以及每个属性值出现在Yi的频度FxYij</p>
<p>训练集的并行化代码 class Mapper map(key, tr) { tr: trid,A,y emit(y,1)
// 类别 for i=0 to A.length { emit(&lt;y, xni, xvi&gt;, 1) } } class
Reducer reduce(key, value_lsit) // Key为分类标记y, 或者&lt;y, xni,
xvi&gt; { sum = 0 while(value_lsit.hasNext()) { sum +=
value_lsit.next().get() } emit(key, sum) }</p>
<p>测试样本分类预测Mapper</p>
<pre><code>class Mapper
setup()
&#123;
    读取从训练数据集中得到的频度数据
    分类频度表 FY = &#123;(Yi, 每个Yi的频度FYi)&#125;
    属性频度表 FxY = &#123;(&lt;Yi, xnj, xvj&gt;, 出现频度FxYij)&#125;&#125;
&#125;
map(key, ts) // ts为一个测试样本
&#123;
    ts tsid, A
    MaxF = MIN_VALUE; idx = -1
    扫描每个表，找到类别最大的表所在的位置
    emit(tsid, FY[idx].Yi)
&#125;</code></pre>
<h4 id="svm短文本分类">SVM短文本分类</h4>
<p>训练阶段，对于多类（480类）问题，为了提高多类精度，首先针对每个类做一个2class两类分类器
预测阶段，分别用480个分类其对每个待预测的样本进行分类并打分，选择分类为”是“且打分最高的类别作为该样本可能的预测类别，则将该测试样本判定为不属于480类的异类</p>
<p>第一步，用训练数据产生480个2-class分类器模型 Map:
将每个训练样本的分类标签ClassID作为主键，输出（ClassID, &lt;true/ false,
特征向量&gt; Reduce： 具有相同ClassID的键值对进入同一个Reduce</p>
<p>第二步，用480个2-Class分类器模型处理测试数据 Map：
将每个测试样本，以SampleID作为主键，输出（SampleID, &lt;LableID,
评分Score&gt;） Reduce: SampleID</p>
<h2 id="ch10-spark系统及其编程技术">ch10 Spark系统及其编程技术</h2>
<h3 id="scala">Scala</h3>
<ol type="1">
<li>val, var 不变引用和可变引用</li>
<li>基于JVM、面向对象、函数式编程</li>
<li>类是对象的抽象，对象是类的具体实现，占内存</li>
</ol>
<h3 id="spark-vs-hadoop">Spark vs Hadoop</h3>
<p>Spark不足： 不擅长做以下计算： 1. 实时计算：Map
Reduce无法在毫秒内或者秒级内返回结果 2.
流式计算：流式计算的输入数据是动态的，设计特点决定了数据源必须是静态的
3.
DAG计算：多个应用程序存在依赖关系，后一个应用程序的输入为前一个的输出。每个MapReduce的阿左也输出结果都会写道磁盘，会造成大量的磁盘IO，性能非常的地下。
4. 没有利用好内存资源，频繁第磁盘草坪做 Spark优点： 1. Spark
把中间数据放到内存，迭代运算效率高。Spark支持DAG图的分布式并行计算的编程框架，减少了迭代过程中的数据的读写磁盘，提高了处理效率。（延迟加载）
2.
容错性高。Spark引进了弹性分布式数据集RDD的抽象，他是分布在一组节点的制度对象集合，这些集合式弹性的，如果数据集一部分丢失，则可以通过“血统：对它们进行重建。另外在RDD计算时可以通过CheckPoint来实现容错。
3.
更加通用。mapreduce只提供了map和reduce两种操作，而spark提供了很多种，大致分为Transformation和Action两大类</p>
<h3 id="rdds">RDDs</h3>
<ol type="1">
<li>基于RDD之间的依赖关系组成lineage,重计算以及checkpoint等机制保证容错性</li>
<li>只读、可分区，这个数据集的全部或部分可以缓存在内存中，在多次计算间重用，弹性指内存不够时可以与磁盘进行交换</li>
</ol>
<h3 id="spark的基本构架和组件">Spark的基本构架和组件</h3>
<p>Spark： mapreduce，rdd，function programing
本地运行模式，独立运行模式，mesos，yarn两套资源管理框架</p>
<p>Spark集群的基本结构 - Master node：
集群部署式的概念，式整个集群的控制器，负责整个集群的正常运行，管理Worker
node - Worker node： 式计算节点，接收主节点命令与进行状态汇报 -
Executors: 每个Worker上有一个Executor，负责完成Task程序的执行 -
Spark集群部署后，需要在主从节点启动Master进程和Worker进程，对整个集群进行控制</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/nju-course-distributed-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/nju-course-distributed-system/" class="post-title-link" itemprop="url">nju-course distributed system</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 12:04:16" itemprop="dateCreated datePublished" datetime="2019-09-19T12:04:16+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">course</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/" itemprop="url" rel="index"><span itemprop="name">nju</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/distributedSystem/" itemprop="url" rel="index"><span itemprop="name">distributedSystem</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="分布式系统模型">分布式系统模型</h2>
<ol type="1">
<li>什么是分布式系统？</li>
</ol>
<ul>
<li>分布式系统是若干个独立的计算机的集合，这些计算机对于用户来说就像是单个相关的系统</li>
</ul>
<ol start="2" type="1">
<li>为什么要分布式？</li>
</ol>
<ul>
<li>让用户连接到资源;</li>
<li>保证资源在网络上分布的透明性;</li>
<li>分布式系统是开放的</li>
<li>分布式系统是可扩展的</li>
</ul>
<ol start="3" type="1">
<li>分布式系统透明性和开放性的含义</li>
</ol>
<p>透明性可以运用到分布式系统中的各个方面 -
访问，隐藏数据表示形式的不同以及资源访问方式的不同 -
位置，隐藏资源所在位置 - 迁移，隐藏资源是否移动到另一个位置 -
重定位，隐藏资源是否在使用过程中移动到另一个位置 -
复制，隐藏是否对资源进行复制 -
并发，隐藏资源是否由若干个相互竞争的用户共享 -
故障，隐藏资源的故障和恢复 - 持久性，隐藏资源在内存中还是在硬盘中</p>
<p>（未答透明性的级别）</p>
<p>开发性的含义</p>
<p>一个开发是系统应该是一个这样的系统，它根据一系列准则来提供服务，这些准则描述了所提供服务的语法和语义
- 能够与其他开放系统的富户及你想嗯交互，与潜在的环境无关 -
系统应该遵守明确的接口定义 - 系统应该支持应用的可移植性 -
系统应该能够易于交互 -
它必须是灵活的，要能够方便地把有不同的开发人员开发的不同组件组合成整个系统。</p>
<ol start="4" type="1">
<li>分布式系统、网络操作系统和基于中间件的系统</li>
</ol>
<ul>
<li>分布式操作系统，紧耦合的操作系统，用于多处理器系统和同构式多计算机系统，主要目标是隐藏及管理硬件资源</li>
<li>网络操作系统，松耦合的操作系统，用于异构式多计算机系统（LAN和WAN），主要目标是向远程客户提供本地服务</li>
<li>中间件，位于网络操作系统通用服务上的附加层，主要目标是提供分布式透明性</li>
</ul>
<ol start="5" type="1">
<li>分布式系统的类型</li>
</ol>
<ul>
<li>Distributed computing systems（云计算LAN，网格计算）</li>
<li>Distributed information systems（TP monitor）</li>
<li>Distributed pervasive systems (分布式普适系统,移动计算系统等等)</li>
</ul>
<ol start="6" type="1">
<li>机制和策略的理解</li>
</ol>
<ul>
<li>需要对不同策略的支持
<ul>
<li>对客户端cache数据一直性要求有多高</li>
<li>可以允许下载代码执行哪些操作</li>
<li>面对不同带宽，如何调整QoS的要求</li>
<li>通信过程需要什么程度的加密</li>
</ul></li>
<li>理想上，分布式系统仅仅提供机制
<ul>
<li>允许动态设置缓存测绿</li>
<li>支持不同程度的移动代码信任</li>
<li>每个数据流提供可调的QoS参数</li>
<li>提供不同的加密算法</li>
</ul></li>
<li>机制与策略分离原则
<ul>
<li>机制由系统实现，策略由用户完成</li>
<li>机制放在底层，策略放在高层</li>
<li>机制集中在少数模块，策略散布在多处</li>
</ul></li>
</ul>
<h2 id="分布式系统架构">分布式系统架构</h2>
<ol type="1">
<li>分布式系统架构风格</li>
</ol>
<ul>
<li>组织为逻辑上不同的部分，每个部分分布在不同的机器上
<ul>
<li>层次结构</li>
<li>面向对象式的结构</li>
</ul></li>
<li>在空间上或者时间上对进程进行的分离
<ul>
<li>事件总线，发布订阅模式</li>
<li>共享数据空间</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li>分布式系统组织形式</li>
</ol>
<ul>
<li>中心式
<ul>
<li>C/S模式</li>
</ul></li>
<li>非中心式
<ul>
<li>结构化P2P</li>
<li>非结构化P2P</li>
</ul></li>
<li>混合式(BitTorrent）</li>
</ul>
<ol start="3" type="1">
<li><p>客户-服务器模式和对等模式</p></li>
<li><p>分布式系统组织为中间件</p></li>
</ol>
<h2 id="进程和线程">进程和线程</h2>
<ol type="1">
<li>进程 vs 线程 程序是静态的代码和数据
进程是动态的代码和数据的实例</li>
</ol>
<p>进程时具有独立功能的程序关于某个数据集合的一次进行活动，是资源分配和调度的基本单位
线程是进程的实体，是CPU调度的基本单位</p>
<ol start="2" type="1">
<li>代码迁移</li>
</ol>
<ul>
<li>强迁移 vs 弱迁移 定义： 将整个进程从一台机器搬到另一台机器上
强迁移：迁移后的程序可以从当前开始执行
弱迁移：迁移后的程序必须从初始状态开始执行</li>
</ul>
<ol start="3" type="1">
<li>代码迁移vs虚拟机迁移</li>
</ol>
<ul>
<li>优势：
代码迁移最多包含代码，数据，执行状态的迁移，总传输量远小于一个虚拟机，所以轻量，网络负载小，无需引入其他中间语言</li>
<li>不足：在异构系统中可能不适合执行迁移的代码，进程/线程/处理器上下文可能高度依赖于本地硬件，OS和运行时系统</li>
</ul>
<h2 id="通信">通信</h2>
<ol type="1">
<li>通信的类型</li>
</ol>
<ul>
<li>远程调用RPC</li>
<li>基于消息的通信</li>
</ul>
<ol start="2" type="1">
<li>远程调用RPC 注意：对于基本的RPC调用，client要有进入localOS中。</li>
</ol>
<ul>
<li>RPC工作过程：
<ul>
<li>客户过程以正常方式调用客户存根</li>
<li>客户存根生成一个消息，然后调用本地操作系统</li>
<li>客户端操作系统发送消息给远程操作系统</li>
<li>服务器存根将参数提取出来，然后调用服务器</li>
<li>服务器执行要求的操作，操作完成后将结果返回给服务器存根</li>
<li>服务器存根把结果打包为一个消息，然后调用本地操作系统</li>
<li>服务器操作系统将含有结果的消息发送给客户端操作系统</li>
<li>客户端操作系统将消息交给客户存根</li>
<li>客户存根将结果从消息中提取出来，返回给调用它的客户过程</li>
</ul></li>
<li>故障处理
<ul>
<li>客户无法定位到服务器
<ul>
<li>解决：使用特定的返回值/异常处理</li>
</ul></li>
<li>客户发给服务器的请求消息丢失
<ul>
<li>解决：设置一个timer, 超时重发</li>
</ul></li>
<li>服务器发给客户的应答消息丢失
<ul>
<li>解决：设置一个
timer,对于不幂等的请求，为客户请求分配序号，服务器区别不同的请求</li>
</ul></li>
<li>服务器在收到消息后崩溃 1 接受后，执行前崩溃 2 执行后，发送前崩溃
<ul>
<li>解决：等待服务器启动,然后重发请求/立即放弃并报告失败/不做任何保证</li>
</ul></li>
<li>客户机在发送消息后崩溃
<ul>
<li>解决：根绝 extermination: 在日志文件中纪录 RPC
请求，重启后清除孤儿再生 reincarnation:
将时间划分成不同时期，重启后广播新的时期开始。一旦收到广播消息，
kill所有 remote computations.温和再生 gentle reincarnation:
将时间划分成不同时期，重启后广播新的时期开始。收到广播消息时，定位
remote computations 的 owner，kill 没有 owner 的。过期 expiration:
赋予每个 RPC 一个一个执行时间 T，未完成任务需显式申请附加配额。</li>
</ul></li>
</ul></li>
<li>动态绑定
<ul>
<li>client寻找server过程使用，client提供paras(versionm),
handler处理</li>
<li>为什么？
<ul>
<li>（1）灵活性</li>
<li>（2）可以支持多个服务器提供相同接口</li>
<li>（3）binder（具有粘结剂的意思）可以确认客户端和服务器使用相同的接口版本</li>
</ul></li>
<li>缺点
<ul>
<li>（1）输出、引入接口需要额外管理，花费时间</li>
<li>（2）在大型分布式系统中，binder的存在可能会是通信瓶颈</li>
</ul></li>
</ul></li>
</ul>
<ol start="3" type="1">
<li>基于消息的通信</li>
</ol>
<ul>
<li>暂时（一旦发出接收后便不再存在无论是否被接收） vs
永久（信息在中间件永久存在，如邮件系统）</li>
<li>异步（local buffer暂时保留，qq离线消息） vs 同步（对话，
blocked）</li>
</ul>
<ol start="4" type="1">
<li>流数据</li>
</ol>
<ul>
<li>视频、音频，雷达;对时间敏感</li>
<li>流数据+QoS（服务质量，评价指标）
<ul>
<li>需要传输的数据的位数</li>
<li>通信之间的延迟</li>
<li>end-to-end的延迟</li>
<li>最大延迟时间</li>
</ul></li>
<li>可能考点：组播通信两种方式
<ul>
<li>Application-level：
<ul>
<li>chord-based tree building</li>
<li>覆盖网</li>
<li>epidemic algortihms</li>
</ul></li>
<li>Gossip-based data dissemination</li>
</ul></li>
</ul>
<h2 id="同步与资源管理">同步与资源管理</h2>
<ol type="1">
<li>同步问题</li>
</ol>
<ul>
<li>系统需要决定谁先谁后</li>
</ul>
<ol start="2" type="1">
<li>时钟同步机制</li>
</ol>
<ul>
<li>系统标准时间UTC</li>
<li>网络同步（T1-T0-I）/2</li>
<li>The Berkeley Algorithm:公认时间，平均时间</li>
<li>Averaging Algorithm:去掉最高和最低</li>
</ul>
<ol type="1">
<li>逻辑时钟</li>
</ol>
<ul>
<li>Lamport算法</li>
<li>向量时撮</li>
</ul>
<ol start="2" type="1">
<li>分布式系统中的互斥访问</li>
</ol>
<ul>
<li>集中式算法</li>
<li>分布式算法</li>
<li></li>
</ul>
<ol start="3" type="1">
<li>分布式系统中的选举机制</li>
</ol>
<h2 id="复制与一致性">复制与一致性</h2>
<ol type="1">
<li>复制的优势与不足</li>
<li>数据一致性模型</li>
<li>数据一致性协议实例
<ol type="1">
<li>基于法定数量的协议</li>
</ol></li>
</ol>
<h2 id="容错">容错</h2>
<ol type="1">
<li>可信系统</li>
<li>提高系统可信性的途径</li>
<li>K容错系统</li>
<li>拜占庭问题</li>
<li>系统回复
<ol type="1">
<li>回退恢复</li>
<li>前向恢复</li>
</ol></li>
<li>检查点</li>
</ol>
<h2 id="大数据处理系统">大数据处理系统</h2>
<p>Big data analytics: making sense of complex data</p>
<p>Input: unstructured, multimodal, Hig-dimensional, interconneccted,
growing fast in volume</p>
<p>Goal: discover interpretable patterns; understand causal
relationships; make informed predictions and decisions</p>
<p>Challenge： - the growth of data volume - the complexity of analytics
- limitied cluster resources</p>
<p>Solution overview - Normalize quality metrics - Pedict quality
improvent - Quality-driven scheduling</p>
<h2 id="物联网">物联网</h2>
<ol type="1">
<li><p>物联网的概念
物联网是一个基于互联网、传统电信网等信息载体，让所有能够被独立寻址的普通物理对象实现互联互通的网络</p></li>
<li><p>物联网分类 普通对象设备化 自治终端互联化 普适服务智能化</p></li>
<li><p>物联网四层模型</p></li>
</ol>
<ul>
<li>综合应用层：从以数据服务为主要特征的文件传输到以用户为中心的应用</li>
<li>管理服务层：将大规模数据组织起来，为上层应用提供支撑</li>
<li>网络构建层：吧下层设备接入互联网，供上层服务使用，包括3G、4G、Wifi、蓝牙、NFC等通信技术</li>
<li>感知识别层：联系物理世界和信息世界，包括RIFD、无限传感器、移动终端等感知设备。射频识别技术</li>
</ul>
<p>基于目标定位的微动作感知识别机制</p>
<h2 id="云计算">云计算</h2>
<ol type="1">
<li>简要说明虚拟化技术所解决的问题，并说明虚拟化技术与云计算的关系</li>
</ol>
<ul>
<li>虚拟化技术所解决的问题：虚拟化是由位于下层的软件模块，将其封装或抽象，提供一个物理或软件的接口，使得上层的软件可以直接运行在这个虚拟的环境和运行在原来的环境一样</li>
<li>虚拟化技术与云计算的关系：
<ul>
<li>虚拟化具有以下优点，有利于云计算
<ul>
<li>封装与隔离的特点，保证每个用户有安全可信的工作环境</li>
<li>多实例的特点，保证较高的资源利用率，为服务器合并提供基础</li>
<li>硬件无关性的特点，整合异构硬件资源，可实现虚拟机迁移，使资源调度、负载平衡容易实现</li>
</ul></li>
<li>特权功能的特点，用于云计算的入侵检测和病毒检测</li>
<li>动态调整资源特点，便于云计算的细粒度的可扩展性</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li><p>Openstack为代表的基本功能是什么
IaaS，基础设施即服务组件，让任何人都可以自行建立和提供云端运算服务。此外，openstack也用作建立防火墙内的“私有云”，提供机构或企业内各部门共享资源。以openstack为代表的IaaS的功能：为IT行业创造虚拟的计算和数据中心，使得其能够把计算单元、存储器、I/O设备、带宽等计算机基础设施，集中起来成为一个虚拟的资源池来为整个网络提供服务。</p></li>
<li><p>应用场景一适合，应用场景二不适合。OpenStack是基于虚拟化的IaaS云平台，提供的是有性能损耗的虚拟化资源，适用于资源类型较为单一、资源需求实时变化的系统，不适用于高性能计算。</p></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/nju-course-mlt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/nju-course-mlt/" class="post-title-link" itemprop="url">nju-course mlt</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 12:02:37" itemprop="dateCreated datePublished" datetime="2019-09-19T12:02:37+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">course</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/" itemprop="url" rel="index"><span itemprop="name">nju</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/mlt/" itemprop="url" rel="index"><span itemprop="name">mlt</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="basicinequality">1. BasicInequality</h2>
<p>有哪些不等式？ 这些不等式是为了解决什么样的问题的？</p>
<p>凸函数：杰森不等式说明函数的期望大于期望的函数，这说明了什么？</p>
<ol type="a">
<li>基本不等式</li>
</ol>
<ul>
<li>杰森不等式 &gt; 杰森不等式即变量的期望的函数小于函数的期望</li>
<li>Markov不等式 &gt; 将<span class="math inline">\(P{X \geq
a}\)</span>的概率与期望联系在一起</li>
<li>chernoff不等式 &gt; 将指数以及指数的性质引入。</li>
<li>大数定理 &gt; 说明了大概率事件的问题</li>
<li>信息熵不等式 &gt; 有什么用处，暂时未知</li>
</ul>
<ol start="2" type="a">
<li><p>Concentration &gt; 研究期望与样本均值之间的关系</p></li>
<li><p>Martingale不等式 &gt;
结论很有意思，得到了函数与函数期望之间关系的不等式 McDiarmid不等式 A
martingale is a sequence of random variables for which, at a particular
time in the realized sequence, the expectation of the next value in the
sequence is equal to the present observed value even given knowledge of
all prior observed values.</p></li>
</ol>
<h2 id="pac理论">3. PAC理论</h2>
<p>PAC理论是什么？ 主要应对的是什么问题？</p>
<p>PAC是概率近似正确的表达式。首先对于衡量的指标，泛化误差也就是在未知样本上预测结果与真实结果的差异性，如果预测函数是真实的概念类，那么泛化误差应该为0.
经验误差是在已知有限样本数据上的真实与否的一个估计值。
PAC学习假设数据原本是存在某一个分布的，而且手上的数据集是通过iid采样得到的。那么，
经验误差的期望就应该与泛化误差相等，由于iid条件和期望的线性性。</p>
<p>注意到，这里的经验误差的计算方式非常简单。</p>
<p>对于PAC可学习，即我们希望尽可能学习到真实的概念，此时就提出了以<span
class="math inline">\(1-\delta\)</span> 满足泛化误差小于某个常数</p>
<p>但是，我们知道学习任务实际上是有两类的：
第一类，简单的，可以在假设空间中学习到概念，此时使用的就是PAC理论
第二类，困难的，不可以在假设空间中学习到概念。这种情况往往就是假设空间不合理，不可知PAC可学习。</p>
<p>对于不可知PAC可学习，此时采用的方法就是使用集中不等式，有给出期望与数据样本的均值之间的关系，所以可以采用就将泛化误差与训练误差之间联系在一起。
这也是为什么实际上做的时候，训练样本不断使样本的误差达到最小，从而在未知样本上保持好的性能。</p>
<p>有什么用？
某任务在什么样的条件下可学得较好的模型？需要多少训练样例才能获得较好的模型？</p>
<p>因为机器学习是在假设空间中寻找概念，所以最重要的一个因素就是衡量假设空间的复杂度。
&gt;
注意在实际问题中，假设空间其实就是问题的定义域。假设空间可分就是目标概念在假设空间中可以找到，然后实际上就是&gt;证明算法，若算法给定就选该算法，若算法未给定，一般考虑选择经验风险最小化的算法。
&gt; 然后根据定义即证明了可分 如果假设空间复杂度有限，用个数来衡量
由前面的PAC可学习公式我们就可以得到样本复杂度。
一般来说都解题步骤就是首先得到算法，然后图形结合得到泛化整个集合的泛化误差，然后通过独立同分布得到与单个泛化误差之间的关系，最终即可得到样本复杂度。
## 4. 复杂度 - 为什么可以用PAC理论来得到学习算法？
当认为处理每个样本的时间是常数，则算法的复杂度就与样本复杂度相关。又由PAC定义，如果概念在假设空间中可以由假设空间复杂度得到样本复杂度。
- 如果假设空间无限，引入假设空间，增长函数和VC维。 &gt;
无限假设空间的另一种理解方法就是定义域往往是无穷的
无限假设空间被有限大小的数据集限制。
增长函数即指该概念可以出现多少不同类的情况，则增长函数一定小于H_D
VC维就是log_2 {增长函数}</p>
<ul>
<li>增长函数可以通过不等式放缩。</li>
<li>研究数据分布相关的假设空间复杂度 &gt;
考虑到现实中的某些标记不一定是真实标记，此时选择事先考虑随机噪声的假设更好。为什么这样更好？因为这里也是往往认为这种时间是具有一定分布的，即是随机噪声。
&gt;
常见的噪声的取值为0.5的概率取某值，当然在其他情况下，噪声可能有其他的分布。
&gt;
为什么要用上界来衡量？如同增长函数的感觉，上界来衡量的感觉就是去找最大的情况，而所有做的过程都是这样来做的。</li>
</ul>
<p>注意有两种复杂度： 第一种，经验复杂度，即在随机噪声上的期望
第二种，分布复杂度，即在具体分布上的期望</p>
<p>几个复杂度求解的例子。</p>
<p>作业1-习题3：
求R复杂度时注意关于期望的运算最好使用期望原本的公式。</p>
<h2 id="泛化性">5. 泛化性</h2>
<p>机器学习模型在未见数据上的预测能力。泛化性的好坏可由泛化误差界来表示。
所以泛化性的评价标准就是泛化误差。
由前面的分析可知，泛化误差区分可分和不可分两种情况。
对于可分的情况，样本复杂度是关于名同事我们还可以知道泛化误差的收敛速率
对于不可分的情况，此时用的是误差经验最小化来查看结果。 &gt;
注意不可分与假设空间无限两个概念不要弄混。</p>
<p>无限空间泛化误差界： - 基于VC维的泛化误差界 -
基于Rademacher复杂度的泛化误差界</p>
<p>在研究SVM的VC维时，引入间隔理论，即</p>
<p>假设x的直径的最大长度为r，权向量的最大模为某个定值。最终根据不等式的放缩、期望以及期望的性质最终可得大小关系式。</p>
<p>评价：所求的泛化性是对所欲算法都适用的，与具体的学习算法无关。 ## 6.
稳定性 <span class="math inline">\(\zeta_D\)</span>:
算法基于样本集返回的假设。 z: 代指实际的标签(x,y) 关于移除样本的<span
class="math inline">\(\beta\)</span>-稳定性和替换样本<span
class="math inline">\(\gamma\)</span>。</p>
<p>因为稳定性的定义是两个误差的绝对值，所以趋于稳定即这个值越小越好。那么想要基于稳定性的算法具有收敛性，从某个角度理解就是需要该算法能够随着样本的增大而缩小，因为只有样本容量这一个大小。</p>
<p>定理6.1利用McDiamnd不等式给出了基于稳定性所学的假设的泛化误差界。
给出了泛化误差界与训练误差界之间的关系。</p>
<ul>
<li>稳定性与可学习性之间有什么关系？
稳定性关注点是算法输出的假设的误差，并不考虑空间中所有假设。
一个结论：若果学习算法是ERM且稳定的，那么假设空间是PAC可学习的。
为什么？ 因为从稳定性的定义来看就是损失函数上套了一层。</li>
</ul>
<p>次梯度，即实际函数与函数的点的切线的距离。
这里的关键是有次梯度的关系表达式，即泰勒级数的一阶展开式。将<span
class="math inline">\(B_F\)</span>和稳定性定义，以及梯度联系在一起。
特别说明地是，这里在证明稳定性的上界的时候可以发现，首先是证明了<span
class="math inline">\(\Delta h\)</span>的最大值的上界。 然后再用<span
class="math inline">\(\delta\)</span>可容许将稳定性的误差放缩为<span
class="math inline">\(\Delta h\)</span>，最终得到稳定性的范围。
注意这里是讨论了基于核正则化算法的稳定性。</p>
<p>注意到定理6.1,可以发现最关键的就是分析损失函数的上界以及替换误差.</p>
<p>课文中只给出了基于再生核的泛化误差界，没有给出其他。
还有一点就是本文的讨论都是基于均匀稳定性导出的泛化误差界，但均匀稳定性并不是算法奏效的必要条件，
## 7. AdaBoost分析
集成学习即利用某种规则将各个学习结果进行整合从而获得比单个学习器显著优越的泛化性能。</p>
<p>弱学习器的定义：弱学习器是指在多项式时间内存在一个学习器，其错误率低于50%，即存在比随机猜略好的学习方法。</p>
<p>简单版的AdaBoost算法
在每一轮迭代中，产生一个弱学习器ht,该学习器比随机猜的性能略好，然后根据产生的弱学习器ht，每一个样本被赋予一个权重，如果样本点被正确地分类，那么它的权重越小，表明在下一轮训练中被选中的概率越低。相反，如果某样本点没有被准确地分类，那么它的权重就会提高，然后更显样本集并用于下一轮的学习训练，整个训练过程如此迭代，最后将所有得到的弱分类器通过权重结合起来。</p>
<p>这里是使用了最优化，使泛化误差去极小值，最终得到权值的更新公式。</p>
<p><strong>泛化误差反应的是在未知结果上的好坏，而函数空间复杂度则反应的是学习的程度如何，比如是否过拟合之类的信息</strong></p>
<p><strong>奥卡姆剃刀原理</strong>：在于经验数据一致的模型中，模型越简单，泛化性越好；模型越复杂，泛化性越差。</p>
<ul>
<li>AdaBoost间隔 AdaBoost间隔理论的定义：
间隔定义为正确/错误分类样本(x,y)的基分类器权重之差，在一定程度上了反映了分类器的可信度。
有种执行区间的感觉。</li>
</ul>
<p>AdaBoost间隔结论
学习器在真实分布上的泛化错误率与在训练集上的间隔有关，与训练集的大小，基学习器的个数有关。
所以说明了AdaBoost算法但训练错误率时不停止训练，可以进一步增大间隔，从而提高学习方法的泛化性而没有过拟合。
也就是AdaBoost算法不易引起过拟合现象。想想真的是超级神奇了。</p>
<ul>
<li><p>AdaBoost VC维泛化误差性
由VC维得到结论：随着迭代轮数的增加，学习器函数空间复杂度增加，从而导致发生过拟合风险。不过这是有问题的。</p></li>
<li><p>AdaBoost Rademaer泛化误差性
可以发现，这里所用的都是利普西子条件来分析的。 ## 8. 一致性
结构风险，1范数-稀疏性，2范数-平均性</p></li>
</ul>
<p>一致性这里研究的就是模型和测试的结果之间是否一致，至少在理论上提供保证。</p>
<p>KNN 经验风险最小化。 Tree 拆分法</p>
<p>所以这里的问题的起点变为了首先给定样本空间和标记空间。D是这两个空间的笛卡尔积的一个联合分布。分布D可分解为边缘分布和条件概率，为什么？
&gt; 因为联合分布的定义就是边缘分布乘以条件概率</p>
<p>若函数给出一个分类器或决策函数，其错误率定义为 &gt;
R(g)=Pr[g(X)!=Y]=E[I_{g(X)!=Y}]</p>
<p>那么，考虑最优分类器及其性质 &gt;
这里应该有理论上最优和基于后验最优。</p>
<p>只考虑所有可测函数，选出最符合后验概率的，作为最优。</p>
<blockquote>
<p>注意这里给定任意的损失函数来做经验风险最小化。
首先按照条件期望展开，然后把g(X)即分类器当做变量。对损失求极值，由此可以得到最优分类器和最优风险。
此时就被称为贝叶斯风险和贝叶斯分类器。</p>
</blockquote>
<blockquote>
<p>注意指示函数非凸不连续做不到效果，所以建议使用对数，指数和sigmoid函数。
如果是凸函数可以得到全局最优解。 各点最小，全局最小。</p>
</blockquote>
<ul>
<li>这里的<span class="math inline">\(\eta(x)=Pr(Y=1|X=x)\)</span>
一种经典的条件概率估计方法：Plug-in学习方法。 &gt;
该学习方法是通过训练数据集来估计<span
class="math inline">\(\eta(x)\)</span>, 即学习器<span
class="math inline">\(g(x)=I[\widehat\eta(x) &gt; \frac {1}{2}]\)</span>
&gt; 这里是训练集预测的结果差异 实际上理解就是少数服从多数</li>
</ul>
<p>然后，将Plug-in学习器与最优分类器的错误率之差建立了与两个n(x)的差的期望</p>
<ul>
<li>拆分算法 &gt;
将示例空间划分为多个互不相交的单元格A1,A2,...。对每个单元格投票的方法赋予标记，还是少数服从多数。</li>
</ul>
<p>A(X)这里表示包含X的单元格。N(X)表示训练集中与示例X落入同一单元格的实例数。</p>
<ul>
<li><p>Box算法</p></li>
<li><p>随机森林一致性</p></li>
<li><p>替换损失函数一致性 &gt; 替换函数一般都需要是凸函数。 &gt;
替换函数一致性是指替换损失的最优解接近于0,1损失的最优解 &gt;
替代函数的种类： &gt; 1. 最小二乘损失函数 <span
class="math inline">\((1-t)^2\)</span> &gt; 2. Hinge损失函数 <span
class="math inline">\(max(0,1-t)\)</span> &gt; 3. 指数损失函数 <span
class="math inline">\(e^{-t}\)</span> &gt; 4. 对数损失函数 <span
class="math inline">\(log(1+e^{-t})\)</span> &gt; 5. 平方Hinge损失函数
<span class="math inline">\((max(0,1-t))^2\)</span></p></li>
</ul>
<h2 id="优化">9. 优化</h2>
<blockquote>
<p>监督学习目的想在未知样本中能预测到好的结果，实际上就是测试数据上的期望的性能。往往思考的时候添加个损失函数，所以就变成了是带损失的期望风险最小化。</p>
</blockquote>
<h3 id="凸优化">9.1 凸优化</h3>
<blockquote>
<p>凸优化求解经验风险最小化 几个概念 1. 凸集合 2. 凸函数的几种判定方式 ?
Jensen不等式有什么性质 凸函数能保证局部最优解就是全局最优解。
一阶条件的理解：可以想象成梯度的等温线然后来做。
一般地，Affine,Exponential,Powers,Powers of absolute value, Negative
entropy都是凸函数 几种合起来的套路：
非负加权、线性加权、max、sup(只需要自由变元满足即可) 3. 共轭函数
注意：无论原函数f是否为凸函数，共轭函数f*都为凸 4. 对偶问题 KKT条件： -
原始问题约束 - 对偶问题约束 - 互补松弛条件 - 原函数梯度为0 5. 优化方法
对于梯度下降，目的就是为了分析其在凸函数情况下的收敛速率。 ?</p>
</blockquote>
<blockquote>
<p>? 所以说可以认为凸优化在这里就对应于定步长的梯度下降。</p>
</blockquote>
<blockquote>
<p>凸优化再思考，凸优化为什么表达式是最优化目标min,小于等于，还有必须是纺织函数；
因为Jensen不等式，所以就有加权函数值小于等于函数值加权，所以就能找到最优化目标。</p>
</blockquote>
<h3 id="随机优化">9.2 随机优化</h3>
<blockquote>
<p>随机优化是类大的引题，随机优化是一种方法，一种思想。然后在机器学习中就对应于经验风险最小化部分。</p>
</blockquote>
<p>随机优化求解有两种方法：样本平均近似和随机近似。</p>
<h4 id="样本平均近似">样本平均近似</h4>
<p>机器学习领域的经验风险最小化。
其核心思想是对随机变量进行独立采样，然后利用定义在m个样本上的平均函数来近似未知的目标函数
&gt; ?，这里的随机变量是R复杂度，还是样本值？什么鬼？</p>
<p>然后衡量的目标就是经验风险最小化学的w，在目标函数上w与目标函数上最优解之间的误差
&gt; 这里的w与F对应的是什么？</p>
<p>然后通过不等式放缩即找
平常情况下的w在目标函数中的值和在样本平均中的值的差</p>
<h4 id="随机近似">随机近似</h4>
<blockquote>
<p>利用目标函数F的有噪声观测直接优化问题，如果可以观测到目标函数值，则称为零阶随机优化；如果可以观测到目标函数的梯度，则称为一阶优化</p>
</blockquote>
<p>两个例子 1. 随机梯度下降</p>
<ol start="2" type="1">
<li>阶段随机梯度下降 阶段</li>
</ol>
<h3 id="完全信息在线学习">9.3 完全信息在线学习</h3>
<blockquote>
<p>这一章以及后面就涉及到在线学习的内容了。在线学习在某种意义上可以看作是学习器与对手之间的博弈过程。完全信息在线学习能观测到全部的信息，赌博机在线学习只能观测到局部的信息。</p>
</blockquote>
<ol type="1">
<li><p>基于专家建议的预测 &gt; 对手给出yt,
每个专家给出自己的意见，然后统帅根据某种方法综合专家的意见（线性或者加权），这种方法带有参数，共N个专家，训练T轮。
&gt;
如何学习最优决策？目标是统帅做出决策所获得的损失和专家的损失和相近。（就是专家最牛，希望自己的决策最终能趋近于专家的决策）</p></li>
<li><p>在线凸优化 &gt;
对于损失函数的选择，从某种意义上感觉来说还是与函数的性质有关。</p></li>
<li><p>在线梯度下降 &gt; 这里分凸函数和强凸函数</p></li>
<li><p>在线牛顿法 &gt; 指数凹函数</p></li>
<li><p>在线批处理转换</p></li>
</ol>
<blockquote>
<p>从某种意义上，可以再看看源码中怎么写的 ### 9.4 赌博机在线学习
对于赌博机来说，学习器预测错误后并不知道正确答案。</p>
</blockquote>
<ol type="1">
<li>多臂赌博机 &gt;
学习器的遗憾就是探索和利用之间的折中；一方面，为了准确均值估计需要探索;另一方面，学习器又倾向于选择最大收益的手臂。</li>
</ol>
<blockquote>
<p>注意选择不能只是选均值大的。</p>
</blockquote>
<blockquote>
<p>评价准则：首先最优选择是什么？事先知道答案，即选择了最优的。那么就是T*Ui;
其次，实际做的是什么？就是每轮真正的选择之和。</p>
</blockquote>
<p>一种做法就是置信上界，为每个手臂维持一个均值加一个变量，注意这个变量定的方式暂时未知。</p>
<ol start="2" type="1">
<li>线性赌博机 &gt;
一个问题，噪声具有分布，怎么观测到噪声，噪声有什么用。</li>
</ol>
<p>首先，这里有个目标；目标可以是最小方差。然后，可以取得一个权重，并根据这个权重找到对应的置信趋于，有置信区域找到上界。然后再根据各个标签的置信区域的上界来找到<span
class="math inline">\(X_{t+1}\)</span>。
然后提交观测的样本，再进行学习。
注意，一些扩展的tips，最小方差，在线最小方差。</p>
<ol start="3" type="1">
<li>凸赌博机</li>
</ol>
<p>在赌博机的设定下，学习器智能观测到损失函数<span
class="math inline">\(f_t\)</span>在决策<span
class="math inline">\(w_t\)</span>上的值<span
class="math inline">\(f(w_t)\)</span>,因此是无法直接应用梯度下降的。
所以这里引入了从函数值估计梯度的技术。
首先在x组成的空间中随机选择一个单位向量，然后学习器根据这个单位向量选择决策<span
class="math inline">\(w_t=z_t+\delta
u_t\)</span>;同时，对手选择一个损失函数。学习器遭受损失，并更新<span
class="math inline">\(z_t\)</span>。值得注意的是这是就能从<span
class="math inline">\(z_t\)</span>近似来做，最终来做凸优化。 ## 补充
#### 1.频率 vs 贝叶斯</p>
<h4 id="频率">频率</h4>
<blockquote>
<p>有上帝之手的感觉，假设事物在冥冥之中服从一个分部，这个分布的参数是未知的，但是是固定的</p>
</blockquote>
<p>最大似然估计MLE:
首先假定一个分布，然后基于最大期望估计得到模型的参数。参数固定。</p>
<h4 id="贝叶斯">贝叶斯</h4>
<blockquote>
<p>世界是不确定的，人们对世界先有一个预判，而后通过观测数据对这个预判进行调整。我们的目标是要找到最优的描述这个世界的概率分布。参数是一个随机变量，符合一定的概率分布。</p>
</blockquote>
<p>最大后验估计MAP: 对世界预判后，不断改变参数找到最适合的分布</p>
<p>过拟合？频率派的专有词 频率学派——最大似然估计 MLE. &gt;
EM算法使用的就是MLE</p>
<p>缓解办法： 1. 添加正则化项 2. 模型集成</p>
<p>贝叶斯学派——最大后验估计MAP</p>
<p>缓解办法： 1. 引入先验，做最大后验估计？ &gt;
认为正则化项实际是一种先验分布，比如u均值的拉普拉斯分布，0均值的高斯分布
2. 计算后验分布的积分（相当于给不同模型进行加权组合）</p>
<h3 id="三种函数的性质">三种函数的性质</h3>
<p>凸函数：局部最优就是全局最优
强凸：只有唯一的最优值，因为表达式中涉及到二阶值，所以此时可以看出强凸有距离的概念。强凸使得前一轮的信息可以直接用到当前论</p>
<h3 id="nothing-is-more-practical-than-a-good-theory">Nothing is more
practical than a good theory!</h3>
<p>Notations - Input space - Fuction: g - Risk of g: 泛化风险 -
Regression function: 回归问题 - Target function: 非回归问题 &gt; ?
后两个是最优的function</p>
<p>普通的策略都是经验风险最小化来得到最优分类器，然后防止过拟合引入正则化项。</p>
<blockquote>
<p>所以必然考虑到基于训练集得到的分类器的误差与最小分类器得到的误差之间的关系。
最优分类器可能没在假设空间中。</p>
</blockquote>
<p>然后根据二次bound可以bound到 <span
class="math inline">\(R(g_n)-R_n(g_n)\)</span>,即generalization下最优误差与经验风险最小化误差的差值。</p>
<p>如果带有损失函数用来分析一致性、稳定性之类，利用Lipschitz条件进行放缩</p>
<p>分析<span class="math inline">\(R(g_n)-R_n(g_n)\)</span>
利用Hoeffding's Inequilty 推出假设空间为有限的界</p>
<p>若假设空间为无限，由秧差得到R复杂度。</p>
<blockquote>
<p>当面对具体算法，因为是凸优化问题；就可以根据分类器即函数的性质得到收敛速率之类的事情。
### 应用 未标签数据的应用： 四种，其中前三种已经有理论证明。 1.
生成式方法。
从有标记数据中学得参数，作用在未标记数据上。然后更新有标记数据集，进而更新参数。
2. 半监督SVM 一次性读入数据，不能中间添加数据。
不能在采样点秘籍的地方穿过 3. 图 标签传播，进行随机游走 4. 一组分类器
基于不一致性进行学习；多视图学习</p>
</blockquote>
<h3 id="generalization">Generalization</h3>
<ul>
<li>证明PAC &gt; 写出最优分类器，然后拆分，然后做</li>
<li>VC &gt; 打散，假设空间可自己构造</li>
<li>算R &gt; 假设带进入做期望</li>
<li>R的性质</li>
</ul>
<ol type="1">
<li>R(aH)=|a|R(H)</li>
<li>R(H1+H2)=R(H1)+R(H2)</li>
<li>R(max(h1,h2)) &lt;= R(h1) + R(h2) &gt; max=<span
class="math inline">\(\frac{1}{2} (x+y+|x-y|)\)</span></li>
</ol>
<ul>
<li>为什么对假设空间进行限制的合理？
因为误差会随假设空间的维度增大而减小</li>
<li>证明最优分类器 &gt; 把一般的表达式写出来，证明最小值即最优</li>
<li>稳定性 &gt; 说明有界，并且证明<span
class="math inline">\(\delta\)</span>可容许</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/nju-course-cplus-lecture7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/nju-course-cplus-lecture7/" class="post-title-link" itemprop="url">nju-course-cplus-lecture7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:59:18" itemprop="dateCreated datePublished" datetime="2019-09-19T09:59:18+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">course</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/" itemprop="url" rel="index"><span itemprop="name">nju</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/cplus/" itemprop="url" rel="index"><span itemprop="name">cplus</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="重点">重点</h1>
<h2
id="转移构造函数转移赋值操作符重载函数">转移构造函数&amp;转移赋值操作符重载函数</h2>
<p>拷贝构造问题
当用一个临时或即将消亡的对象去初始化另一个同类的对象时，目前的拷贝构造函数实现效率不高</p>
<p>主要对应的是一种情况：即当类作为返回值时，调用拷贝构造函数后会立即消亡。</p>
<p>在C++中就提出了一种转移构造函数的概念。</p>
<p>转移构造函数即进行资源转移 A(A&amp;&amp; x) { p=x.p; x.p=NULL; }</p>
<p>赋值操作符重载， 转移赋值操作符重载</p>
<h2 id="函数式逻辑式程序设计">函数式&amp;逻辑式程序设计</h2>
<p>从本质上说，用计算机来解决实际问题就是通过对反映问题本质的数据进行处理来实现的:
程序=算法+数据结构</p>
<p>如何看待和组织算法和数据结构却存在着不同的做法，从而形成不同的程序设计范式：
-
程序设计范式是设计、组织和编写程序的一种方式，它往往要基于一组理论、原则和概念
- 不同的范式将采用不同的程序结构和程序元素来描述程序。 -
范式具有针对性，不同的范式往往适合于解决不同类型的问题。</p>
<ol type="1">
<li>过程式程序设计</li>
</ol>
<ul>
<li>一种以功能为中心、基于功能分解和复合的程序设计范式。</li>
<li>程序由一些子程序构成，每个子程序对应一个子功能。子程序描述了一系列操作，它是操作的封装体，实现了过程抽象。</li>
<li>程序的执行过程体现为一系列的子程序调用</li>
<li>在过程式程序中，数据处于附属地位，它独立于子程序，在子程序调用时通过参数或全局变量传给子程序使用。</li>
</ul>
<ol start="2" type="1">
<li>面向对象程序设计</li>
</ol>
<ul>
<li>一种以数据为中心，基于数据抽象的程序设计范式。</li>
<li>程序由一些对象构成，对象是由一些数据及可施加于这些数据上的操作所组成的封装体。</li>
<li>对象的特征由相应的类来描述，一个类描述的对象特征可以从其它的类获得。</li>
<li>程序的执行过程体现为各个对象之间相互发送和处理消息</li>
<li>在面向对象程序中，数据表现为对象的属性，对数据的操作是通过向包含数据的对象发送消息（调用对象提供的操作）来实现。</li>
</ul>
<ol start="3" type="1">
<li>函数式程序设计</li>
</ol>
<ul>
<li>程序由一组数学函数构成，计算过程体现为一系列的函数应用（把函数作用于数据）</li>
<li>基于的理论是递归函数理论和lambda演算</li>
</ul>
<ol start="4" type="1">
<li>逻辑式程序设计</li>
</ol>
<ul>
<li>程序由一组事实和一组推理规则构成，在事实基础上运用推理规则来实施计算。</li>
<li>基于的理论是谓词演算。</li>
</ul>
<h2 id="命令式声明式程序设计">命令式&amp;声明式程序设计</h2>
<ol type="1">
<li>命令式程序设计</li>
</ol>
<ul>
<li>强调对“如何做”的描述，要对操作步骤和状态变化给出明确的描述。例如，过程式和面向对象程序设计</li>
<li>与冯洛伊曼结构一致，是使用较广泛的程序设计范式，适合于解决大部分的实际应用问题。</li>
</ul>
<ol start="2" type="1">
<li>声明式程序设计</li>
</ol>
<ul>
<li>强调对“做什么”的描述，而如何做则由实现系统自动完成。例如，函数式和逻辑式程序设计</li>
<li>有良好的数学理论支持，并且，设计出的程序具有潜在的并行性。适合于需要大量进行复杂的符号处理（非数值计算）的人工智能领域的应用。</li>
</ul>
<p>函数式程序设计的几个基本特征</p>
<ul>
<li>“纯”函数：引用透明（无副作用，以相同的参数调用函数总得到相同的值）</li>
<li>没有状态（数据不可变）：计算不改变已有数据，而是产生新的数据。（无赋值操作）</li>
<li>函数也是值（first-class citizen)
：函数的参数和返回值都可以是函数。（高阶函数）</li>
<li>表达式的惰性（延迟）求值（Lazy evaluation）：需要的时候才计算。</li>
<li>潜在的并行性。</li>
</ul>
<p>函数式程序设计的几个基本技术</p>
<ul>
<li>递归：实现重复操作，不采用迭代方式（循环）。</li>
<li>尾递归：递归调用是递归函数的最后一步操作，编译可优化之。
就是返回参数的return f(a,b); 这里f(a,b)不应该含有任何运算
尾递归有以下几个好处： 便于编译程序优化：
<ul>
<li>重用本次调用的栈空间</li>
<li>自动转成迭代 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">T f(T1 x1, T2 x2, ...)</span><br><span class="line">&#123;  ......</span><br><span class="line">    ... return f(e1,e2,...);</span><br><span class="line">    ......</span><br><span class="line">    ... return f(e3,e4,...);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">改成：</span><br><span class="line">T f(T1 x1, T2 x2, ...)</span><br><span class="line">&#123;  while (true)</span><br><span class="line">    &#123; ......</span><br><span class="line">       ... &#123; x1 = e1; x2 = e2; ... continue;&#125; </span><br><span class="line">       ......</span><br><span class="line">       ... &#123; x1 = e3; x2 = e4; ... continue;&#125;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>map/reduce（映射/规约）：对一个集合中的元素做映射和规约操作。</li>
<li>currying（柯里化）：把接受多个参数的函数变换成接受单一参数（原函数的第一个参数）的函数，该函数返回一个接收剩余参数的函数。（函数约简）</li>
</ul>
<p>map, reduce操作</p>
<ul>
<li>惰性和并行求值</li>
</ul>
<p>对于一个函数式程序：（示意） a = f1();  //f1是一个纯函数b = f2(); 
//f2是一个纯函数 ...... if (...)  ... a + b ...
由于f1、f2是纯函数，哪个先执行都可以，甚至可以并发执行！
f1、f2也可以到需要它们的时候（a+b）再执行（惰性求值）；如果程序中没用到它们，f1、f2也可以不执行！</p>
<p>逻辑式程序设计简介</p>
<p>程序由一组事实和一组推理规则构成，在事实基础上运用推理规则来实施计算。
基于的理论就是谓词演算</p>
<p>特征 - 数据（事实和规则）就是程序 -
计算（匹配、搜索、回溯）由实现系统自动完成。</p>
<p>语言 Prolog</p>
<blockquote>
<p>逻辑式程序设计是事实和规则作为数据。
给定目标，系统会自动进行搜索来探讨是否有效
函数式程序设计给人的感觉就是运用这些来做。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/nju-course-cplus-lecture6-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/nju-course-cplus-lecture6-summary/" class="post-title-link" itemprop="url">nju-course-cplus-lecture6-summary</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:57:29" itemprop="dateCreated datePublished" datetime="2019-09-19T09:57:29+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">course</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/" itemprop="url" rel="index"><span itemprop="name">nju</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/cplus/" itemprop="url" rel="index"><span itemprop="name">cplus</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>820</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="重点">重点</h1>
<ol type="1">
<li>Window是一种基于图形界面的多任务操作系统。同时多个，交互，用户操作</li>
</ol>
<ul>
<li>两种方式：直接的应用程序，API</li>
<li>应用方式: 单文档、多文档、对话框。 &gt;
单文档是什么？多文档是什么？</li>
</ul>
<p>基于消息驱动的，不断地处理消息</p>
<ol start="2" type="1">
<li>面向过程，基于Windows API
每个应用程序都提供了一个主函数，首先进行注册每一类的窗口，其次创建主窗口，然后进入消息循环。再对消息进行分类处理。
消息还可以生成新的消息。</li>
</ol>
<blockquote>
<p>实际上是Windows将每个窗口都进行了分类，也就是每个窗口和消息都具有总的类别。HWND,
UINT
然后，主窗口接收消息，接收到消息后传递到对应的窗口。对应的窗口可以考虑再进行窗口的改变，再生成新的消息加入消息队列，如此反复，直到消息队列中的消息被完全处理完。</p>
</blockquote>
<p>可重入函数，哪些函数是可以重新调用其他函数的？</p>
<p>资源：程序代码，菜单id，显示文字，对话框类型，尺寸与位置,
存储在相应的资源文件.rc中</p>
<ol start="3" type="1">
<li>面向对象，基于MFC类库的支持 对象： 窗口，文档
应用程序包含成员对象窗口和文档</li>
</ol>
<blockquote>
<p>多文档和单文档，多文档允许同时操作多个文档；单文档只允许操作单个文档。</p>
</blockquote>
<p>然后，所有的分类标准也是从CObject派生的，派生了AA,Ex,FS,A</p>
<p>MFC主要类 - 窗口类 1. 基本窗口类Cwd &gt;
从后面来看这里应该是基类没错了。 2.
框架窗口类应该是基本窗口类的子类或者基本窗口类是它的参数的感觉，因为它要对子窗口进行管理以及提供更多的比如对标题栏、菜单栏、工具栏等的支持。
3. 视类：显示数据。位于多文档框架的可显示区。 4.
对话框类，特殊的弹出来的类 - 文档类 CDocument - 应用框架类 1. 文档模板类
2. 应用类 - 绘图类 - 文件输入/输出类 - 常用数据类型</p>
<p>文档-视结构</p>
<p>CView, CDocument, CFrameWnd, CDocTemplate, CWinApp</p>
<p>应用向导 类向导 &gt; 如何将GUI与面向对象设计联系起来？</p>
<p>GUI设计 - 菜单 - 对话框 消息，成员函数 - 绘图
绘图函数，绘图工具；作用范围 - 坐标变化</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yun-Pan Wang"
      src="/images/default-avatar.png">
  <p class="site-author-name" itemprop="name">Yun-Pan Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">115</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AugF" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AugF" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wangyp@smail.nju.edu.cn" title="E-Mail → mailto:wangyp@smail.nju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/Joswxe" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;Joswxe" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.google.com/" title="https:&#x2F;&#x2F;www.google.com" rel="noopener" target="_blank">Google</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://cn.bing.com/" title="https:&#x2F;&#x2F;cn.bing.com" rel="noopener" target="_blank">Bing</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">Baidu</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">[object Object]</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">466k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:04</span>
</div>!

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://augf.github.io/page/6/',]
      });
      });
  </script>



</body>
</html>
