<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"augf.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Life&#39;s Notes">
<meta property="og:url" content="https://augf.github.io/page/8/index.html">
<meta property="og:site_name" content="Life&#39;s Notes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yun-Pan Wang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://augf.github.io/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Life's Notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Life's Notes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">岁月数载，愿不负韶华</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/nju-course-cplus-lecture1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/nju-course-cplus-lecture1/" class="post-title-link" itemprop="url">nju-course-cplus</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:42:19" itemprop="dateCreated datePublished" datetime="2019-09-19T09:42:19+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">course</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/" itemprop="url" rel="index"><span itemprop="name">nju</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/nju/cplus/" itemprop="url" rel="index"><span itemprop="name">cplus</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="程序设计基础知识回顾">0 程序设计基础知识回顾</h2>
<h3 id="基本">0.1 基本</h3>
<p>程序=算法+数据结构</p>
<p>在程序中，数据类型来描述数据，流程控制语句来实现算法</p>
<p>数据类型规定了两个集合： 1. 值集 2. 操作集</p>
<p>基本数据类型：对应机器指令能直接处理的数据
构造数据类型：由基本数据类型构造出来的数据，枚举、数组、结构、联合、指针、引用</p>
<p>程序实体在内存中的安排 -
静态数据区用于全局变量、static存储类的局部变量及常量的内存分配。如果没有显式初始化，系统将把它们初始化为0
- 代码区用于存放程序的指令 - 栈区用于auto存储类的局部变量 -
堆区用于动态变量的内存分配</p>
<p>对于返回值： - 如果是简单数据类型，通常在寄存器 -
否则，在一块临时内存空间，在调用者的栈空间，调用者把这块空间的地址传给被调用者，被调用者通过这个地址存储返回值</p>
<p>一般情况，不必关心栈的具体情况，进行混合语言编程，需要考虑不同语言在栈上的差别
过深的函数嵌套将造成栈空间不足。
对于参数来说，不应把大的结构按值传递给函数，不应定义很大的局部数组变量。
不要返回局部变量的地址，没有什么输出。 &gt;
这里仿佛懂了为什么不在函数里定义变量，而一般的算法竞赛的代码都在开头定义，因为最终所处的位置不一样。
&gt; 还有一点就是对于函数参数，最后的情况下还是进行地址传递的好。 ###
循环&amp;递归函数 &gt;
循环，重点关注的是退出的元素，即循环判断语句中的内容。</p>
<p>循环对计算机问题求解中的穷举法和迭代法提供支持</p>
<p>分而治之：
把一个问题分解为若干个子问题，而每个子问题的性质与原问题相同，只是在规模上比原问题要小。每个子问题的求解过程可以采用与原问题相同的方式来进行。</p>
<p>递归函数的关键：
递归条件：何时进行递归调用，它描述了问题求解的一般情况，包括：分解和综合过程
结束条件：何时不需递归调用，它描述了问题求解的特殊情况或基本情况</p>
<blockquote>
<p>递归函数中定义的局部变量在运行中分布在栈区中，而非静态数据区，因此此时临时变量将不再有效。所以务必注意在设计递归函数时的变量的要求是否符合实际的要求。
循环是在同一组变量上进行重复操作；递归则是在不同的变量组上进行重复操作
### 指针和引用</p>
</blockquote>
<blockquote>
<p>指针再理解，尽管数据结构是链表，其在底层的存储方式不过是一个一个位置块而已。而指针指向它，不过是指向这些块，并能通过这些块，不断继续能访问到下面的元素。
但是，一点有意思的是，指针就像路标，指示该点的位置。而且用指针可以改变链表后面的组织方式。但指针获得后面元素的指针，对元素之间进行一顿猛操作后。前面的指针依然生效，此时返回前面的指针，就是返回一种新的位置。</p>
</blockquote>
<p>指针只是一个位置的地址，可以在程序中间接来访问，通过p可以访问实参意外的数据，变量的地址；
初始化后，仍可指向其它变量
引用，变量的名字，只能直接访问实参的数据，初始化后，不能再指向其它变量。
&amp;=const *.</p>
<p>&amp;最好用，指向的变量不可改变，但可以在函数中改变其值。 &gt;
引用类型变量 int x=0; int &amp;y=x; //y是引用类型变量，x的别名 y=1;
cout&lt;&lt;x; // x==1
不要返回局部变量的引用，这样返回值可能会被修改。</p>
<p>const int &amp; 不可不改变其值</p>
<p>const int <em>: </em>p=1 X int * const p: p=&amp;x X</p>
<p>const三种用法 1. 放在开头，修饰内容，内容不可Ian const int a=5; const
int <em>p = 8; 2. 放在</em>后面，修饰指针，指针不可变 int a = 8; int*
const p = &amp;a; <em>p = 9; // 正确 int b = 7; p = &amp;b; // 错误 ###
序列数据的表示 #### 1. 静态表示 int a[N]; // N为一个常量或常量表达式
好处：能够快速访问序列元素a[i]: a的首地址+i</em>sizeof(int) #### 2.
动态表示 数据的内存空间随元素数量的变化动态分配 - 动态数组 int <em>p=new
int[n]; //动态分配数组空间，n可以是变量 p[i] //
使用数组元素，等价于</em>(p+i) int *q=new int[n+m] //扩大空间 ...//
元素从p到q的转移 delete []p; // 删除原来的空间 p=q; //p指向新的空间 p[j]
##### <strong>链表</strong>
为每个元素动态分配内存空间，各元素的内存空间不必联系。</p>
<p>为了能把离散的元素空间“串”起来
好处：空间补充容易，增加、删除元素不影响其它元素 strut Node{ int
content; Node <em>next; }; Node </em>head=NULL;</p>
<p>这里的链表头结点也有值. 所以访问时，头结点从第一个元素开始思考。
###### 访问链表元素 &gt; 输入是链表的头结点，目的是返回元素的值</p>
<ul>
<li>访问第i个元素(i=0,1,2,...) <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Node *p=head;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i &amp;&amp; p!=<span class="literal">NULL</span>;j++)&#123;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p!=<span class="literal">NULL</span>)  *p  <span class="comment">//访问第i个元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">设计数单位为i=<span class="number">4</span>，若从<span class="number">0</span>开始。值得注意的是这里</span><br><span class="line">Node *head;</span><br><span class="line">head=L;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp; i) &#123;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>访问指定元素a <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node *p=head;</span><br><span class="line">while(p!=NULL &amp;&amp; p-&gt;content!=a) p=p-&gt;next;</span><br><span class="line">if(p!=NULL) *p //访问元素a</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="在单链表中增加元素">在单链表中增加元素</h6>
<blockquote>
<p>传入旧的链表，目的是返回新的链表。而新的链表由头结点返回标志即可。</p>
</blockquote>
<ul>
<li>分配新元素的空间 Node *p=new Node;</li>
<li>存储元素本身的内容 p-&gt;content=..</li>
<li>找到前一个元素的位置（设由q指向它）
<ul>
<li>按序号找:</li>
<li>按内容找</li>
</ul></li>
<li>把新元素q插入 p-&gt;next=q-&gt;next q-&gt;next=p;</li>
<li>特殊情况的处理！ 在表头增加元素q q-&gt;next=head-&gt;next
head-&gt;next=q; // 错误，这里把head当做空了 ######
在单链表中删除元素</li>
<li>找到前一个元素的位置（由q指向它），要删除p，则 p=q-&gt;next &gt;
删除元素： q-&gt;next=p-&gt;next; delete p;</li>
<li>特殊情况的处理！
<ul>
<li>要删除的元素不存在 &gt;
目的达到了，但关键就是是否需要进行报告所删除的元素不存在。 &gt;
此时遍历到最后一个节点的next节点，p==NULL</li>
<li>删除第一个元素 &gt; Node *p=head; &gt; if(n==0) { &gt; return
head-&gt;next; // &gt; }</li>
</ul></li>
</ul>
<blockquote>
<p>? 如何结合数组与链表的优点？ STL, vector,
可以动态开辟空间，还可以随机访问。 ？</p>
</blockquote>
<h3 id="编译预处理命令">编译预处理命令</h3>
<p>编译预处理命令不是C++程序所要完成的功能，而是用于对编译过程给出指导，其功能有编译预处理系统在编译时候来完成。
编译预处理命令主要有：</p>
<h4 id="include-文件包含命令">#include 文件包含命令</h4>
<p><文件名> 在系统指定目录下寻找文件 "文件名"
现在包含改文件所在目录下寻找指定文件，再找系统文件 &gt;
但是这里找的是工程目录？还是文件目录？</p>
<p>为多模块结构提供了支持 file1.h // 进行全局变量、函数的声明 file1.cpp
// 进行全局变量、函数的定义</p>
<p>file2.h file2.cpp</p>
<p>int main(){ double r; // 局部变量的定义 }</p>
<blockquote>
<p>如果file1.h和file2.h发生冲突怎么办</p>
</blockquote>
<h4 id="define-宏定义命令">#define 宏定义命令</h4>
<p>宏定义常用来定义变量和实现类似函数的功能： &gt; #define
<宏名>(<参数表>) <文字串> 如： #define max(a,b) ((a)&gt;(b) ?
(a):(b))</p>
<p>优点：效率更高
缺点：需要加上很多的括号，否则会出问题；有时会重复计算；替换时不进行参数类型检查和转换；不利于调试</p>
<h4 id="条件编译命令">条件编译命令</h4>
<blockquote>
<p>理解，一种感觉就是编写代码过程中，即实际的代码分布为多个文件，而怎么样把整个文件一起组织呢?
由小往大看，分为局部变量和全局变量。全局变量应该是在运行过程中堆栈中的静态数据区的。所以，这里一方面希望不能冲突
file1.h, file2.h冲突怎么办。
用条件编译设置指示变量来表示将编译哪些内容和不编译哪些内容。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;代码1&gt; 必须编译的代码</span><br><span class="line">#define ABC</span><br><span class="line">&lt;代码2&gt; 必须编译的代码</span><br><span class="line">#ifdef ABC</span><br><span class="line">&lt;代码2&gt; 如果宏名ABC有定义则编译之</span><br><span class="line">#else</span><br><span class="line">&lt;代码3&gt; //如果宏名ABC没有定义，编译之 </span><br><span class="line">#endif</span><br><span class="line">&lt;代码4&gt; //必须编译的代码</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意可以嵌入到代码中执行 宏可以在代码中定义，也可在编译环境中定义</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#if &lt;常量表达式1&gt; / #ifdef &lt;宏名&gt; / #ifndef &lt;宏名&gt;</span><br><span class="line">	&lt;程序段1&gt;</span><br><span class="line">#elif &lt;常量表达式2&gt;</span><br><span class="line">	&lt;程序段2&gt;</span><br><span class="line">......</span><br><span class="line">#elif &lt;常量表达式n&gt;</span><br><span class="line">	&lt;程序段n&gt;</span><br><span class="line">[#else</span><br><span class="line">	&lt;程序段n+1&gt;]</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>作用： &gt; 避免包含头文件带来的重复定义或声明 &gt;
基于多环境的程序编制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">重复包含下面的头文件不会引起多次编译</span><br><span class="line">//module1.h</span><br><span class="line">#ifndef MODULE1</span><br><span class="line">#define MODULE1</span><br><span class="line">......  //module1中的程序实体的声明或定义</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">编译到不同的平台</span><br><span class="line">#ifdef UNIX</span><br><span class="line">	......  //适合于UNIX环境的代码</span><br><span class="line">#elif WINDOWS</span><br><span class="line">	......  //适合于WINDOWS环境的代码</span><br><span class="line">#else</span><br><span class="line">	......  //适合于其它环境的代码</span><br><span class="line">#endif</span><br><span class="line">......  //适合于各种环境的公共代码</span><br><span class="line"></span><br><span class="line">在开发阶段加入的调试信息：</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">......  //调试信息，主要由输出操作构成 </span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/neu-ai-course/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/neu-ai-course/" class="post-title-link" itemprop="url">neu ai course</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:24:12" itemprop="dateCreated datePublished" datetime="2019-09-19T09:24:12+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">course</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/neu/" itemprop="url" rel="index"><span itemprop="name">neu</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/neu/ai/" itemprop="url" rel="index"><span itemprop="name">ai</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="人工智能">人工智能</h2>
<h3 id="智能体与环境">1. 智能体与环境</h3>
<p>智能体：通过传感器感知所处环境并通过执行器对该环境产生作用的计算机程序及其控制的硬件。</p>
<p>任务环境</p>
<p>智能体种类，性能度量，环境，执行器，传感器</p>
<blockquote>
<p>智能体在环境中使用传感器，根据性能度量执行执行器。也就是智能体与环境的一个交互的过程。</p>
<p>任务环境：可观察与不可观察，确定性的与随机的，片段式的与延续式的</p>
<p>基于反射、模型、目标、效用的智能体</p>
</blockquote>
<h3 id="知识表示">2. 知识表示</h3>
<p>多种类别</p>
<ul>
<li><p>一阶谓词</p></li>
<li><p>产生式</p></li>
<li><p>语义网络</p></li>
<li><p>框架</p></li>
<li><p>剧本</p></li>
<li><p>过程</p></li>
<li><p>面向对象</p></li>
<li><p>Petri网</p>
<p>库所和变迁，有向狐，以及令牌等元素组成。</p></li>
<li><p>信念网</p></li>
<li><p>本体论</p></li>
</ul>
<h4 id="状态空间表示法">状态空间表示法</h4>
<p>两种：</p>
<ul>
<li>问题求解状态空间图</li>
<li>完整状态空间图</li>
</ul>
<blockquote>
<p>状态空间法表示法：</p>
<ul>
<li>初试状态集合S</li>
<li>操作F：走步、产生式、规则、数学算子、运算符号或逻辑符号等</li>
<li>目标状态集合G:</li>
</ul>
<p>作用：</p>
<p>提供
了一种新的解题思路，将问题重新表示。可以将实际问题的为无数的小块，将其隐含地转化为状态来做。然后，一种最简单的策略就是看与最终状态的相差值来看是否查看（一般还可以利用其它评价指标，这里突然想到了机器学习，是怎么想到各种评价指标的呢，从某种意义上还可以不停地多套）</p>
</blockquote>
<p>方法：搜索</p>
<blockquote>
<p>八数码问题</p>
</blockquote>
<ul>
<li>不可撤回式</li>
</ul>
<blockquote>
<p>沿一条路径单向延伸搜索</p>
<p>局部知识的利用，比如W(n)最大为原则来选择规则;
但可能停留在局部最优值</p>
</blockquote>
<ul>
<li>可撤回</li>
</ul>
<blockquote>
<ol type="1">
<li>回溯，可修正搜索路径</li>
<li>图搜索，展开式搜索，可保留完整的搜索树</li>
</ol>
</blockquote>
<h3 id="搜索问题">3. 搜索问题</h3>
<blockquote>
<p>状态空间： 由给定问题的所有可能状态组成的空间（全集G）</p>
<p>搜索空间：按某种策略在状态空间中选取的部分空间（G的子集）</p>
<p>解路径：求解问题的一条有效路径</p>
<p>搜索策略的基本思路：搜索空间中必有解路径；如果问题由解，尽量缩小搜索空间，且能否找到最佳解。</p>
<p>搜索策略的评价准则：总体费用最低，费用包括两部分：</p>
<ul>
<li>规则应用费用，执行规则的费用</li>
<li>控制费用：选择规则的费用</li>
</ul>
</blockquote>
<blockquote>
<p>3.1和3.2是无信息搜索策略，3.3是启发式搜索策略</p>
</blockquote>
<h4 id="回溯策略">3.1 回溯策略</h4>
<blockquote>
<p>原问题要选取的点化为多个点，选取每个点即为规则。所以在这里最重要的就是规则的排列，就是如果排列选取规则。</p>
</blockquote>
<h4 id="图搜索">3.2 图搜索</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">算法看上去没有那么复杂：</span><br><span class="line">要点1：</span><br><span class="line">- OPEN: 尚未扩充的节点； CLOSED:已经扩充过的节点</span><br><span class="line">- G中每个节点都唯一地指向一个父节点，意味着只能选取一个来做</span><br><span class="line">- &#123;mi&#125; = &#123;mj&#125; U &#123;mk&#125; U &#123;m1&#125;， 当前被扩充的全部节点=新扩充节点+OPEN+CLOSED</span><br><span class="line">- n是当前被选中的节点，它是OPEN表中排列在最前面的一个节点</span><br><span class="line">- 该算法对于连通图及树都适用</span><br><span class="line"></span><br><span class="line">&gt; 跟DFS不同的是，在扩展完节点后，修改原本已经是黑色节点的最优值，即这些节点的父亲节点可能会进行改变。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>DFS和BFS</p>
<p>BFS的变形：一致性搜索（每个点有评价指标，评价指标最重要），迭代加深搜索（限定深度，先DFS，再BFS）</p>
</blockquote>
<h4 id="启发式图搜索">3.3 启发式图搜索</h4>
<ul>
<li>A算法</li>
<li>爬山算法</li>
<li>分支限界法</li>
<li>动态规划法</li>
<li>A*算法</li>
<li>h函数与A*的关系</li>
<li>A*算法实例</li>
</ul>
<blockquote>
<p>设目标节点从s搜素到t, 中间经过n</p>
<p>定义几个评价指标：</p>
<p>k(s,n): 最佳路径耗散值</p>
<p>c(ni,nk): 路径耗散值等于该路径上所有相邻节点间耗散值的总和。</p>
<ol type="1">
<li>g*(n) = k(s,n):
从初始节点s到节点n的最小耗散值路径的实际耗散值。</li>
<li>h*(n)=min k(n.ti):
从节点n到目标节点集ti中所有节点最小耗散值路径的实际耗散值中的最小值。</li>
<li>f*(n) = g*(n) + h*(n):
从初始节点s约束通过节点n的最小耗散值路径的耗散值。</li>
<li>评价函数：f(n)=g(n)+h(n) 其中 f,g,h为f*,g*,h*的估计值</li>
</ol>
<p>h(n)为启发函数，g(n) &gt;= g*(n)</p>
</blockquote>
<blockquote>
<p>只考虑h(n), 爬山算法；只考虑g(n),分支限界法；</p>
<p>只考虑g(n),动态规划法</p>
<blockquote>
<p>解析，动态规划法仅保留queue中公共节点路径中耗散值最小的路径，余者删除；所以动态规划相比分支限界去掉了公共路径中的冗余部分，提高效率；如果问题空间是树结构，效率相同</p>
<p>？这样看，是BFS的用途；而算法课是DFS的拓扑路径</p>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>A*算法(最佳图搜索算法)</li>
</ul>
<blockquote>
<p>如果算法A有h(n)&lt;h*(n),则为A*算法.</p>
<blockquote>
<p>h*(n): 是n到t的最短的。实际预估的还要短，为什么？凸优化？</p>
<p>h*(n)未说明如何计算，实际上如何计算的？</p>
<p>h(n)=0, BFS.
h(n)越大越好，越接近h*(n)越好，意味着剩下的分支数的减小。</p>
</blockquote>
<p>几个结论：</p>
<blockquote>
<p>A*不结束， 必有f(n)&gt;f*(s)</p>
<p>A*结束前，必有f(n)&lt;f*(n)</p>
<p>对于有限图或无限图，如果存在路径，A*一定成功</p>
<p>A*选中的任何节点f(n)&lt;=f*(s)</p>
</blockquote>
<p>? A*失败的唯一原因是OPEN表为空， 不成立</p>
</blockquote>
<p>h(n)最好满足三角单调性限制，即c(ni,nj)&gt;=h(ni)-h(nj)</p>
<p>g(n)设计：与深度有关，或者路径长度</p>
<p>h(n)设计：当前位置到目标位置的各种距离。</p>
</blockquote>
<ul>
<li>与或图</li>
</ul>
<blockquote>
<p>这个也易于理解，与的话就说明这两步都需要走才行。但有个好奇的问题就是那为什么不直接合并呢</p>
</blockquote>
<p>与节点直接看作是连接节点，那么子节点分解的与节点的个数和为该节点的耗散值。</p>
<p>AO*算法</p>
<p>一般来说首先这里有一个h(n)函数，采用的就是启发式算法；对每个子节点找h(n)最小的，然后走h(n)最小的那条通路；如果走不通，则进行回溯。因为直接会回溯，所以没有g(n)就很正常</p>
<blockquote>
<p>扩展：博弈搜索</p>
<ul>
<li>极大极小搜索</li>
</ul>
<p>博弈搜索属于对抗的这种，即有对抗双方；双方可以进行对抗选择。然后A为先手，所以就想思考如何才能让A获胜。</p>
<p>全局有一个评价函数，评价值越高对A越有利。</p>
<p>因为是下棋所以考虑的就是对抗式搜索。</p>
<p>A想让自己胜利会选择max策略，B想阻止A获胜会选择min策略。</p>
<p>极大极小搜索的策略就是先根据宽度优先生成规定深度的全部博弈树，并计算叶子节点的棋局值。然后，从底向上倒推非端节点的棋局值。最终寻找出一条路径</p>
<p><span class="math inline">\(\alpha\)</span>-<span
class="math inline">\(\beta\)</span>搜索，在极大极小值算法的基础上增加了剪枝功能，并采用深度优先的策略进行搜索。？向上搜索还是向下搜索</p>
<p>很有效，代码不是那么难写，但需要花费一定功夫。</p>
<p>从某种程度上来说还是与子节点的排列顺序有关，即需要先搜索哪个节点</p>
</blockquote>
<h3 id="机器学习概述">机器学习概述</h3>
<p>设计一个学习系统，学习定义：对于某类任务T和性能度量P，如果一个计算机程序在T上以P衡量的性能随着经验E而自我完善，那么我们称这个计算机程序从经验中学习。</p>
<p>对于一个学习问题，必须明确：</p>
<ul>
<li>任务的种类T</li>
<li>衡量标准P</li>
<li>经验的来源E，数据库</li>
</ul>
<p>设计一个学习系统</p>
<p>（以西洋跳棋为例）</p>
<p>选择训练经验、选择目标函数、选择目标函数的表示、选择函数逼近算法（学习算法）、最终设计。</p>
<p>第一个关键属性，训练经验能否为系统的决策提供直接或间接的反馈。</p>
<ul>
<li>系统可从直接的训练样例，即各种棋盘状态和对应的正确走子中学习。</li>
<li>系统可能仅有间接的信息，即很多过去对弈序列和最终结局。（间接学习经验）</li>
</ul>
<p>第二个重要属性，训练样例的分布能多好第表示实例分布，最终系统的性能是通过后者来衡量</p>
<p>例子：西洋跳棋学习问题</p>
<blockquote>
<p>这里展示的只是粗略的模型，其中也是包含技巧的。比如中间通过几个模型组合，然后怎么来做得到最优结果</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/neu-algorithm-course/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/neu-algorithm-course/" class="post-title-link" itemprop="url">neu algorithm course</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:23:01" itemprop="dateCreated datePublished" datetime="2019-09-19T09:23:01+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">course</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/neu/" itemprop="url" rel="index"><span itemprop="name">neu</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/course/neu/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="neu-algorithm">NEU-Algorithm</h2>
<p>主要是为了对比这学期学的算法书与本科学习的清华大学之间教材的区别。</p>
<p>清华大学教材</p>
<ol type="1">
<li>递归分治</li>
<li>动态规划</li>
<li>贪心策略</li>
<li>回溯法，一种复杂版的蛮力的感觉</li>
<li>分支限界法</li>
<li>随机化算法</li>
<li>线性规划与网络流</li>
</ol>
<p>还有一个思考点：</p>
<p>常规思路：</p>
<p>问题， BF1， BF2， 改进，......</p>
<p>大量的题之后</p>
<ol type="1">
<li>对于某道题，什么样的解法能将其搞定？什么样的解法能直觉达到最优</li>
<li>这些方法的适用范围以及时间复杂度</li>
</ol>
<h3 id="回溯法">4. 回溯法</h3>
<blockquote>
<p>从某种意义上感觉，回溯法是用来明确定义了问题的解空间。比如背包问题，有n个物品，则解空间就是{0,1}^N。
但这样下来感觉上有一个问题就是时间复杂度与n有关，不也不一定这样说，应该是说解空间为最多可以容纳多少个解。</p>
<p>！！！这里就涉及到问题的表示方法，即一个问题究竟怎样可以表示地最优</p>
</blockquote>
<p>利用了DFS框架，首先将代解的问题看作一棵搜索树。</p>
<h4 id="对应的问题定义是什么">1）对应的问题定义是什么？</h4>
<p>问题的解向量：回溯法希望一个问题的解可以表示为一个n元式(x1,x2,...,xn)的形式</p>
<p>显约束：对分量Xi的取值限定</p>
<p>隐约束：对于问题的一个实例，解向量满足现实约束条件的所有多元组，构成了该实例的一个解空间。</p>
<p>注意：同一个问题可以有多种表示n，有些表示方法更简单，所需表示的状态空间更小（存储量少，搜索方法简单）p(n)</p>
<h4 id="相关的一些定义">2） 相关的一些定义</h4>
<p>扩展节点：正在产生儿子的节点，即第一类灰色节点，当前最小灰色节点</p>
<p>活节点：一个自身已生成但其儿子还没有全部生成的节点，
即第二类灰色节点，非直系灰色节点</p>
<p>死节点：黑色节点</p>
<h4 id="实现方法">3）实现方法</h4>
<p>问题状态生成方法：</p>
<p>如果对一个扩展节点R，一旦产生了它的一个儿子C，就把C当做新的扩展节点。在完成对子树C的穷尽搜索之后，将R重新变成扩展节点，继续生成下一个儿子。</p>
<p>回溯法：为了避免发生那些不可能产生最佳解的问题状态，要不断地利用限界函数（bounding
function）来处死那些实际上不可能产生所需解的活节点，以减少问题的计算量。</p>
<p>具有限界函数的深度优先方法称为回溯法</p>
<h4 id="基本思想">4）基本思想</h4>
<ul>
<li><p>针对所给问题，定义问题的解空间</p></li>
<li><p>确定易于搜素的解空间结构</p></li>
<li><p>以深度优先方式搜素解空间，并在搜素过程中用剪枝函数避免无效搜素。</p>
<blockquote>
<p>常用剪枝函数：用约束函数在扩展节点处剪去不满足约束的子树；用限界函数剪去得不到最优解的子树。</p>
<p>即两个条件：</p>
<ul>
<li>每个值本身的约束</li>
<li>是否能得到最优解的约束</li>
</ul>
</blockquote></li>
</ul>
<h4 id="时空复杂度分析">5）时空复杂度分析</h4>
<p>空间：由于在搜素过程中是动态产生问题的解空间。所以，在任何时刻，算法只保存从根节点到当前扩展节点的路径即可。所以如果解空间树中从根节点到叶节点的最长路径的长度为h(n)，那么回溯法所需的计算空间通常为O(h(n))。而显式地存储整个解空间需要O(2^{h(n)})或O(h(n)!)内存空间。</p>
<p>时间：</p>
<blockquote>
<p>待处理？</p>
<p>两种分析方法，第一种，从树出发，即本身形成的结构，然后通过树的节点来分析复杂度；第二种，由代码出发，即代码往往能表示很多东西，从代码出发可以</p>
<p>感觉上是 O(2^n), O(n!), 这里n应该是最小表示来说</p>
<p>基于全局，从全局的所有结构中寻找结果，那么可以发现其性能复杂度是高于分支限界法的。</p>
<p>跟动态规划一样是万能解的感觉？</p>
</blockquote>
<h4 id="代码框架">6） 代码框架</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">backtrack-wrapper()&#123;</span><br><span class="line">  bestw = 0</span><br><span class="line">  backtrack(1);</span><br><span class="line">  cout&gt;&gt;bestw&gt;&gt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void backtrack(int t)</span><br><span class="line">&#123;</span><br><span class="line">	if(t&gt;n || solution(x)) &#123;   // 注意这里t&gt;n, solution(x)应该在上一层更好，但是这里也没事。</span><br><span class="line">		temp = output(x); //已经搜索到叶节点; 这里只是输出的当前可行解。</span><br><span class="line">		if (temp &gt; bestw)</span><br><span class="line">			update bestw, bestx;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">		// 排列树，例如任务的调度问题求最节约时间的任务调度，那么实际上求得的结果就是任务的排列。在这里做时考虑将边作为任务。</span><br><span class="line">		for(int i=t;i&lt;=n ;i++ )  //排列数由边构成</span><br><span class="line">			// 这里说明有n个孩子，注意问题已经发生改变</span><br><span class="line">			&lt;对x[i]相关统计量进行处理&gt; </span><br><span class="line">			// 前面的选择在x[i-1]中。</span><br><span class="line">			x[i] = i; // 注意这里需要进行定义</span><br><span class="line">			if (问题仍然未得到解决)</span><br><span class="line">			&#123;</span><br><span class="line">			swap(x[t],x[i]);</span><br><span class="line">			if (legal[t]) backtrack(t+1);</span><br><span class="line">			swap(x[t],x[i]) // 进行恢复</span><br><span class="line">			&#125;</span><br><span class="line">			&lt;对x[i]相关统计量进行恢复&gt;</span><br><span class="line">// 输出 backtrack(1) n=2</span><br><span class="line">// </span><br><span class="line">		</span><br><span class="line">		// 子集树</span><br><span class="line">		if(第一颗子树) &#123;</span><br><span class="line">				//动态变化的结果，等于说这里其实存储的是临时第t层的; 这里是遍历子树</span><br><span class="line">				// 这里会产生带到下一层的变量, 比如说当前使用量cw</span><br><span class="line">				if(constraint(x[t])&amp;&amp;bound(x[t]))  		                          backtrack(t+1);</span><br><span class="line">				//这里是进行子树回溯。为下一阶段同等的子节点做准备		</span><br><span class="line">		&#125;</span><br><span class="line">		if(第二颗子树) &#123;</span><br><span class="line">				...</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		for(int i=f(n,t);i&lt;=g(n,t);i++)  // 所以这里循环的次数就是子节点的个数。</span><br><span class="line">			x[t]=h(i);  h(i)为从f(n,t)到g(n,t)的选择，比如0,1</span><br><span class="line">			具体来说，这里应该再增加一个进行可以对各个子节点记性处理的操作。（</span><br><span class="line">			注意！该操作为什么要加在这里，肯定是在这里啊，想想递归思路）</span><br><span class="line">			if(constraint(x[t])&amp;&amp;bound(x[t]))  		                          backtrack(t+1);</span><br><span class="line">			// 这里可以加某一统计变量，比如说或选址少1啦</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n表示最大递归深度</span><br><span class="line">t表示当前递归深度</span><br><span class="line">i为当前节点对应的子节点</span><br><span class="line">f(n,t): 当前扩展节点未搜索过的子树起始编号；难道还要重新搞起始节点？？？</span><br><span class="line">g(n,t): 当前扩展节点未搜索过的子树终止编号</span><br><span class="line">h(i)为第i个可选的问题表示</span><br><span class="line">x[t]这里是临时变量，可以替代很多情况的。</span><br><span class="line"></span><br><span class="line">constraint: 关于x[t]的约束，只有当前节点的值有关。</span><br><span class="line">bound: 关于能否产生解的约束，与x[t]有关，实际上还与前面的某个统计量有关。这里开始有点联想到那个什么矩阵,一般与剩余量有关。</span><br><span class="line"></span><br><span class="line">n为全局变量，需要提前得出来。</span><br><span class="line">bestw也为全局变量</span><br><span class="line"></span><br><span class="line">思考点： </span><br><span class="line">1. 进行进一步理解？有啥意义</span><br><span class="line">  进行问题结果建模，其中产生了问题结果状态树。所以此时时间复杂度分析是树节点的个数，同时需要考虑其他那些附加函数的复杂度。如果把他们看作1的话，易于分析。</span><br><span class="line">2. 与DFS框架来说有什么关系？</span><br><span class="line">  这里就是一种简单的树的结构，即仅仅只是对树进行DFS遍历而已。而DFS的精华在于对图的处理上。</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">进一步求解最优解和最优路径！</span><br></pre></td></tr></table></figure>
<p>7）其他</p>
<p>优点本质：</p>
<p>回溯法的约束条件是所有解都应满足的条件，所以从某种意义上来说回溯法可以得到所有解，其中包括最优解。</p>
<blockquote>
<p>这个跟图遍历不一样哟。</p>
</blockquote>
<p>但无限界bound函数时，该问题是判定问题，不是最优化问题</p>
<p>8）例子</p>
<p>按解空间为子集树和排列树进行划分</p>
<ul>
<li><p>子集树</p>
<blockquote>
<p>为什么叫子集树？答案的解是问题的解的子集。</p>
<p>问题：</p>
<p>一批n个集装箱要装上重量为c1和c2的轮船，每个集装箱i的重量为wi。且有</p>
<p><span class="math inline">\(\sum_{i=1}^n w_i \leq c_1 +
c_2\)</span>.</p>
<p>试图找出一种方案满足：</p>
<ol type="1">
<li>首先将第一艘轮船尽可能装满</li>
<li>将剩余的集装箱装上第二艘轮船</li>
</ol>
<p>目标：bestw，</p>
<p>其余设置量：cw, bestx, r</p>
<p>解题：</p>
<p>框架的层数对应n。 solution</p>
<p>根节点有两颗子树，选或不选（0/1）</p>
<p>可行性约束函数：<span class="math inline">\(\sum_{i=1}^n w_i x_i \leq
c_1\)</span></p>
<p>上界函数（不选择当前元素）：</p>
<p>当前载重量cw+剩余集装箱的重量r <span
class="math inline">\(\leq\)</span> 当前最优载重量bestw</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">*W</span><br><span class="line">*x</span><br><span class="line">*bestx</span><br><span class="line">bestw</span><br><span class="line">cw = 0</span><br><span class="line"></span><br><span class="line">backtrack-wrapper()&#123;</span><br><span class="line">	backtrack(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">backtrack(int t)&#123;</span><br><span class="line">	if(t&gt;n || solution(x)) &#123;</span><br><span class="line">		查看是否需要更新</span><br><span class="line">		*bestx = *x;</span><br><span class="line">		bestw = cw;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if(cw + x[t] &lt;= c) // 搜索左子树</span><br><span class="line">			x[t] = 1;</span><br><span class="line">			cw += x[t];</span><br><span class="line">			backtrack(t+1);</span><br><span class="line">		if(cw + x[t] &gt; c) // 搜素右子树</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote></li>
<li><p>排列树</p>
<blockquote>
<p>为什么叫排列树？答案的解是问题的解的排列。</p>
<p>问题:</p>
<p>批处理作业调度：给定n个作业的集合{<span
class="math inline">\(J_1,J_2, ..., J_n\)</span>}.
每个作业必须先由机器1处理，然后由机器2处理。作业<span
class="math inline">\(J_i\)</span>需要机器j的处理时间为<span
class="math inline">\(t_{ji}\)</span>。要求对于给定的n个作业，制定最佳作业调度方案，使其完成时间和达到最小。</p>
<p>例子：</p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(t_{j i}\)</span></th>
<th>j1</th>
<th>j2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>i1</td>
<td>2</td>
<td>1</td>
</tr>
<tr class="even">
<td>i2</td>
<td>3</td>
<td>1</td>
</tr>
<tr class="odd">
<td>i3</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>数据结构：</p>
<p>存储: <span class="math inline">\(M[i][j]\)</span>,
注意i表示第i个作业，j表示机器j</p>
<p>注意这里有个问题就是j1上一个结束就可以执行下一个，而j2的话必须是上一个任务结束，下一个任务才能开始。所以数据结构</p>
<p>f1: 当前任务结束时间</p>
<p>f2*: f2[i] = max(f2[i-1], f1) + t2(i-1)</p>
<p>? 这题是否有问题？感觉并不需要最终相加啊</p>
<p>则由此可给出回溯法版的算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">inital M;</span><br><span class="line">bestf</span><br><span class="line">*f2</span><br><span class="line">f1</span><br><span class="line">f</span><br><span class="line">*x</span><br><span class="line">*bestx</span><br><span class="line"></span><br><span class="line">backtrack-wrapper()</span><br><span class="line">&#123;</span><br><span class="line">backtrack(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">backtrack(int t)&#123;</span><br><span class="line">	if(t&gt;n) &#123; // 已经将事情安排完</span><br><span class="line">		*bestx=*x</span><br><span class="line">		bestf=f</span><br><span class="line">		//</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		for(int j=t;j&lt;=n;j++)&#123;</span><br><span class="line">			f1 += M[x[j]][1];</span><br><span class="line">			f2[i] = Max(f2[i-1], f1)+M[x[j]][2];</span><br><span class="line">			f += f2[i];</span><br><span class="line">			if(f &lt; bestf)&#123;</span><br><span class="line">				swap(x[t],x[i]);</span><br><span class="line">				backtrack(t+1);</span><br><span class="line">				swap(x[t],x[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			f1 += M[x[j]][1];</span><br><span class="line">			f2[i] = Max(f2[i-1], f1)+M[x[j]][2];</span><br><span class="line">			f += f2[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote></li>
</ul>
<p>其他例子</p>
<ul>
<li>最大团问题</li>
</ul>
<blockquote>
<p>感觉上进入右子树的时机给的很有问题。</p>
</blockquote>
<ul>
<li>图的m着色问题</li>
</ul>
<blockquote>
<p>教训就是要区分判定问题还是最优化问题</p>
</blockquote>
<h4 id="回溯法效率分析">7）回溯法效率分析</h4>
<p>回溯法取决于以下因素：</p>
<ul>
<li>产生x[k]的时间</li>
<li>满足显约束x[k]值的个数</li>
<li>计算约束函数的时间</li>
<li>计算上界函数的时间</li>
<li>满足约束函数和上界函数约束的所有x[k]的个数</li>
</ul>
<blockquote>
<p>由此可见，在选择约束函数式通常存在生成节点数与约束函数计算量之间的折中。</p>
</blockquote>
<h3 id="分支限界法">5. 分支限界法</h3>
<p>利用BFS框架</p>
<p>试图去寻找问题的一个解或者最优解。</p>
<blockquote>
<p>在分支限界法中，每个活结点只有一次机会成为扩展节点。活节点一旦成为扩展节点，就一次性生成器所有儿子节点。在这些儿子节点中，导致不可行解或导致非最优解的儿子节点被舍弃，其余儿子节点加入活节点链表。</p>
<p>感觉上有点像BestFS的框架的感觉，比较奇妙的以及感觉需要深入思考的就是这里怎么把一些兄弟节点给排除的。</p>
<p>剪枝策略：在算法扩展节点中，一旦发现一个节点的下界不小于当前找到的最短路长，则算法剪去以该节点为根的子树。所以从某种意义上来说是等于还是在基于之前的信息进行剪枝。
所以这里的剪枝函数必然是某种与路径相关的变量。</p>
</blockquote>
<p>2）算法框架</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pq;</span><br><span class="line">cw;</span><br><span class="line">bestw;</span><br><span class="line"></span><br><span class="line">branchBound(s)  // 注意s可以是随机开始的一个点</span><br><span class="line">&#123;</span><br><span class="line">	pq Q;</span><br><span class="line">	Q.add(-1);</span><br><span class="line">	Ew=0;</span><br><span class="line">	bestw=0;</span><br><span class="line">	while(true) &#123;</span><br><span class="line">		for every w of v:</span><br><span class="line">			if(bound(w)) Q.add(w,..);//注意这里可以添加一些其他变量之类的东西。</span><br><span class="line">		// 注意这里可以做一些更新操作。</span><br><span class="line">		Q.delete(v);</span><br><span class="line">		if(v == -1) &#123;</span><br><span class="line">			if(Q.isEmpty) return bestw;</span><br><span class="line">			Q.add(-1);</span><br><span class="line">			Q.delete(Ew);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）算法直观感觉</p>
<p>分支限界法常用来解离散最优解的问题。</p>
<p>算法过程：首先，队列中有第一个元素。然后，对队列中选取的节点的子节点加入到队列中。按照优先级选取某个元素，凡是操作某个元素，对应的临时变量进行更新；当到达叶子节点时，说明开始取得某个最优值。所以此时考虑对队列中小于最优值的进行剪枝。</p>
<p>一个问题就是对于离散树和排列树两种不同的情况应该如何考虑。</p>
<ul>
<li>单源最短路径</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Graph &#123;</span><br><span class="line">n; //顶点数</span><br><span class="line">*prev //前驱顶点数组</span><br><span class="line">**c  // 邻接矩阵</span><br><span class="line">*dist //最短距离数组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MinHeapNode&#123;</span><br><span class="line">i; // 顶点编号</span><br><span class="line">length; //当前路长</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">ShortestPath(s)</span><br><span class="line">// 找出s到其他所有顶点的最短路径。结果在*dist中。</span><br><span class="line">&#125;</span><br><span class="line">ShortestPath(int v)</span><br><span class="line">&#123;</span><br><span class="line">MinHeap&lt;&lt;MinHeapNode&gt;&gt; H(100);</span><br><span class="line">MinHeapNode E;</span><br><span class="line">E.i=v;</span><br><span class="line">E.length=0;</span><br><span class="line">dist[v]=0;</span><br><span class="line">while(true)&#123;</span><br><span class="line">for(int j=1; j&lt;=n;j++)&#123;</span><br><span class="line">	if(c[E.i][j]&lt;inf &amp;&amp; E.length+c[E.i][j]&lt;dist[j]) &#123;</span><br><span class="line">	// 第一个条件表示有边存在， 第二个情况表示比当前的dist[j]还要短</span><br><span class="line">		dist[j] = E.length+c[E.i][j];</span><br><span class="line">		prev[i]=E.i;</span><br><span class="line">		// 加入活节点列表</span><br><span class="line">		MinHeapNode N;</span><br><span class="line">		N.i =i;</span><br><span class="line">		N.length=dist[j]; // 注意这里的更新</span><br><span class="line">		H.Insert(N)</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;H.DeleteMin(E);&#125; // 这里蕴含了取下一个节点。</span><br><span class="line">	catch(OutOfBounds)&#123;break;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>分支限界法有种感觉就是利用层次遍历，首先取一个节点，然后找它的儿子节点。对每个儿子节点扩充，因为是队列，所以处理起来感觉像是并行处理。如果两个节点扩展到同一个节点，那么选取最优的节点，而删除非最优的节点。</p>
<p>从某种意义上说，当源点的多条路遍历结果到达某个节点时，进行比对，选择最优的。</p>
<p>而跟bestfs不同的是，bestfs比较是同时发生一下选定的，而分支限界法是异步发生，异步选定的。</p>
</blockquote>
<h3 id="随机化算法">6. 随机化算法</h3>
<blockquote>
<p>随机化算法的特征是对所求解问题的同一个实例用同一随机化算法求解两次可能得到完全不同的效果。但是会在很大程度上降低时间复杂度。</p>
<p>常见的随机化算法：</p>
<ol type="1">
<li>数字随机化算法，常用于数值问题的求解</li>
<li>蒙特卡洛算法，常用于求问题的精确解</li>
<li>拉斯维加斯算法，不会得到不正确的解</li>
<li>舍伍德算法，求解的算法总是正确的。</li>
</ol>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/algorithm-course-np/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/algorithm-course-np/" class="post-title-link" itemprop="url">algorithm course np</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:21:39" itemprop="dateCreated datePublished" datetime="2019-09-19T09:21:39+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/nju-course/" itemprop="url" rel="index"><span itemprop="name">nju-course</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>84</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="np">NP</h2>
<blockquote>
<p>这里思考一个问题</p>
<ol type="1">
<li><p>A多项式时间可规约到B；</p></li>
<li><p>B多项式时间可规约到C</p></li>
</ol>
<p>问A是否可以多项式时间规约到C？</p>
<p>问题关键在于：b=f(a), c=g(b); 多项式的复合是否还满足要求？</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/algorithm-course-selecting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/algorithm-course-selecting/" class="post-title-link" itemprop="url">algorithm course selecting</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:18:24" itemprop="dateCreated datePublished" datetime="2019-09-19T09:18:24+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/nju-course/" itemprop="url" rel="index"><span itemprop="name">nju-course</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>909</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="selecting">Selecting</h2>
<blockquote>
<p>Selecting的目标是选择出阶为k的元素，即第k小的元素，注意此时寻找的应该是函数值</p>
</blockquote>
<blockquote>
<p>因为是基于比较的选择，即使是选择max,min都需要(n-1)次的比较，所以下界必然是O(n).</p>
<p>随着k的增加，很多时候很有可能到达O(n^2)</p>
<p>所以目标是期望线性时间选择，以及最坏情况线性时间选择</p>
</blockquote>
<h3 id="期望线性时间选择">期望线性时间选择</h3>
<blockquote>
<p>!!!!
这里用到的是快速排序中的partition概念，这很符号第k小元素本身的性质。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">思想： Partition算法是采用使用第一个元素或者其他元素的方式，得到每个划分值。</span><br><span class="line"></span><br><span class="line">search(A,l,r,k)步骤：</span><br><span class="line">0. 如果l==r, 返回</span><br><span class="line">1. 使用Partition算法得到q, x=q-l+1</span><br><span class="line">2. 如果k大于x，则search(A,q+1,r,k-x+1)；如果k等于x，return A[q]; 如果k小于x， 则search(A,l,q-1,k);</span><br><span class="line"></span><br><span class="line">search(A,l,r,k)&#123;</span><br><span class="line">	if (l==r) return A[l];</span><br><span class="line">	</span><br><span class="line">	q = Partition(A,l,r);</span><br><span class="line">	x = q - l + 1;</span><br><span class="line">	</span><br><span class="line">	if(k == x) return A[q];</span><br><span class="line">	if(k &gt; x)</span><br><span class="line">		search(A,q+1,r,k-x+1)</span><br><span class="line">	if(k &lt; x)</span><br><span class="line">		search(A,l,q-1,k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最坏情况线性选择">最坏情况线性选择</h3>
<blockquote>
<p>这里的改进点主要在于是q尽量在中位数附近。</p>
<p>使用我们之前所学到的哪些知识。</p>
</blockquote>
<p>最坏情况线性选择</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">m* = select_median(A, l, r)</span><br><span class="line"></span><br><span class="line">select_median(A, l, r)&#123;</span><br><span class="line">	n = l - r;</span><br><span class="line">	if(n&lt;=5) solve_median(A,l,r);</span><br><span class="line">	else &#123;</span><br><span class="line">		cnt = floor(n/5);</span><br><span class="line">		int[] B=new int[cnt+1];</span><br><span class="line">		for i in &#123;1,..,cnt+1&#125;:</span><br><span class="line">			if i == cnt+1: </span><br><span class="line">				B[i-1]=select_median(A, l+5cnt, r)</span><br><span class="line">			else</span><br><span class="line">				B[i-1]=select_median(A, l+5(i-1), l+5i);</span><br><span class="line">		return select_median(B);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/algorithm-course-searching/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/algorithm-course-searching/" class="post-title-link" itemprop="url">algorithm course searching</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:17:17" itemprop="dateCreated datePublished" datetime="2019-09-19T09:17:17+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/nju-course/" itemprop="url" rel="index"><span itemprop="name">nju-course</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>813</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="searching">Searching</h2>
<h3 id="bf">BF</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">search(v)&#123;</span><br><span class="line"></span><br><span class="line">	for a in array:</span><br><span class="line">		if a.value = v:</span><br><span class="line">			return true;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bst">BST</h3>
<blockquote>
<p>这里研究的关键问题是searching，设为key-value对，那么目标是查找value，一般来说目的是查找该value是否存在，或者更进一步返回位置。</p>
</blockquote>
<blockquote>
<p>由前面分析知，对于searching问题</p>
<ol type="1">
<li>组织为原本的形式，BF O(n)</li>
<li>组织为hash的形式，O(1)</li>
<li>组织为树的结构，O([logn])</li>
</ol>
<p>我们知道，搜索的长度实际上与搜索的树的高度密切相关，所以我们希望寻找平衡的树。</p>
</blockquote>
<blockquote>
<p>本身有多种平衡树的结构，我们这里RBT</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">递归定义，由递归定义无论如何是很容易地去写出原本的结构的。</span><br><span class="line"></span><br><span class="line">RB0</span><br><span class="line"></span><br><span class="line">RB: black (RB/ARB, RB/ARB)</span><br><span class="line"></span><br><span class="line">ARB: red (RB, RB)</span><br><span class="line"></span><br><span class="line">insert()</span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line">class RBTree</span><br><span class="line">	Element root;</span><br><span class="line">	RBtree leftSubtree；</span><br><span class="line">	RBtree rightSubtree;</span><br><span class="line">	int color; // red,black</span><br><span class="line">	</span><br><span class="line">	static class InsReturn</span><br><span class="line">		public RBtree newTree;</span><br><span class="line">		public int status; //ok,rbr,brb,rrb,brr</span><br></pre></td></tr></table></figure>
<h4 id="insertion">Insertion</h4>
<h3 id="hashing">Hashing</h3>
<blockquote>
<p>这里在Insert使用均摊分析， 即ArrayDouble</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Insert</span><br><span class="line">Delete //? 删除是否需要收缩</span><br><span class="line">Find</span><br><span class="line"></span><br><span class="line">hashingInsert(H, x)&#123;</span><br><span class="line">	size = num = 0;</span><br><span class="line">	if size = 0:</span><br><span class="line">		allocate a block of size 1:</span><br><span class="line">		size = 1;</span><br><span class="line">	if num = size:</span><br><span class="line">		allocate a block of size 2size:</span><br><span class="line">		size = 2size;</span><br><span class="line">	insert x into the table;</span><br><span class="line">	num ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/algorithm-course-red-blackTree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/algorithm-course-red-blackTree/" class="post-title-link" itemprop="url">algorithm course red-blackTree</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:16:22" itemprop="dateCreated datePublished" datetime="2019-09-19T09:16:22+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/nju-course/" itemprop="url" rel="index"><span itemprop="name">nju-course</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>301</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="bst">BST</h2>
<blockquote>
<p>这里研究的关键问题是searching，设为key-value对，那么目标是查找value，一般来说目的是查找该value是否存在，或者更进一步返回位置。</p>
</blockquote>
<blockquote>
<p>由前面分析知，对于searching问题</p>
<ol type="1">
<li>组织为原本的形式，BF O(n)</li>
<li>组织为hash的形式，O(1)</li>
<li>组织为树的结构，O([logn])</li>
</ol>
<p>我们知道，搜索的长度实际上与搜索的树的高度密切相关，所以我们希望寻找平衡的树。</p>
</blockquote>
<blockquote>
<p>本身有多种平衡树的结构，我们这里RBT</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">递归定义，由递归定义无论如何是很容易地去写出原本的结构的。</span><br><span class="line"></span><br><span class="line">RB0</span><br><span class="line"></span><br><span class="line">RB: black (RB/ARB, RB/ARB)</span><br><span class="line"></span><br><span class="line">ARB: red (RB, RB)</span><br><span class="line"></span><br><span class="line">insert()</span><br><span class="line">delete()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/algorithm-course-BruteForce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/algorithm-course-BruteForce/" class="post-title-link" itemprop="url">algorithm course BruteForce</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:04:00" itemprop="dateCreated datePublished" datetime="2019-09-19T09:04:00+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/nju-course/" itemprop="url" rel="index"><span itemprop="name">nju-course</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="数学归纳法溯源与公理化思维">1.1 数学归纳法溯源与公理化思维</h2>
<blockquote>
<p>首先我们需要考虑到自然数的定义到底是什么。</p>
<p>一般地，定义$$为0，注意这里参考了维基百科</p>
</blockquote>
<ol type="1">
<li><p>well-ordering principle</p>
<blockquote>
<p>任何非空的自然数集合必然有最小元素，既是最基本的原则。</p>
</blockquote></li>
<li><p>只有一种数学归纳法</p>
<blockquote>
<p>基于良序定理，考虑一组关于自然数的命题P(n).
如果P(n)不是关于所有的自然数都成立，那么必然有P(n)存在最小反例。</p>
<p>如果P(n)不对所有命题都成立，则</p>
<p><span class="math display">\[\exist a \geq 2, P(1) \and P(2) \and ...
\and \neg P(a) = True\]</span></p>
<p>否命题， P(n)对所有命题都成立</p>
<p><span class="math display">\[\exist a \geq 2, P(1) \and P(2) \and ...
\and \neg P(a) = FALSE\]</span></p>
<p>逆否命题</p>
<p><span class="math display">\[\exist a \geq 2, P(1) \and P(2) \and ...
\and P(a-1) \rightarrow P(a) =True\]</span></p>
</blockquote></li>
<li><p>一个错误的数学归纳法证明</p></li>
<li><p>算法正确性证明实例</p></li>
</ol>
<h2 id="极限实数与-n">1.2 极限、实数与$-N $</h2>
<p><span class="math inline">\(\mathbb{N} \Rightarrow
\mathbb{Z}\)</span>: 减法不封闭</p>
<p><span class="math inline">\(\mathbb{Z} \Rightarrow
\mathbb{Q}\)</span>: 除法不封闭</p>
<p><span class="math inline">\(\mathbb{Q} \Rightarrow R\)</span>:
无限，无穷概念的引入</p>
<p><span class="math inline">\(\mathbb{R} \Rightarrow
\mathbb{C}\)</span>: 引入复数域，由于是否存在根的原因</p>
<h2 id="从算法角度重新审视数学的概念">1.3
从算法角度重新审视数学的概念</h2>
<h4 id="一些基本概念">1. 一些基本概念</h4>
<ul>
<li><p>自变量， 通常是自然数</p></li>
<li><p>单调性？</p></li>
<li><p>取整 <span class="math inline">\(\lceil x \rceil , \lfloor x
\rfloor\)</span>, 问题的量往往是自然数级别的</p></li>
<li><p>对数<span class="math inline">\(\log{n}\)</span></p>
<blockquote>
<p>与之相关的现象：</p>
<ol type="1">
<li><p>折半，当问题划分规模为n的问题，经过折半查找，大概<span
class="math inline">\(\log{n}\)</span>次循环问题的规模降为常数。</p></li>
<li><p>完美二叉树，对于一个n个节点的完美二叉树，他的高度为<span
class="math inline">\(\lfloor \log{n} \rfloor\)</span>.</p>
<blockquote>
<ul>
<li><p>完美二叉树的概念</p>
<p>所有外部节点的深度都相同</p></li>
</ul>
</blockquote></li>
<li><p>二进制数的比特数。一个十进制的自然数的二进制表示所需的比特数为<span
class="math inline">\(\lfloor \log{n} \rfloor + 1\)</span>.</p></li>
</ol>
<blockquote>
<p>从数值的角度，二进制数每向右移动一位，比特数减1，数值变为原来的<span
class="math inline">\(\frac{1}{2}\)</span></p>
</blockquote>
</blockquote></li>
<li><p>阶乘</p>
<blockquote>
<p>对于n个完全不同的数，其全排列的个数为<span
class="math inline">\(n!\)</span>.</p>
<p>如果阶乘是连乘形式，通常对它取对数变成求和形式。</p>
<p>这里有个Stirling公式，因为平时用的不多，这里就不补充了</p>
</blockquote></li>
</ul>
<h3 id="常用级数求和">2. 常用级数求和</h3>
<p>求和与算法分析往往关系非常密切。</p>
<ul>
<li><p>多项式级数</p>
<ol type="1">
<li><span class="math inline">\(\sum_{i=1}^n {i} = \frac
{n(n+1)}{2}\)</span></li>
<li><span class="math inline">\(\sum_{i=1}^n i^2 =
\frac{n(n+1)(2n+1)}{6}\)</span></li>
<li><span class="math inline">\(\sum_{i=1}^n i^k = \Theta (\frac{1}{k+1}
n^{k+1})\)</span></li>
</ol></li>
<li><p>几何级数，等比数列，只考虑最大的那项即可</p></li>
<li><p>算术几何级数</p>
<blockquote>
<p><span class="math inline">\(\sum_{i=1}^k i *2^i = (k-1) 2^{k+1} +
2\)</span></p>
</blockquote></li>
<li><p>调和级数</p>
<blockquote>
<p><span class="math inline">\(\sum_{i=1}^k \frac{1}{i} = \ln k +
\Upsilon + \epsilon\)</span></p>
</blockquote></li>
<li><p>斐波拉数列</p></li>
</ul>
<h3 id="期望值-指标随机变量期望的线性特征">3. 期望值，
指标随机变量，期望的线性特征</h3>
<h3 id="蛮力算法">4. <font color='red'>蛮力算法</font></h3>
<ol type="1">
<li><p>微博名人问题: 寻找图中所有人都关注，但是不关注别人的人。</p>
<blockquote>
<p>BF1: 对每个人是否是名人进行判断，时间复杂度为<span
class="math inline">\(O(n^2)\)</span></p>
<p>BF2: 对每一对关系进行思考，根据一对关系，进行将名人进行筛选</p>
<p>本质：集合中的二元关系，所以有算法下界O(n^2) ??</p>
</blockquote></li>
<li><p>频繁项问题特例(出现次数超过一半)的线性时间解</p>
<blockquote>
<p>注意这里实际利用了<span class="math inline">\(f \geq n/2\)</span>
这件事，扩展思考 <strong><span class="math inline">\(f \geq
n/k\)</span></strong></p>
</blockquote></li>
<li><p>候选：交换左右部分，最大和连续子串问题，Maxima问题的非分治解</p></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/algorithm-course-MST/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/algorithm-course-MST/" class="post-title-link" itemprop="url">algorithm course MST</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:02:26" itemprop="dateCreated datePublished" datetime="2019-09-19T09:02:26+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/nju-course/" itemprop="url" rel="index"><span itemprop="name">nju-course</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>556</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="mst">MST</h2>
<blockquote>
<p>注意，MST从某种意义上是图上的应用关于贪心策略的一部分。</p>
</blockquote>
<h3 id="definition">Definition</h3>
<p>定义1. 常规定义： X, S, V/S, e: a lightest edge across (S,V/S)</p>
<p>证明要点：</p>
<p>首先假设cut中的一条e在MST中，然后因为cut中有一条cycle，所以必然有一条边可以构成。所以可以构成一条最小生成树，即取cycle中最小的边。</p>
<p>MST每次都有一部分。</p>
<p>定义2. Reverse-delete方法</p>
<p>delete an 最大权edge if this does not disconnect the graph.</p>
<p>Cycle Property</p>
<p>$T F T': T' F - {e} $</p>
<p>定义3.</p>
<p>10.18 求证：Minimum-weight eage across any cut is unique , so Unique
MST.</p>
<p>证明1：</p>
<p>Construct T by adding all such edges.</p>
<p><span class="math inline">\(e \in \forall MST, T \in \forall
MST\)</span></p>
<p>T is spanning tree eage.</p>
<ul>
<li>construct cycle 连通</li>
<li>no cycle ?</li>
</ul>
<p>证明2：</p>
<p>依赖于某个算法进行证明。</p>
<h3 id="code">Code</h3>
<p>更多地思考</p>
<p>使用递归与分治的策略解决MST问题</p>
<blockquote>
<p>整体思路:</p>
<ol type="1">
<li>将图按点集划分为两个集合，分别求解这两个集合的MST。</li>
<li>然后再找这两个集合之间的最小边，将两个MST一起合并为整个图的MST。</li>
</ol>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://augf.github.io/2019/09/19/algorithm-course-Greedy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default-avatar.png">
      <meta itemprop="name" content="Yun-Pan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Life's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/algorithm-course-Greedy/" class="post-title-link" itemprop="url">algorithm course Greedy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 09:01:25" itemprop="dateCreated datePublished" datetime="2019-09-19T09:01:25+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:05:35" itemprop="dateModified" datetime="2021-05-27T09:05:35+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/nju-course/" itemprop="url" rel="index"><span itemprop="name">nju-course</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="greedy">Greedy</h2>
<blockquote>
<p>Greedy就是BestFS</p>
</blockquote>
<p>Greedy 满足三个条件</p>
<ol type="1">
<li><p>feasible, 即满足约束</p></li>
<li><p>Locally optimal</p></li>
<li><p>Irrevocable: 不可回退</p></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 过程可以看作是不断从candidate中，根据某种策略选择local optimal, 然后更新candidate, 重复选择过程，知道candidate为空，或者已经找到问题的解</span><br><span class="line"></span><br><span class="line">step by step解决问题</span><br><span class="line"></span><br><span class="line">Greedy(candidate) &#123;</span><br><span class="line">	S = null;  // S为解决问题的解集</span><br><span class="line"></span><br><span class="line">	while not solution(S) and candidate != null: &#123;</span><br><span class="line">		choose locally optimal x from candidate;</span><br><span class="line">        </span><br><span class="line">        candidate = candidate - &#123;x&#125;;</span><br><span class="line">        if feasible(x) then S = S + &#123;x&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	if solution(S) return S;</span><br><span class="line">	else return &quot;no solution&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mst">MST</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">primMST(G,n) &#123;</span><br><span class="line"></span><br><span class="line">	initialize the priority queue pq as empty;</span><br><span class="line">	Select vertex s to start the tree;</span><br><span class="line">	Set its candidate edge to (-1, s, 0);</span><br><span class="line">	</span><br><span class="line">	insert(pq, s, 0)</span><br><span class="line">	while(pq is not empty)&#123;	 </span><br><span class="line">         v = getMin(pq); deleteMin(pq);</span><br><span class="line">         add the candidate edge of v to the tree;</span><br><span class="line">         updateFringe(pq, G, v)</span><br><span class="line">	&#125;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updateFringe(pq,G,v)&#123;</span><br><span class="line">	for w that vw in E: //2m loops?</span><br><span class="line">		newWgt = w(v,w)</span><br><span class="line">		if w.status is unseen then</span><br><span class="line">			Set its candidate edge to (v,w newWgt)</span><br><span class="line">			insert(pq,w,newWgt)</span><br><span class="line">		else // w in Fringe, 需要更新在pq中的权值</span><br><span class="line">			if newWgt &lt; getPriorty(pq,w)</span><br><span class="line">				Revise its candidate edge to (v,newWgt) // 记录哪个边才是真正与之相邻</span><br><span class="line">				decreseKey(pq, w, newWgt) // 改变pq中w的权值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?--priorityqueue </span><br><span class="line">- getMin(pq)</span><br><span class="line">- deleteMin(pq)</span><br><span class="line">- insert(pq, w, newWgt)</span><br><span class="line">- decreseKey(pq, w, newWgt)</span><br></pre></td></tr></table></figure>
<h3 id="bestfs">BestFS</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Initialize the priority queue Fringe as empty</span><br><span class="line">while Fringe != empty do</span><br><span class="line">	v: = Fringe.extract-min();</span><br><span class="line">	&lt;process-v&gt;</span><br><span class="line">	update-fringe(v, Fringe)</span><br><span class="line"></span><br><span class="line">subroutine update-fringe(v, Fringe)</span><br><span class="line">	for w of v which is Frensh do</span><br><span class="line">		set the priority of w, insert w to Fringe</span><br><span class="line">	for w of v which is Fringe do</span><br><span class="line">		update the priority if w in Fringe, if necessary.</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yun-Pan Wang"
      src="/images/default-avatar.png">
  <p class="site-author-name" itemprop="name">Yun-Pan Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">115</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AugF" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AugF" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wangyp@smail.nju.edu.cn" title="E-Mail → mailto:wangyp@smail.nju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/Joswxe" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;Joswxe" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.google.com/" title="https:&#x2F;&#x2F;www.google.com" rel="noopener" target="_blank">Google</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://cn.bing.com/" title="https:&#x2F;&#x2F;cn.bing.com" rel="noopener" target="_blank">Bing</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">Baidu</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">[object Object]</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">466k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:04</span>
</div>!

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://augf.github.io/page/8/',]
      });
      });
  </script>



</body>
</html>
